<!-- HTML header for doxygen 1.13.2-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LLZK: lib/Util/SymbolHelper.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<!-- doxygen-awesome extensions -->
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeParagraphLink.init()
    DoxygenAwesomeInteractiveToc.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LLZK<span id="projectnumber">&#160;0.1.0</span>
   </div>
   <div id="projectbrief">Veridise&#39;s ZK Language IR</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('_symbol_helper_8cpp_source.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">SymbolHelper.cpp</div></div>
</div><!--header-->
<div class="contents">
<a href="_symbol_helper_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a id="l00001" name="l00001"></a><span class="lineno">    1</span><span class="comment">//===-- SymbolHelper.cpp - LLZK Symbol Helpers ------------------*- C++ -*-===//</span></div>
<div class="line"><a id="l00002" name="l00002"></a><span class="lineno">    2</span><span class="comment">//</span></div>
<div class="line"><a id="l00003" name="l00003"></a><span class="lineno">    3</span><span class="comment">// Part of the LLZK Project, under the Apache License v2.0.</span></div>
<div class="line"><a id="l00004" name="l00004"></a><span class="lineno">    4</span><span class="comment">// See LICENSE.txt for license information.</span></div>
<div class="line"><a id="l00005" name="l00005"></a><span class="lineno">    5</span><span class="comment">// Copyright 2025 Veridise Inc.</span></div>
<div class="line"><a id="l00006" name="l00006"></a><span class="lineno">    6</span><span class="comment">// SPDX-License-Identifier: Apache-2.0</span></div>
<div class="line"><a id="l00007" name="l00007"></a><span class="lineno">    7</span><span class="comment">//</span></div>
<div class="line"><a id="l00008" name="l00008"></a><span class="lineno">    8</span><span class="comment">//===----------------------------------------------------------------------===//</span></div>
<div class="line"><a id="l00013" name="l00013"></a><span class="lineno">   13</span><span class="comment">//===----------------------------------------------------------------------===//</span></div>
<div class="line"><a id="l00014" name="l00014"></a><span class="lineno">   14</span> </div>
<div class="line"><a id="l00015" name="l00015"></a><span class="lineno">   15</span><span class="preprocessor">#include &quot;<a class="code" href="_array_2_i_r_2_ops_8h.html">llzk/Dialect/Array/IR/Ops.h</a>&quot;</span></div>
<div class="line"><a id="l00016" name="l00016"></a><span class="lineno">   16</span><span class="preprocessor">#include &quot;<a class="code" href="_function_2_i_r_2_ops_8h.html">llzk/Dialect/Function/IR/Ops.h</a>&quot;</span></div>
<div class="line"><a id="l00017" name="l00017"></a><span class="lineno">   17</span><span class="preprocessor">#include &quot;<a class="code" href="_global_2_i_r_2_ops_8h.html">llzk/Dialect/Global/IR/Ops.h</a>&quot;</span></div>
<div class="line"><a id="l00018" name="l00018"></a><span class="lineno">   18</span><span class="preprocessor">#include &quot;<a class="code" href="_polymorphic_2_i_r_2_types_8h.html">llzk/Dialect/Polymorphic/IR/Types.h</a>&quot;</span></div>
<div class="line"><a id="l00019" name="l00019"></a><span class="lineno">   19</span><span class="preprocessor">#include &quot;<a class="code" href="_symbol_helper_8h.html">llzk/Util/SymbolHelper.h</a>&quot;</span></div>
<div class="line"><a id="l00020" name="l00020"></a><span class="lineno">   20</span><span class="preprocessor">#include &quot;<a class="code" href="_symbol_lookup_8h.html">llzk/Util/SymbolLookup.h</a>&quot;</span></div>
<div class="line"><a id="l00021" name="l00021"></a><span class="lineno">   21</span> </div>
<div class="line"><a id="l00022" name="l00022"></a><span class="lineno">   22</span><span class="preprocessor">#include &lt;mlir/IR/BuiltinOps.h&gt;</span></div>
<div class="line"><a id="l00023" name="l00023"></a><span class="lineno">   23</span><span class="preprocessor">#include &lt;mlir/IR/Operation.h&gt;</span></div>
<div class="line"><a id="l00024" name="l00024"></a><span class="lineno">   24</span> </div>
<div class="line"><a id="l00025" name="l00025"></a><span class="lineno">   25</span><span class="preprocessor">#include &lt;llvm/Support/Debug.h&gt;</span></div>
<div class="line"><a id="l00026" name="l00026"></a><span class="lineno">   26</span> </div>
<div class="line"><a id="l00027" name="l00027"></a><span class="lineno"><a class="line" href="_symbol_helper_8cpp.html#ad78e062f62e0d6e453941fb4ca843e4d">   27</a></span><span class="preprocessor">#define DEBUG_TYPE &quot;llzk-symbol-helpers&quot;</span></div>
<div class="line"><a id="l00028" name="l00028"></a><span class="lineno">   28</span> </div>
<div class="line"><a id="l00029" name="l00029"></a><span class="lineno">   29</span><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacemlir.html">mlir</a>;</div>
<div class="line"><a id="l00030" name="l00030"></a><span class="lineno">   30</span> </div>
<div class="line"><a id="l00031" name="l00031"></a><span class="lineno">   31</span><span class="keyword">namespace </span><a class="code hl_namespace" href="namespacellzk.html">llzk</a> {</div>
<div class="line"><a id="l00032" name="l00032"></a><span class="lineno">   32</span> </div>
<div class="line"><a id="l00033" name="l00033"></a><span class="lineno">   33</span><span class="keyword">using namespace </span>array;</div>
<div class="line"><a id="l00034" name="l00034"></a><span class="lineno">   34</span><span class="keyword">using namespace </span>component;</div>
<div class="line"><a id="l00035" name="l00035"></a><span class="lineno">   35</span><span class="keyword">using namespace </span>function;</div>
<div class="line"><a id="l00036" name="l00036"></a><span class="lineno">   36</span><span class="keyword">using namespace </span>global;</div>
<div class="line"><a id="l00037" name="l00037"></a><span class="lineno">   37</span><span class="keyword">using namespace </span>polymorphic;</div>
<div class="line"><a id="l00038" name="l00038"></a><span class="lineno">   38</span> </div>
<div class="line"><a id="l00039" name="l00039"></a><span class="lineno">   39</span><span class="keyword">namespace </span>{</div>
<div class="line"><a id="l00040" name="l00040"></a><span class="lineno">   40</span> </div>
<div class="line"><a id="l00041" name="l00041"></a><span class="lineno">   41</span><span class="keyword">enum</span> RootSelector { CLOSEST, FURTHEST };</div>
<div class="line"><a id="l00042" name="l00042"></a><span class="lineno">   42</span></div>
<div class="line"><a id="l00048" name="l00048"></a><span class="lineno">   48</span>FailureOr&lt;ModuleOp&gt; collectPathToRoot(</div>
<div class="line"><a id="l00049" name="l00049"></a><span class="lineno">   49</span>    Operation *<a class="code hl_variable" href="_l_i_c_e_n_s_e_8txt.html#aaf8226a059307a1b18aac1295b5cf3a2">from</a>, Operation *origin, std::vector&lt;FlatSymbolRefAttr&gt; &amp;path, RootSelector whichRoot</div>
<div class="line"><a id="l00050" name="l00050"></a><span class="lineno">   50</span>) {</div>
<div class="line"><a id="l00051" name="l00051"></a><span class="lineno">   51</span>  Operation *check = <a class="code hl_variable" href="_l_i_c_e_n_s_e_8txt.html#aaf8226a059307a1b18aac1295b5cf3a2">from</a>;</div>
<div class="line"><a id="l00052" name="l00052"></a><span class="lineno">   52</span>  ModuleOp currRoot = <span class="keyword">nullptr</span>;</div>
<div class="line"><a id="l00053" name="l00053"></a><span class="lineno">   53</span>  <span class="keywordflow">do</span> {</div>
<div class="line"><a id="l00054" name="l00054"></a><span class="lineno">   54</span>    <span class="keywordflow">if</span> (ModuleOp m = llvm::dyn_cast_if_present&lt;ModuleOp&gt;(check)) {</div>
<div class="line"><a id="l00055" name="l00055"></a><span class="lineno">   55</span>      <span class="comment">// We need this attribute restriction because some stages of parsing have</span></div>
<div class="line"><a id="l00056" name="l00056"></a><span class="lineno">   56</span>      <span class="comment">//  an extra module wrapping the top-level module from the input file.</span></div>
<div class="line"><a id="l00057" name="l00057"></a><span class="lineno">   57</span>      <span class="comment">// This module, even if it has a name, does not contribute to path names.</span></div>
<div class="line"><a id="l00058" name="l00058"></a><span class="lineno">   58</span>      <span class="keywordflow">if</span> (m-&gt;hasAttr(<a class="code hl_variable" href="namespacellzk.html#a1b66c1ee1b386cb29f255332f586e96d">LANG_ATTR_NAME</a>)) {</div>
<div class="line"><a id="l00059" name="l00059"></a><span class="lineno">   59</span>        <span class="keywordflow">if</span> (whichRoot == RootSelector::CLOSEST) {</div>
<div class="line"><a id="l00060" name="l00060"></a><span class="lineno">   60</span>          <span class="keywordflow">return</span> m;</div>
<div class="line"><a id="l00061" name="l00061"></a><span class="lineno">   61</span>        }</div>
<div class="line"><a id="l00062" name="l00062"></a><span class="lineno">   62</span>        currRoot = m;</div>
<div class="line"><a id="l00063" name="l00063"></a><span class="lineno">   63</span>      }</div>
<div class="line"><a id="l00064" name="l00064"></a><span class="lineno">   64</span>      <span class="keywordflow">if</span> (StringAttr modName = m.getSymNameAttr()) {</div>
<div class="line"><a id="l00065" name="l00065"></a><span class="lineno">   65</span>        path.push_back(FlatSymbolRefAttr::get(modName));</div>
<div class="line"><a id="l00066" name="l00066"></a><span class="lineno">   66</span>      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!currRoot) {</div>
<div class="line"><a id="l00067" name="l00067"></a><span class="lineno">   67</span>        <span class="keywordflow">return</span> origin-&gt;emitOpError()</div>
<div class="line"><a id="l00068" name="l00068"></a><span class="lineno">   68</span>            .append(</div>
<div class="line"><a id="l00069" name="l00069"></a><span class="lineno">   69</span>                <span class="stringliteral">&quot;has ancestor &#39;&quot;</span>, ModuleOp::getOperationName(), <span class="stringliteral">&quot;&#39; without \&quot;&quot;</span>, <a class="code hl_variable" href="namespacellzk.html#a1b66c1ee1b386cb29f255332f586e96d">LANG_ATTR_NAME</a>,</div>
<div class="line"><a id="l00070" name="l00070"></a><span class="lineno">   70</span>                <span class="stringliteral">&quot;\&quot; attribute or a name&quot;</span></div>
<div class="line"><a id="l00071" name="l00071"></a><span class="lineno">   71</span>            )</div>
<div class="line"><a id="l00072" name="l00072"></a><span class="lineno">   72</span>            .attachNote(m.getLoc())</div>
<div class="line"><a id="l00073" name="l00073"></a><span class="lineno">   73</span>            .append(<span class="stringliteral">&quot;unnamed &#39;&quot;</span>, ModuleOp::getOperationName(), <span class="stringliteral">&quot;&#39; here&quot;</span>);</div>
<div class="line"><a id="l00074" name="l00074"></a><span class="lineno">   74</span>      }</div>
<div class="line"><a id="l00075" name="l00075"></a><span class="lineno">   75</span>    }</div>
<div class="line"><a id="l00076" name="l00076"></a><span class="lineno">   76</span>  } <span class="keywordflow">while</span> ((check = check-&gt;getParentOp()));</div>
<div class="line"><a id="l00077" name="l00077"></a><span class="lineno">   77</span> </div>
<div class="line"><a id="l00078" name="l00078"></a><span class="lineno">   78</span>  <span class="keywordflow">if</span> (whichRoot == RootSelector::FURTHEST &amp;&amp; currRoot) {</div>
<div class="line"><a id="l00079" name="l00079"></a><span class="lineno">   79</span>    <span class="keywordflow">return</span> currRoot;</div>
<div class="line"><a id="l00080" name="l00080"></a><span class="lineno">   80</span>  }</div>
<div class="line"><a id="l00081" name="l00081"></a><span class="lineno">   81</span> </div>
<div class="line"><a id="l00082" name="l00082"></a><span class="lineno">   82</span>  <span class="keywordflow">return</span> origin-&gt;emitOpError().append(</div>
<div class="line"><a id="l00083" name="l00083"></a><span class="lineno">   83</span>      <span class="stringliteral">&quot;has no ancestor &#39;&quot;</span>, ModuleOp::getOperationName(), <span class="stringliteral">&quot;&#39; with \&quot;&quot;</span>, <a class="code hl_variable" href="namespacellzk.html#a1b66c1ee1b386cb29f255332f586e96d">LANG_ATTR_NAME</a>, <span class="stringliteral">&quot;\&quot; attribute&quot;</span></div>
<div class="line"><a id="l00084" name="l00084"></a><span class="lineno">   84</span>  );</div>
<div class="line"><a id="l00085" name="l00085"></a><span class="lineno">   85</span>}</div>
<div class="line"><a id="l00086" name="l00086"></a><span class="lineno">   86</span></div>
<div class="line"><a id="l00089" name="l00089"></a><span class="lineno">   89</span>FailureOr&lt;SymbolRefAttr&gt; buildPathFromRoot(</div>
<div class="line"><a id="l00090" name="l00090"></a><span class="lineno">   90</span>    Operation *position, Operation *origin, std::vector&lt;FlatSymbolRefAttr&gt; &amp;&amp;path,</div>
<div class="line"><a id="l00091" name="l00091"></a><span class="lineno">   91</span>    RootSelector whichRoot</div>
<div class="line"><a id="l00092" name="l00092"></a><span class="lineno">   92</span>) {</div>
<div class="line"><a id="l00093" name="l00093"></a><span class="lineno">   93</span>  <span class="comment">// Collect the rest of the path to the root module</span></div>
<div class="line"><a id="l00094" name="l00094"></a><span class="lineno">   94</span>  <span class="keywordflow">if</span> (failed(collectPathToRoot(position, origin, path, whichRoot))) {</div>
<div class="line"><a id="l00095" name="l00095"></a><span class="lineno">   95</span>    <span class="keywordflow">return</span> failure();</div>
<div class="line"><a id="l00096" name="l00096"></a><span class="lineno">   96</span>  }</div>
<div class="line"><a id="l00097" name="l00097"></a><span class="lineno">   97</span>  <span class="comment">// Reverse the vector and convert it to a SymbolRefAttr</span></div>
<div class="line"><a id="l00098" name="l00098"></a><span class="lineno">   98</span>  std::vector&lt;FlatSymbolRefAttr&gt; reversedVec(path.rbegin(), path.rend());</div>
<div class="line"><a id="l00099" name="l00099"></a><span class="lineno">   99</span>  <span class="keywordflow">return</span> <a class="code hl_function" href="namespacellzk.html#ab1ef6741a40f7e02fc0b94c979c8b3be">asSymbolRefAttr</a>(reversedVec);</div>
<div class="line"><a id="l00100" name="l00100"></a><span class="lineno">  100</span>}</div>
<div class="line"><a id="l00101" name="l00101"></a><span class="lineno">  101</span></div>
<div class="line"><a id="l00104" name="l00104"></a><span class="lineno">  104</span>FailureOr&lt;SymbolRefAttr&gt; buildPathFromRoot(</div>
<div class="line"><a id="l00105" name="l00105"></a><span class="lineno">  105</span>    StructDefOp &amp;to, Operation *origin, std::vector&lt;FlatSymbolRefAttr&gt; &amp;&amp;path,</div>
<div class="line"><a id="l00106" name="l00106"></a><span class="lineno">  106</span>    RootSelector whichRoot</div>
<div class="line"><a id="l00107" name="l00107"></a><span class="lineno">  107</span>) {</div>
<div class="line"><a id="l00108" name="l00108"></a><span class="lineno">  108</span>  <span class="comment">// Add the name of the struct (its name is not optional) and then delegate to helper</span></div>
<div class="line"><a id="l00109" name="l00109"></a><span class="lineno">  109</span>  path.push_back(FlatSymbolRefAttr::get(to.getSymNameAttr()));</div>
<div class="line"><a id="l00110" name="l00110"></a><span class="lineno">  110</span>  <span class="keywordflow">return</span> buildPathFromRoot(to.getOperation(), origin, std::move(path), whichRoot);</div>
<div class="line"><a id="l00111" name="l00111"></a><span class="lineno">  111</span>}</div>
<div class="line"><a id="l00112" name="l00112"></a><span class="lineno">  112</span> </div>
<div class="line"><a id="l00113" name="l00113"></a><span class="lineno">  113</span>FailureOr&lt;SymbolRefAttr&gt; <a class="code hl_function" href="namespacellzk.html#a17e5f2ed35eb7b924e98864bc950b296">getPathFromRoot</a>(StructDefOp &amp;to, RootSelector whichRoot) {</div>
<div class="line"><a id="l00114" name="l00114"></a><span class="lineno">  114</span>  std::vector&lt;FlatSymbolRefAttr&gt; path;</div>
<div class="line"><a id="l00115" name="l00115"></a><span class="lineno">  115</span>  <span class="keywordflow">return</span> buildPathFromRoot(to, to.getOperation(), std::move(path), whichRoot);</div>
<div class="line"><a id="l00116" name="l00116"></a><span class="lineno">  116</span>}</div>
<div class="line"><a id="l00117" name="l00117"></a><span class="lineno">  117</span> </div>
<div class="line"><a id="l00118" name="l00118"></a><span class="lineno">  118</span>FailureOr&lt;SymbolRefAttr&gt; <a class="code hl_function" href="namespacellzk.html#a17e5f2ed35eb7b924e98864bc950b296">getPathFromRoot</a>(FuncDefOp &amp;to, RootSelector whichRoot) {</div>
<div class="line"><a id="l00119" name="l00119"></a><span class="lineno">  119</span>  std::vector&lt;FlatSymbolRefAttr&gt; path;</div>
<div class="line"><a id="l00120" name="l00120"></a><span class="lineno">  120</span>  <span class="comment">// Add the name of the function (its name is not optional)</span></div>
<div class="line"><a id="l00121" name="l00121"></a><span class="lineno">  121</span>  path.push_back(FlatSymbolRefAttr::get(to.getSymNameAttr()));</div>
<div class="line"><a id="l00122" name="l00122"></a><span class="lineno">  122</span> </div>
<div class="line"><a id="l00123" name="l00123"></a><span class="lineno">  123</span>  <span class="comment">// Delegate based on the type of the parent op</span></div>
<div class="line"><a id="l00124" name="l00124"></a><span class="lineno">  124</span>  Operation *current = to.getOperation();</div>
<div class="line"><a id="l00125" name="l00125"></a><span class="lineno">  125</span>  Operation *parent = current-&gt;getParentOp();</div>
<div class="line"><a id="l00126" name="l00126"></a><span class="lineno">  126</span>  <span class="keywordflow">if</span> (StructDefOp parentStruct = llvm::dyn_cast_if_present&lt;StructDefOp&gt;(parent)) {</div>
<div class="line"><a id="l00127" name="l00127"></a><span class="lineno">  127</span>    <span class="keywordflow">return</span> buildPathFromRoot(parentStruct, current, std::move(path), whichRoot);</div>
<div class="line"><a id="l00128" name="l00128"></a><span class="lineno">  128</span>  } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ModuleOp parentMod = llvm::dyn_cast_if_present&lt;ModuleOp&gt;(parent)) {</div>
<div class="line"><a id="l00129" name="l00129"></a><span class="lineno">  129</span>    <span class="keywordflow">return</span> buildPathFromRoot(parentMod.getOperation(), current, std::move(path), whichRoot);</div>
<div class="line"><a id="l00130" name="l00130"></a><span class="lineno">  130</span>  } <span class="keywordflow">else</span> {</div>
<div class="line"><a id="l00131" name="l00131"></a><span class="lineno">  131</span>    <span class="comment">// This is an error in the compiler itself. In current implementation,</span></div>
<div class="line"><a id="l00132" name="l00132"></a><span class="lineno">  132</span>    <span class="comment">//  FuncDefOp must have either StructDefOp or ModuleOp as its parent.</span></div>
<div class="line"><a id="l00133" name="l00133"></a><span class="lineno">  133</span>    <span class="keywordflow">return</span> current-&gt;emitError().append(<span class="stringliteral">&quot;orphaned &#39;&quot;</span>, <a class="code hl_function" href="classllzk_1_1function_1_1_func_def_op.html#acbf62a48d4e47cdc1c346e19c0e3577b">FuncDefOp::getOperationName</a>(), <span class="stringliteral">&quot;&#39;&quot;</span>);</div>
<div class="line"><a id="l00134" name="l00134"></a><span class="lineno">  134</span>  }</div>
<div class="line"><a id="l00135" name="l00135"></a><span class="lineno">  135</span>}</div>
<div class="line"><a id="l00136" name="l00136"></a><span class="lineno">  136</span>} <span class="comment">// namespace</span></div>
<div class="line"><a id="l00137" name="l00137"></a><span class="lineno">  137</span> </div>
<div class="foldopen" id="foldopen00138" data-start="{" data-end="}">
<div class="line"><a id="l00138" name="l00138"></a><span class="lineno"><a class="line" href="namespacellzk.html#a3395beb30b5d17bc8a968b14eb3638d6">  138</a></span>llvm::SmallVector&lt;StringRef&gt; <a class="code hl_function" href="namespacellzk.html#a3395beb30b5d17bc8a968b14eb3638d6">getNames</a>(SymbolRefAttr ref) {</div>
<div class="line"><a id="l00139" name="l00139"></a><span class="lineno">  139</span>  llvm::SmallVector&lt;StringRef&gt; <a class="code hl_variable" href="_l_i_c_e_n_s_e_8txt.html#a30594132172b3373a0a76459eed4796e">names</a>;</div>
<div class="line"><a id="l00140" name="l00140"></a><span class="lineno">  140</span>  <a class="code hl_variable" href="_l_i_c_e_n_s_e_8txt.html#a30594132172b3373a0a76459eed4796e">names</a>.push_back(ref.getRootReference().getValue());</div>
<div class="line"><a id="l00141" name="l00141"></a><span class="lineno">  141</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> FlatSymbolRefAttr &amp;r : ref.getNestedReferences()) {</div>
<div class="line"><a id="l00142" name="l00142"></a><span class="lineno">  142</span>    <a class="code hl_variable" href="_l_i_c_e_n_s_e_8txt.html#a30594132172b3373a0a76459eed4796e">names</a>.push_back(r.getValue());</div>
<div class="line"><a id="l00143" name="l00143"></a><span class="lineno">  143</span>  }</div>
<div class="line"><a id="l00144" name="l00144"></a><span class="lineno">  144</span>  <span class="keywordflow">return</span> <a class="code hl_variable" href="_l_i_c_e_n_s_e_8txt.html#a30594132172b3373a0a76459eed4796e">names</a>;</div>
<div class="line"><a id="l00145" name="l00145"></a><span class="lineno">  145</span>}</div>
</div>
<div class="line"><a id="l00146" name="l00146"></a><span class="lineno">  146</span> </div>
<div class="foldopen" id="foldopen00147" data-start="{" data-end="}">
<div class="line"><a id="l00147" name="l00147"></a><span class="lineno"><a class="line" href="namespacellzk.html#aefd24a67a7806996a53b63a5014c82a2">  147</a></span>llvm::SmallVector&lt;FlatSymbolRefAttr&gt; <a class="code hl_function" href="namespacellzk.html#aefd24a67a7806996a53b63a5014c82a2">getPieces</a>(SymbolRefAttr ref) {</div>
<div class="line"><a id="l00148" name="l00148"></a><span class="lineno">  148</span>  llvm::SmallVector&lt;FlatSymbolRefAttr&gt; pieces;</div>
<div class="line"><a id="l00149" name="l00149"></a><span class="lineno">  149</span>  pieces.push_back(FlatSymbolRefAttr::get(ref.getRootReference()));</div>
<div class="line"><a id="l00150" name="l00150"></a><span class="lineno">  150</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> FlatSymbolRefAttr &amp;r : ref.getNestedReferences()) {</div>
<div class="line"><a id="l00151" name="l00151"></a><span class="lineno">  151</span>    pieces.push_back(r);</div>
<div class="line"><a id="l00152" name="l00152"></a><span class="lineno">  152</span>  }</div>
<div class="line"><a id="l00153" name="l00153"></a><span class="lineno">  153</span>  <span class="keywordflow">return</span> pieces;</div>
<div class="line"><a id="l00154" name="l00154"></a><span class="lineno">  154</span>}</div>
</div>
<div class="line"><a id="l00155" name="l00155"></a><span class="lineno">  155</span> </div>
<div class="line"><a id="l00156" name="l00156"></a><span class="lineno">  156</span><span class="keyword">namespace </span>{</div>
<div class="line"><a id="l00157" name="l00157"></a><span class="lineno">  157</span> </div>
<div class="line"><a id="l00158" name="l00158"></a><span class="lineno">  158</span>SymbolRefAttr changeLeafImpl(</div>
<div class="line"><a id="l00159" name="l00159"></a><span class="lineno">  159</span>    StringAttr origRoot, ArrayRef&lt;FlatSymbolRefAttr&gt; origTail, FlatSymbolRefAttr newLeaf,</div>
<div class="line"><a id="l00160" name="l00160"></a><span class="lineno">  160</span>    <span class="keywordtype">size_t</span> drop = 1</div>
<div class="line"><a id="l00161" name="l00161"></a><span class="lineno">  161</span>) {</div>
<div class="line"><a id="l00162" name="l00162"></a><span class="lineno">  162</span>  llvm::SmallVector&lt;FlatSymbolRefAttr&gt; newTail;</div>
<div class="line"><a id="l00163" name="l00163"></a><span class="lineno">  163</span>  newTail.append(origTail.begin(), origTail.drop_back(drop).end());</div>
<div class="line"><a id="l00164" name="l00164"></a><span class="lineno">  164</span>  newTail.push_back(newLeaf);</div>
<div class="line"><a id="l00165" name="l00165"></a><span class="lineno">  165</span>  <span class="keywordflow">return</span> SymbolRefAttr::get(origRoot, newTail);</div>
<div class="line"><a id="l00166" name="l00166"></a><span class="lineno">  166</span>}</div>
<div class="line"><a id="l00167" name="l00167"></a><span class="lineno">  167</span> </div>
<div class="line"><a id="l00168" name="l00168"></a><span class="lineno">  168</span>} <span class="comment">// namespace</span></div>
<div class="line"><a id="l00169" name="l00169"></a><span class="lineno">  169</span> </div>
<div class="foldopen" id="foldopen00170" data-start="{" data-end="}">
<div class="line"><a id="l00170" name="l00170"></a><span class="lineno"><a class="line" href="namespacellzk.html#a6233c90d2afb42113aa36eddeebd8f76">  170</a></span>SymbolRefAttr <a class="code hl_function" href="namespacellzk.html#a6233c90d2afb42113aa36eddeebd8f76">replaceLeaf</a>(SymbolRefAttr orig, FlatSymbolRefAttr newLeaf) {</div>
<div class="line"><a id="l00171" name="l00171"></a><span class="lineno">  171</span>  ArrayRef&lt;FlatSymbolRefAttr&gt; origTail = orig.getNestedReferences();</div>
<div class="line"><a id="l00172" name="l00172"></a><span class="lineno">  172</span>  <span class="keywordflow">if</span> (origTail.empty()) {</div>
<div class="line"><a id="l00173" name="l00173"></a><span class="lineno">  173</span>    <span class="comment">// If there is no tail, the root is the leaf so replace the whole thing</span></div>
<div class="line"><a id="l00174" name="l00174"></a><span class="lineno">  174</span>    <span class="keywordflow">return</span> newLeaf;</div>
<div class="line"><a id="l00175" name="l00175"></a><span class="lineno">  175</span>  } <span class="keywordflow">else</span> {</div>
<div class="line"><a id="l00176" name="l00176"></a><span class="lineno">  176</span>    <span class="keywordflow">return</span> changeLeafImpl(orig.getRootReference(), origTail, newLeaf);</div>
<div class="line"><a id="l00177" name="l00177"></a><span class="lineno">  177</span>  }</div>
<div class="line"><a id="l00178" name="l00178"></a><span class="lineno">  178</span>}</div>
</div>
<div class="line"><a id="l00179" name="l00179"></a><span class="lineno">  179</span> </div>
<div class="foldopen" id="foldopen00180" data-start="{" data-end="}">
<div class="line"><a id="l00180" name="l00180"></a><span class="lineno"><a class="line" href="namespacellzk.html#a5a8f8e48ae6b42bbfbccc3b9a58e642d">  180</a></span>SymbolRefAttr <a class="code hl_function" href="namespacellzk.html#a5a8f8e48ae6b42bbfbccc3b9a58e642d">appendLeaf</a>(SymbolRefAttr orig, FlatSymbolRefAttr newLeaf) {</div>
<div class="line"><a id="l00181" name="l00181"></a><span class="lineno">  181</span>  <span class="keywordflow">return</span> changeLeafImpl(orig.getRootReference(), orig.getNestedReferences(), newLeaf, 0);</div>
<div class="line"><a id="l00182" name="l00182"></a><span class="lineno">  182</span>}</div>
</div>
<div class="line"><a id="l00183" name="l00183"></a><span class="lineno">  183</span> </div>
<div class="foldopen" id="foldopen00184" data-start="{" data-end="}">
<div class="line"><a id="l00184" name="l00184"></a><span class="lineno"><a class="line" href="namespacellzk.html#a1834ce0bbea39a5089abc81e496ea685">  184</a></span>SymbolRefAttr <a class="code hl_function" href="namespacellzk.html#a1834ce0bbea39a5089abc81e496ea685">appendLeafName</a>(SymbolRefAttr orig, <span class="keyword">const</span> Twine &amp;newLeafSuffix) {</div>
<div class="line"><a id="l00185" name="l00185"></a><span class="lineno">  185</span>  ArrayRef&lt;FlatSymbolRefAttr&gt; origTail = orig.getNestedReferences();</div>
<div class="line"><a id="l00186" name="l00186"></a><span class="lineno">  186</span>  <span class="keywordflow">if</span> (origTail.empty()) {</div>
<div class="line"><a id="l00187" name="l00187"></a><span class="lineno">  187</span>    <span class="comment">// If there is no tail, the root is the leaf so append on the root instead</span></div>
<div class="line"><a id="l00188" name="l00188"></a><span class="lineno">  188</span>    <span class="keywordflow">return</span> <a class="code hl_function" href="namespacellzk.html#a301a571a8339726388d6173ba81b5283">getFlatSymbolRefAttr</a>(</div>
<div class="line"><a id="l00189" name="l00189"></a><span class="lineno">  189</span>        orig.getContext(), orig.getRootReference().getValue() + newLeafSuffix</div>
<div class="line"><a id="l00190" name="l00190"></a><span class="lineno">  190</span>    );</div>
<div class="line"><a id="l00191" name="l00191"></a><span class="lineno">  191</span>  } <span class="keywordflow">else</span> {</div>
<div class="line"><a id="l00192" name="l00192"></a><span class="lineno">  192</span>    <span class="keywordflow">return</span> changeLeafImpl(</div>
<div class="line"><a id="l00193" name="l00193"></a><span class="lineno">  193</span>        orig.getRootReference(), origTail,</div>
<div class="line"><a id="l00194" name="l00194"></a><span class="lineno">  194</span>        <a class="code hl_function" href="namespacellzk.html#a301a571a8339726388d6173ba81b5283">getFlatSymbolRefAttr</a>(orig.getContext(), origTail.back().getValue() + newLeafSuffix)</div>
<div class="line"><a id="l00195" name="l00195"></a><span class="lineno">  195</span>    );</div>
<div class="line"><a id="l00196" name="l00196"></a><span class="lineno">  196</span>  }</div>
<div class="line"><a id="l00197" name="l00197"></a><span class="lineno">  197</span>}</div>
</div>
<div class="line"><a id="l00198" name="l00198"></a><span class="lineno">  198</span> </div>
<div class="foldopen" id="foldopen00199" data-start="{" data-end="}">
<div class="line"><a id="l00199" name="l00199"></a><span class="lineno"><a class="line" href="namespacellzk.html#a44fd8ecd88f8e6b80079bf6c1328412a">  199</a></span>FailureOr&lt;ModuleOp&gt; <a class="code hl_function" href="namespacellzk.html#a44fd8ecd88f8e6b80079bf6c1328412a">getRootModule</a>(Operation *<a class="code hl_variable" href="_l_i_c_e_n_s_e_8txt.html#aaf8226a059307a1b18aac1295b5cf3a2">from</a>) {</div>
<div class="line"><a id="l00200" name="l00200"></a><span class="lineno">  200</span>  std::vector&lt;FlatSymbolRefAttr&gt; path;</div>
<div class="line"><a id="l00201" name="l00201"></a><span class="lineno">  201</span>  <span class="keywordflow">return</span> collectPathToRoot(<a class="code hl_variable" href="_l_i_c_e_n_s_e_8txt.html#aaf8226a059307a1b18aac1295b5cf3a2">from</a>, <a class="code hl_variable" href="_l_i_c_e_n_s_e_8txt.html#aaf8226a059307a1b18aac1295b5cf3a2">from</a>, path, RootSelector::CLOSEST);</div>
<div class="line"><a id="l00202" name="l00202"></a><span class="lineno">  202</span>}</div>
</div>
<div class="line"><a id="l00203" name="l00203"></a><span class="lineno">  203</span> </div>
<div class="foldopen" id="foldopen00204" data-start="{" data-end="}">
<div class="line"><a id="l00204" name="l00204"></a><span class="lineno"><a class="line" href="namespacellzk.html#a17e5f2ed35eb7b924e98864bc950b296">  204</a></span>FailureOr&lt;SymbolRefAttr&gt; <a class="code hl_function" href="namespacellzk.html#a17e5f2ed35eb7b924e98864bc950b296">getPathFromRoot</a>(<a class="code hl_class" href="classllzk_1_1component_1_1_struct_def_op.html">StructDefOp</a> &amp;to) {</div>
<div class="line"><a id="l00205" name="l00205"></a><span class="lineno">  205</span>  <span class="keywordflow">return</span> <a class="code hl_function" href="namespacellzk.html#a17e5f2ed35eb7b924e98864bc950b296">getPathFromRoot</a>(to, RootSelector::CLOSEST);</div>
<div class="line"><a id="l00206" name="l00206"></a><span class="lineno">  206</span>}</div>
</div>
<div class="line"><a id="l00207" name="l00207"></a><span class="lineno">  207</span> </div>
<div class="foldopen" id="foldopen00208" data-start="{" data-end="}">
<div class="line"><a id="l00208" name="l00208"></a><span class="lineno"><a class="line" href="namespacellzk.html#ab257f68cb79cff1e1f3f992a3cd86168">  208</a></span>FailureOr&lt;SymbolRefAttr&gt; <a class="code hl_function" href="namespacellzk.html#a17e5f2ed35eb7b924e98864bc950b296">getPathFromRoot</a>(<a class="code hl_class" href="classllzk_1_1function_1_1_func_def_op.html">FuncDefOp</a> &amp;to) {</div>
<div class="line"><a id="l00209" name="l00209"></a><span class="lineno">  209</span>  <span class="keywordflow">return</span> <a class="code hl_function" href="namespacellzk.html#a17e5f2ed35eb7b924e98864bc950b296">getPathFromRoot</a>(to, RootSelector::CLOSEST);</div>
<div class="line"><a id="l00210" name="l00210"></a><span class="lineno">  210</span>}</div>
</div>
<div class="line"><a id="l00211" name="l00211"></a><span class="lineno">  211</span> </div>
<div class="foldopen" id="foldopen00212" data-start="{" data-end="}">
<div class="line"><a id="l00212" name="l00212"></a><span class="lineno"><a class="line" href="namespacellzk.html#a858ad75166540367bf85ae38bc875707">  212</a></span>FailureOr&lt;ModuleOp&gt; <a class="code hl_function" href="namespacellzk.html#a858ad75166540367bf85ae38bc875707">getTopRootModule</a>(Operation *<a class="code hl_variable" href="_l_i_c_e_n_s_e_8txt.html#aaf8226a059307a1b18aac1295b5cf3a2">from</a>) {</div>
<div class="line"><a id="l00213" name="l00213"></a><span class="lineno">  213</span>  std::vector&lt;FlatSymbolRefAttr&gt; path;</div>
<div class="line"><a id="l00214" name="l00214"></a><span class="lineno">  214</span>  <span class="keywordflow">return</span> collectPathToRoot(<a class="code hl_variable" href="_l_i_c_e_n_s_e_8txt.html#aaf8226a059307a1b18aac1295b5cf3a2">from</a>, <a class="code hl_variable" href="_l_i_c_e_n_s_e_8txt.html#aaf8226a059307a1b18aac1295b5cf3a2">from</a>, path, RootSelector::FURTHEST);</div>
<div class="line"><a id="l00215" name="l00215"></a><span class="lineno">  215</span>}</div>
</div>
<div class="line"><a id="l00216" name="l00216"></a><span class="lineno">  216</span> </div>
<div class="foldopen" id="foldopen00217" data-start="{" data-end="}">
<div class="line"><a id="l00217" name="l00217"></a><span class="lineno"><a class="line" href="namespacellzk.html#a75fdc2fe83e3eca6b6c048deac2b22ab">  217</a></span>FailureOr&lt;SymbolRefAttr&gt; <a class="code hl_function" href="namespacellzk.html#a75fdc2fe83e3eca6b6c048deac2b22ab">getPathFromTopRoot</a>(<a class="code hl_class" href="classllzk_1_1component_1_1_struct_def_op.html">StructDefOp</a> &amp;to) {</div>
<div class="line"><a id="l00218" name="l00218"></a><span class="lineno">  218</span>  <span class="keywordflow">return</span> <a class="code hl_function" href="namespacellzk.html#a17e5f2ed35eb7b924e98864bc950b296">getPathFromRoot</a>(to, RootSelector::FURTHEST);</div>
<div class="line"><a id="l00219" name="l00219"></a><span class="lineno">  219</span>}</div>
</div>
<div class="line"><a id="l00220" name="l00220"></a><span class="lineno">  220</span> </div>
<div class="foldopen" id="foldopen00221" data-start="{" data-end="}">
<div class="line"><a id="l00221" name="l00221"></a><span class="lineno"><a class="line" href="namespacellzk.html#a9ad8587acfbc58f9dd98165996cce8c7">  221</a></span>FailureOr&lt;SymbolRefAttr&gt; <a class="code hl_function" href="namespacellzk.html#a75fdc2fe83e3eca6b6c048deac2b22ab">getPathFromTopRoot</a>(<a class="code hl_class" href="classllzk_1_1function_1_1_func_def_op.html">FuncDefOp</a> &amp;to) {</div>
<div class="line"><a id="l00222" name="l00222"></a><span class="lineno">  222</span>  <span class="keywordflow">return</span> <a class="code hl_function" href="namespacellzk.html#a17e5f2ed35eb7b924e98864bc950b296">getPathFromRoot</a>(to, RootSelector::FURTHEST);</div>
<div class="line"><a id="l00223" name="l00223"></a><span class="lineno">  223</span>}</div>
</div>
<div class="line"><a id="l00224" name="l00224"></a><span class="lineno">  224</span> </div>
<div class="foldopen" id="foldopen00225" data-start="{" data-end="}">
<div class="line"><a id="l00225" name="l00225"></a><span class="lineno"><a class="line" href="namespacellzk.html#a2cb8dbb7c515a29aa35b18fb74516a42">  225</a></span><span class="keywordtype">bool</span> <a class="code hl_function" href="namespacellzk.html#a2cb8dbb7c515a29aa35b18fb74516a42">hasUsesWithin</a>(Operation *symbol, Operation *<a class="code hl_variable" href="_l_i_c_e_n_s_e_8txt.html#aaf8226a059307a1b18aac1295b5cf3a2">from</a>) {</div>
<div class="line"><a id="l00226" name="l00226"></a><span class="lineno">  226</span>  assert(symbol &amp;&amp; <span class="stringliteral">&quot;pre-condition&quot;</span>);</div>
<div class="line"><a id="l00227" name="l00227"></a><span class="lineno">  227</span>  assert(<a class="code hl_variable" href="_l_i_c_e_n_s_e_8txt.html#aaf8226a059307a1b18aac1295b5cf3a2">from</a> &amp;&amp; <span class="stringliteral">&quot;pre-condition&quot;</span>);</div>
<div class="line"><a id="l00228" name="l00228"></a><span class="lineno">  228</span>  <span class="keywordtype">bool</span> result = <span class="keyword">false</span>;</div>
<div class="line"><a id="l00229" name="l00229"></a><span class="lineno">  229</span>  SymbolTable::walkSymbolTables(<a class="code hl_variable" href="_l_i_c_e_n_s_e_8txt.html#aaf8226a059307a1b18aac1295b5cf3a2">from</a>, <span class="keyword">false</span>, [symbol, &amp;result](Operation *symbolTableOp, <span class="keywordtype">bool</span>) {</div>
<div class="line"><a id="l00230" name="l00230"></a><span class="lineno">  230</span>    assert(symbolTableOp-&gt;hasTrait&lt;OpTrait::SymbolTable&gt;());</div>
<div class="line"><a id="l00231" name="l00231"></a><span class="lineno">  231</span>    <span class="keywordtype">bool</span> hasUse = (symbol != symbolTableOp) &amp;&amp;</div>
<div class="line"><a id="l00232" name="l00232"></a><span class="lineno">  232</span>                  !SymbolTable::symbolKnownUseEmpty(symbol, &amp;symbolTableOp-&gt;getRegion(0));</div>
<div class="line"><a id="l00233" name="l00233"></a><span class="lineno">  233</span>    result |= hasUse;</div>
<div class="line"><a id="l00234" name="l00234"></a><span class="lineno">  234</span>    LLVM_DEBUG({</div>
<div class="line"><a id="l00235" name="l00235"></a><span class="lineno">  235</span>      <span class="keywordflow">if</span> (hasUse) {</div>
<div class="line"><a id="l00236" name="l00236"></a><span class="lineno">  236</span>        <span class="keyword">auto</span> uses = SymbolTable::getSymbolUses(symbol, &amp;symbolTableOp-&gt;getRegion(0));</div>
<div class="line"><a id="l00237" name="l00237"></a><span class="lineno">  237</span>        assert(uses.has_value()); <span class="comment">// must be consistent with symbolKnownUseEmpty()</span></div>
<div class="line"><a id="l00238" name="l00238"></a><span class="lineno">  238</span>        llvm::dbgs() &lt;&lt; <span class="stringliteral">&quot;Found users of &quot;</span> &lt;&lt; *symbol &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><a id="l00239" name="l00239"></a><span class="lineno">  239</span>        <span class="keywordflow">for</span> (SymbolTable::SymbolUse user : uses.value()) {</div>
<div class="line"><a id="l00240" name="l00240"></a><span class="lineno">  240</span>          llvm::dbgs() &lt;&lt; <span class="stringliteral">&quot; * &quot;</span> &lt;&lt; *user.getUser() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><a id="l00241" name="l00241"></a><span class="lineno">  241</span>        }</div>
<div class="line"><a id="l00242" name="l00242"></a><span class="lineno">  242</span>      }</div>
<div class="line"><a id="l00243" name="l00243"></a><span class="lineno">  243</span>    });</div>
<div class="line"><a id="l00244" name="l00244"></a><span class="lineno">  244</span>  });</div>
<div class="line"><a id="l00245" name="l00245"></a><span class="lineno">  245</span>  <span class="keywordflow">return</span> result;</div>
<div class="line"><a id="l00246" name="l00246"></a><span class="lineno">  246</span>}</div>
</div>
<div class="line"><a id="l00247" name="l00247"></a><span class="lineno">  247</span> </div>
<div class="foldopen" id="foldopen00248" data-start="{" data-end="}">
<div class="line"><a id="l00248" name="l00248"></a><span class="lineno"><a class="line" href="namespacellzk.html#adb5ab0e54d49d74723127a7315e8ba22">  248</a></span>LogicalResult <a class="code hl_function" href="namespacellzk.html#adb5ab0e54d49d74723127a7315e8ba22">verifyParamOfType</a>(</div>
<div class="line"><a id="l00249" name="l00249"></a><span class="lineno">  249</span>    SymbolTableCollection &amp;tables, SymbolRefAttr param, Type parameterizedType, Operation *origin</div>
<div class="line"><a id="l00250" name="l00250"></a><span class="lineno">  250</span>) {</div>
<div class="line"><a id="l00251" name="l00251"></a><span class="lineno">  251</span>  <span class="comment">// Most often, StructType and ArrayType SymbolRefAttr parameters will be defined as parameters of</span></div>
<div class="line"><a id="l00252" name="l00252"></a><span class="lineno">  252</span>  <span class="comment">// the StructDefOp that the current Operation is nested within. These are always flat references</span></div>
<div class="line"><a id="l00253" name="l00253"></a><span class="lineno">  253</span>  <span class="comment">// (i.e. contain no nested references).</span></div>
<div class="line"><a id="l00254" name="l00254"></a><span class="lineno">  254</span>  <span class="keywordflow">if</span> (param.getNestedReferences().empty()) {</div>
<div class="line"><a id="l00255" name="l00255"></a><span class="lineno">  255</span>    FailureOr&lt;StructDefOp&gt; getParentRes = <a class="code hl_function" href="namespacellzk.html#ae01374002b3f4f48046cccee2a7087e4">getParentOfType&lt;StructDefOp&gt;</a>(origin);</div>
<div class="line"><a id="l00256" name="l00256"></a><span class="lineno">  256</span>    <span class="keywordflow">if</span> (succeeded(getParentRes)) {</div>
<div class="line"><a id="l00257" name="l00257"></a><span class="lineno">  257</span>      <span class="keywordflow">if</span> (getParentRes-&gt;hasParamNamed(param.getRootReference())) {</div>
<div class="line"><a id="l00258" name="l00258"></a><span class="lineno">  258</span>        <span class="keywordflow">return</span> success();</div>
<div class="line"><a id="l00259" name="l00259"></a><span class="lineno">  259</span>      }</div>
<div class="line"><a id="l00260" name="l00260"></a><span class="lineno">  260</span>    }</div>
<div class="line"><a id="l00261" name="l00261"></a><span class="lineno">  261</span>  }</div>
<div class="line"><a id="l00262" name="l00262"></a><span class="lineno">  262</span>  <span class="comment">// Otherwise, see if the symbol can be found via lookup from the `origin` Operation.</span></div>
<div class="line"><a id="l00263" name="l00263"></a><span class="lineno">  263</span>  <span class="keyword">auto</span> lookupRes = <a class="code hl_function" href="namespacellzk.html#a3073035b30825ce363ac236f14fe289a">lookupTopLevelSymbol</a>(tables, param, origin);</div>
<div class="line"><a id="l00264" name="l00264"></a><span class="lineno">  264</span>  <span class="keywordflow">if</span> (failed(lookupRes)) {</div>
<div class="line"><a id="l00265" name="l00265"></a><span class="lineno">  265</span>    <span class="keywordflow">return</span> failure(); <span class="comment">// lookupTopLevelSymbol() already emits a sufficient error message</span></div>
<div class="line"><a id="l00266" name="l00266"></a><span class="lineno">  266</span>  }</div>
<div class="line"><a id="l00267" name="l00267"></a><span class="lineno">  267</span>  Operation *foundOp = lookupRes-&gt;get();</div>
<div class="line"><a id="l00268" name="l00268"></a><span class="lineno">  268</span>  <span class="keywordflow">if</span> (!llvm::isa&lt;GlobalDefOp&gt;(foundOp)) {</div>
<div class="line"><a id="l00269" name="l00269"></a><span class="lineno">  269</span>    <span class="keywordflow">return</span> origin-&gt;emitError() &lt;&lt; <span class="stringliteral">&quot;ref \&quot;&quot;</span> &lt;&lt; param &lt;&lt; <span class="stringliteral">&quot;\&quot; in type &quot;</span> &lt;&lt; parameterizedType</div>
<div class="line"><a id="l00270" name="l00270"></a><span class="lineno">  270</span>                               &lt;&lt; <span class="stringliteral">&quot; refers to a &#39;&quot;</span> &lt;&lt; foundOp-&gt;getName()</div>
<div class="line"><a id="l00271" name="l00271"></a><span class="lineno">  271</span>                               &lt;&lt; <span class="stringliteral">&quot;&#39; which is not allowed&quot;</span>;</div>
<div class="line"><a id="l00272" name="l00272"></a><span class="lineno">  272</span>  }</div>
<div class="line"><a id="l00273" name="l00273"></a><span class="lineno">  273</span>  <span class="keywordflow">return</span> success();</div>
<div class="line"><a id="l00274" name="l00274"></a><span class="lineno">  274</span>}</div>
</div>
<div class="line"><a id="l00275" name="l00275"></a><span class="lineno">  275</span> </div>
<div class="foldopen" id="foldopen00276" data-start="{" data-end="}">
<div class="line"><a id="l00276" name="l00276"></a><span class="lineno"><a class="line" href="namespacellzk.html#aaa90d2946d0210b5c3be6279175cf786">  276</a></span>LogicalResult <a class="code hl_function" href="namespacellzk.html#aaa90d2946d0210b5c3be6279175cf786">verifyParamsOfType</a>(</div>
<div class="line"><a id="l00277" name="l00277"></a><span class="lineno">  277</span>    SymbolTableCollection &amp;tables, ArrayRef&lt;Attribute&gt; tyParams, Type parameterizedType,</div>
<div class="line"><a id="l00278" name="l00278"></a><span class="lineno">  278</span>    Operation *origin</div>
<div class="line"><a id="l00279" name="l00279"></a><span class="lineno">  279</span>) {</div>
<div class="line"><a id="l00280" name="l00280"></a><span class="lineno">  280</span>  <span class="comment">// Rather than immediately returning on failure, we check all params and aggregate to provide as</span></div>
<div class="line"><a id="l00281" name="l00281"></a><span class="lineno">  281</span>  <span class="comment">// many errors are possible in a single verifier run.</span></div>
<div class="line"><a id="l00282" name="l00282"></a><span class="lineno">  282</span>  LogicalResult paramCheckResult = success();</div>
<div class="line"><a id="l00283" name="l00283"></a><span class="lineno">  283</span>  <span class="keywordflow">for</span> (Attribute attr : tyParams) {</div>
<div class="line"><a id="l00284" name="l00284"></a><span class="lineno">  284</span>    <a class="code hl_function" href="namespacellzk.html#a06f8a74431f12f0298cc7033691f84ec">assertValidAttrForParamOfType</a>(attr);</div>
<div class="line"><a id="l00285" name="l00285"></a><span class="lineno">  285</span>    <span class="keywordflow">if</span> (SymbolRefAttr symRefParam = llvm::dyn_cast&lt;SymbolRefAttr&gt;(attr)) {</div>
<div class="line"><a id="l00286" name="l00286"></a><span class="lineno">  286</span>      <span class="keywordflow">if</span> (failed(<a class="code hl_function" href="namespacellzk.html#adb5ab0e54d49d74723127a7315e8ba22">verifyParamOfType</a>(tables, symRefParam, parameterizedType, origin))) {</div>
<div class="line"><a id="l00287" name="l00287"></a><span class="lineno">  287</span>        paramCheckResult = failure();</div>
<div class="line"><a id="l00288" name="l00288"></a><span class="lineno">  288</span>      }</div>
<div class="line"><a id="l00289" name="l00289"></a><span class="lineno">  289</span>    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (TypeAttr typeParam = llvm::dyn_cast&lt;TypeAttr&gt;(attr)) {</div>
<div class="line"><a id="l00290" name="l00290"></a><span class="lineno">  290</span>      <span class="keywordflow">if</span> (failed(<a class="code hl_function" href="namespacellzk.html#a8a20668e5af9ce080f868692b9d199a6">verifyTypeResolution</a>(tables, origin, typeParam.getValue()))) {</div>
<div class="line"><a id="l00291" name="l00291"></a><span class="lineno">  291</span>        paramCheckResult = failure();</div>
<div class="line"><a id="l00292" name="l00292"></a><span class="lineno">  292</span>      }</div>
<div class="line"><a id="l00293" name="l00293"></a><span class="lineno">  293</span>    }</div>
<div class="line"><a id="l00294" name="l00294"></a><span class="lineno">  294</span>    <span class="comment">// IntegerAttr and AffineMapAttr cannot contain symbol references</span></div>
<div class="line"><a id="l00295" name="l00295"></a><span class="lineno">  295</span>  }</div>
<div class="line"><a id="l00296" name="l00296"></a><span class="lineno">  296</span>  <span class="keywordflow">return</span> paramCheckResult;</div>
<div class="line"><a id="l00297" name="l00297"></a><span class="lineno">  297</span>}</div>
</div>
<div class="line"><a id="l00298" name="l00298"></a><span class="lineno">  298</span> </div>
<div class="line"><a id="l00299" name="l00299"></a><span class="lineno">  299</span>FailureOr&lt;StructDefOp&gt;</div>
<div class="foldopen" id="foldopen00300" data-start="{" data-end="}">
<div class="line"><a id="l00300" name="l00300"></a><span class="lineno"><a class="line" href="namespacellzk.html#a75f8539d20e1d1066b30e5b8d15b0546">  300</a></span><a class="code hl_function" href="namespacellzk.html#a75f8539d20e1d1066b30e5b8d15b0546">verifyStructTypeResolution</a>(SymbolTableCollection &amp;tables, <a class="code hl_class" href="classllzk_1_1component_1_1_struct_type.html">StructType</a> ty, Operation *origin) {</div>
<div class="line"><a id="l00301" name="l00301"></a><span class="lineno">  301</span>  <span class="keyword">auto</span> res = ty.<a class="code hl_function" href="classllzk_1_1component_1_1_struct_type.html#ab507f47422556213a072b3e45b9b3aa4">getDefinition</a>(tables, origin);</div>
<div class="line"><a id="l00302" name="l00302"></a><span class="lineno">  302</span>  <span class="keywordflow">if</span> (failed(res)) {</div>
<div class="line"><a id="l00303" name="l00303"></a><span class="lineno">  303</span>    <span class="keywordflow">return</span> failure();</div>
<div class="line"><a id="l00304" name="l00304"></a><span class="lineno">  304</span>  }</div>
<div class="line"><a id="l00305" name="l00305"></a><span class="lineno">  305</span>  <a class="code hl_class" href="classllzk_1_1component_1_1_struct_def_op.html">StructDefOp</a> defForType = res.value().get();</div>
<div class="line"><a id="l00306" name="l00306"></a><span class="lineno">  306</span>  <span class="keywordflow">if</span> (!<a class="code hl_function" href="namespacellzk.html#a449db750fee6d61e2ec3aa36a969d483">structTypesUnify</a>(ty, defForType.<a class="code hl_function" href="classllzk_1_1component_1_1_struct_def_op.html#a2fe7b83cd6fb6399ccf5555008ae596b">getType</a>({}), res-&gt;getIncludeSymNames())) {</div>
<div class="line"><a id="l00307" name="l00307"></a><span class="lineno">  307</span>    <span class="keywordflow">return</span> origin-&gt;emitError()</div>
<div class="line"><a id="l00308" name="l00308"></a><span class="lineno">  308</span>        .append(</div>
<div class="line"><a id="l00309" name="l00309"></a><span class="lineno">  309</span>            <span class="stringliteral">&quot;Cannot unify parameters of type &quot;</span>, ty, <span class="stringliteral">&quot; with parameters of &#39;&quot;</span>,</div>
<div class="line"><a id="l00310" name="l00310"></a><span class="lineno">  310</span>            <a class="code hl_function" href="classllzk_1_1component_1_1_struct_def_op.html#a4b8e286abe8df3553b201ec695bd7177">StructDefOp::getOperationName</a>(), <span class="stringliteral">&quot;&#39; \&quot;&quot;</span>, defForType.<a class="code hl_function" href="classllzk_1_1component_1_1_struct_def_op.html#afb01a31f952e6b52bd7243ecbf238739">getHeaderString</a>(), <span class="stringliteral">&quot;\&quot;&quot;</span></div>
<div class="line"><a id="l00311" name="l00311"></a><span class="lineno">  311</span>        )</div>
<div class="line"><a id="l00312" name="l00312"></a><span class="lineno">  312</span>        .attachNote(defForType.getLoc())</div>
<div class="line"><a id="l00313" name="l00313"></a><span class="lineno">  313</span>        .append(<span class="stringliteral">&quot;type parameters must unify with parameters defined here&quot;</span>);</div>
<div class="line"><a id="l00314" name="l00314"></a><span class="lineno">  314</span>  }</div>
<div class="line"><a id="l00315" name="l00315"></a><span class="lineno">  315</span>  <span class="comment">// If there are any SymbolRefAttr parameters on the StructType, ensure those refs are valid.</span></div>
<div class="line"><a id="l00316" name="l00316"></a><span class="lineno">  316</span>  <span class="keywordflow">if</span> (ArrayAttr tyParams = ty.<a class="code hl_function" href="classllzk_1_1component_1_1_struct_type.html#a9388689c322310c1d5c4bcf5445cfd53">getParams</a>()) {</div>
<div class="line"><a id="l00317" name="l00317"></a><span class="lineno">  317</span>    <span class="keywordflow">if</span> (failed(<a class="code hl_function" href="namespacellzk.html#aaa90d2946d0210b5c3be6279175cf786">verifyParamsOfType</a>(tables, tyParams.getValue(), ty, origin))) {</div>
<div class="line"><a id="l00318" name="l00318"></a><span class="lineno">  318</span>      <span class="keywordflow">return</span> failure(); <span class="comment">// verifyParamsOfType() already emits a sufficient error message</span></div>
<div class="line"><a id="l00319" name="l00319"></a><span class="lineno">  319</span>    }</div>
<div class="line"><a id="l00320" name="l00320"></a><span class="lineno">  320</span>  }</div>
<div class="line"><a id="l00321" name="l00321"></a><span class="lineno">  321</span>  <span class="keywordflow">return</span> defForType;</div>
<div class="line"><a id="l00322" name="l00322"></a><span class="lineno">  322</span>}</div>
</div>
<div class="line"><a id="l00323" name="l00323"></a><span class="lineno">  323</span> </div>
<div class="foldopen" id="foldopen00324" data-start="{" data-end="}">
<div class="line"><a id="l00324" name="l00324"></a><span class="lineno"><a class="line" href="namespacellzk.html#a8a20668e5af9ce080f868692b9d199a6">  324</a></span>LogicalResult <a class="code hl_function" href="namespacellzk.html#a8a20668e5af9ce080f868692b9d199a6">verifyTypeResolution</a>(SymbolTableCollection &amp;tables, Operation *origin, Type ty) {</div>
<div class="line"><a id="l00325" name="l00325"></a><span class="lineno">  325</span>  <span class="keywordflow">if</span> (<a class="code hl_class" href="classllzk_1_1component_1_1_struct_type.html">StructType</a> sTy = llvm::dyn_cast&lt;StructType&gt;(ty)) {</div>
<div class="line"><a id="l00326" name="l00326"></a><span class="lineno">  326</span>    <span class="keywordflow">return</span> <a class="code hl_function" href="namespacellzk.html#a75f8539d20e1d1066b30e5b8d15b0546">verifyStructTypeResolution</a>(tables, sTy, origin);</div>
<div class="line"><a id="l00327" name="l00327"></a><span class="lineno">  327</span>  } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code hl_class" href="classllzk_1_1array_1_1_array_type.html">ArrayType</a> aTy = llvm::dyn_cast&lt;ArrayType&gt;(ty)) {</div>
<div class="line"><a id="l00328" name="l00328"></a><span class="lineno">  328</span>    <span class="keywordflow">if</span> (failed(<a class="code hl_function" href="namespacellzk.html#aaa90d2946d0210b5c3be6279175cf786">verifyParamsOfType</a>(tables, aTy.getDimensionSizes(), aTy, origin))) {</div>
<div class="line"><a id="l00329" name="l00329"></a><span class="lineno">  329</span>      <span class="keywordflow">return</span> failure();</div>
<div class="line"><a id="l00330" name="l00330"></a><span class="lineno">  330</span>    }</div>
<div class="line"><a id="l00331" name="l00331"></a><span class="lineno">  331</span>    <span class="keywordflow">return</span> <a class="code hl_function" href="namespacellzk.html#a8a20668e5af9ce080f868692b9d199a6">verifyTypeResolution</a>(tables, origin, aTy.getElementType());</div>
<div class="line"><a id="l00332" name="l00332"></a><span class="lineno">  332</span>  } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code hl_class" href="classllzk_1_1polymorphic_1_1_type_var_type.html">TypeVarType</a> vTy = llvm::dyn_cast&lt;TypeVarType&gt;(ty)) {</div>
<div class="line"><a id="l00333" name="l00333"></a><span class="lineno">  333</span>    <span class="keywordflow">return</span> <a class="code hl_function" href="namespacellzk.html#adb5ab0e54d49d74723127a7315e8ba22">verifyParamOfType</a>(tables, vTy.getNameRef(), vTy, origin);</div>
<div class="line"><a id="l00334" name="l00334"></a><span class="lineno">  334</span>  } <span class="keywordflow">else</span> {</div>
<div class="line"><a id="l00335" name="l00335"></a><span class="lineno">  335</span>    <span class="keywordflow">return</span> success();</div>
<div class="line"><a id="l00336" name="l00336"></a><span class="lineno">  336</span>  }</div>
<div class="line"><a id="l00337" name="l00337"></a><span class="lineno">  337</span>}</div>
</div>
<div class="line"><a id="l00338" name="l00338"></a><span class="lineno">  338</span> </div>
<div class="line"><a id="l00339" name="l00339"></a><span class="lineno">  339</span>} <span class="comment">// namespace llzk</span></div>
<div class="ttc" id="a_array_2_i_r_2_ops_8h_html"><div class="ttname"><a href="_array_2_i_r_2_ops_8h.html">Ops.h</a></div></div>
<div class="ttc" id="a_function_2_i_r_2_ops_8h_html"><div class="ttname"><a href="_function_2_i_r_2_ops_8h.html">Ops.h</a></div></div>
<div class="ttc" id="a_global_2_i_r_2_ops_8h_html"><div class="ttname"><a href="_global_2_i_r_2_ops_8h.html">Ops.h</a></div></div>
<div class="ttc" id="a_l_i_c_e_n_s_e_8txt_html_a30594132172b3373a0a76459eed4796e"><div class="ttname"><a href="_l_i_c_e_n_s_e_8txt.html#a30594132172b3373a0a76459eed4796e">names</a></div><div class="ttdeci">within a display generated by the Derivative if and wherever such third party notices normally appear The contents of the NOTICE file are for informational purposes only and do not modify the License You may add Your own attribution notices within Derivative Works that You alongside or as an addendum to the NOTICE text from the provided that such additional attribution notices cannot be construed as modifying the License You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for or distribution of Your or for any such Derivative Works as a provided Your and distribution of the Work otherwise complies with the conditions stated in this License Submission of Contributions Unless You explicitly state any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this without any additional terms or conditions Notwithstanding the nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions Trademarks This License does not grant permission to use the trade names</div><div class="ttdef"><b>Definition</b> <a href="_l_i_c_e_n_s_e_8txt_source.html#l00139">LICENSE.txt:139</a></div></div>
<div class="ttc" id="a_l_i_c_e_n_s_e_8txt_html_aaf8226a059307a1b18aac1295b5cf3a2"><div class="ttname"><a href="_l_i_c_e_n_s_e_8txt.html#aaf8226a059307a1b18aac1295b5cf3a2">from</a></div><div class="ttdeci">Apache License January AND DISTRIBUTION Definitions License shall mean the terms and conditions for and distribution as defined by Sections through of this document Licensor shall mean the copyright owner or entity authorized by the copyright owner that is granting the License Legal Entity shall mean the union of the acting entity and all other entities that control are controlled by or are under common control with that entity For the purposes of this definition control direct or to cause the direction or management of such whether by contract or including but not limited to software source documentation and configuration files Object form shall mean any form resulting from mechanical transformation or translation of a Source including but not limited to compiled object generated and conversions to other media types Work shall mean the work of whether in Source or Object made available under the as indicated by a copyright notice that is included in or attached to the whether in Source or Object that is based or other modifications as a an original work of authorship For the purposes of this Derivative Works shall not include works that remain separable from</div><div class="ttdef"><b>Definition</b> <a href="_l_i_c_e_n_s_e_8txt_source.html#l00045">LICENSE.txt:45</a></div></div>
<div class="ttc" id="a_polymorphic_2_i_r_2_types_8h_html"><div class="ttname"><a href="_polymorphic_2_i_r_2_types_8h.html">Types.h</a></div></div>
<div class="ttc" id="a_symbol_helper_8h_html"><div class="ttname"><a href="_symbol_helper_8h.html">SymbolHelper.h</a></div></div>
<div class="ttc" id="a_symbol_lookup_8h_html"><div class="ttname"><a href="_symbol_lookup_8h.html">SymbolLookup.h</a></div><div class="ttdoc">This file defines methods symbol lookup across LLZK operations and included files.</div></div>
<div class="ttc" id="aclassllzk_1_1array_1_1_array_type_html"><div class="ttname"><a href="classllzk_1_1array_1_1_array_type.html">llzk::array::ArrayType</a></div><div class="ttdef"><b>Definition</b> <a href="_array_2_i_r_2_types_8h_8inc_source.html#l00023">Types.h.inc:23</a></div></div>
<div class="ttc" id="aclassllzk_1_1component_1_1_struct_def_op_html"><div class="ttname"><a href="classllzk_1_1component_1_1_struct_def_op.html">llzk::component::StructDefOp</a></div><div class="ttdef"><b>Definition</b> <a href="_struct_2_i_r_2_ops_8h_8inc_source.html#l00889">Ops.h.inc:889</a></div></div>
<div class="ttc" id="aclassllzk_1_1component_1_1_struct_def_op_html_a2fe7b83cd6fb6399ccf5555008ae596b"><div class="ttname"><a href="classllzk_1_1component_1_1_struct_def_op.html#a2fe7b83cd6fb6399ccf5555008ae596b">llzk::component::StructDefOp::getType</a></div><div class="ttdeci">StructType getType(::std::optional&lt;::mlir::ArrayAttr &gt; constParams={})</div><div class="ttdoc">Gets the StructType representing this struct.</div><div class="ttdef"><b>Definition</b> <a href="_struct_2_i_r_2_ops_8cpp_source.html#l00141">Ops.cpp:141</a></div></div>
<div class="ttc" id="aclassllzk_1_1component_1_1_struct_def_op_html_a4b8e286abe8df3553b201ec695bd7177"><div class="ttname"><a href="classllzk_1_1component_1_1_struct_def_op.html#a4b8e286abe8df3553b201ec695bd7177">llzk::component::StructDefOp::getOperationName</a></div><div class="ttdeci">static constexpr ::llvm::StringLiteral getOperationName()</div><div class="ttdef"><b>Definition</b> <a href="_struct_2_i_r_2_ops_8h_8inc_source.html#l00919">Ops.h.inc:919</a></div></div>
<div class="ttc" id="aclassllzk_1_1component_1_1_struct_def_op_html_afb01a31f952e6b52bd7243ecbf238739"><div class="ttname"><a href="classllzk_1_1component_1_1_struct_def_op.html#afb01a31f952e6b52bd7243ecbf238739">llzk::component::StructDefOp::getHeaderString</a></div><div class="ttdeci">::std::string getHeaderString()</div><div class="ttdoc">Generate header string, in the same format as the assemblyFormat.</div><div class="ttdef"><b>Definition</b> <a href="_struct_2_i_r_2_ops_8cpp_source.html#l00147">Ops.cpp:147</a></div></div>
<div class="ttc" id="aclassllzk_1_1component_1_1_struct_type_html"><div class="ttname"><a href="classllzk_1_1component_1_1_struct_type.html">llzk::component::StructType</a></div><div class="ttdef"><b>Definition</b> <a href="_struct_2_i_r_2_types_8h_8inc_source.html#l00023">Types.h.inc:23</a></div></div>
<div class="ttc" id="aclassllzk_1_1component_1_1_struct_type_html_a9388689c322310c1d5c4bcf5445cfd53"><div class="ttname"><a href="classllzk_1_1component_1_1_struct_type.html#a9388689c322310c1d5c4bcf5445cfd53">llzk::component::StructType::getParams</a></div><div class="ttdeci">::mlir::ArrayAttr getParams() const</div><div class="ttdef"><b>Definition</b> <a href="_struct_2_i_r_2_types_8cpp_8inc_source.html#l00159">Types.cpp.inc:159</a></div></div>
<div class="ttc" id="aclassllzk_1_1component_1_1_struct_type_html_ab507f47422556213a072b3e45b9b3aa4"><div class="ttname"><a href="classllzk_1_1component_1_1_struct_type.html#ab507f47422556213a072b3e45b9b3aa4">llzk::component::StructType::getDefinition</a></div><div class="ttdeci">::mlir::FailureOr&lt; SymbolLookupResult&lt; StructDefOp &gt; &gt; getDefinition(::mlir::SymbolTableCollection &amp;symbolTable, ::mlir::Operation *op) const</div><div class="ttdoc">Gets the struct op that defines this struct.</div><div class="ttdef"><b>Definition</b> <a href="_struct_2_i_r_2_types_8cpp_source.html#l00039">Types.cpp:39</a></div></div>
<div class="ttc" id="aclassllzk_1_1function_1_1_func_def_op_html"><div class="ttname"><a href="classllzk_1_1function_1_1_func_def_op.html">llzk::function::FuncDefOp</a></div><div class="ttdef"><b>Definition</b> <a href="_function_2_i_r_2_ops_8h_8inc_source.html#l00432">Ops.h.inc:432</a></div></div>
<div class="ttc" id="aclassllzk_1_1function_1_1_func_def_op_html_acbf62a48d4e47cdc1c346e19c0e3577b"><div class="ttname"><a href="classllzk_1_1function_1_1_func_def_op.html#acbf62a48d4e47cdc1c346e19c0e3577b">llzk::function::FuncDefOp::getOperationName</a></div><div class="ttdeci">static constexpr ::llvm::StringLiteral getOperationName()</div><div class="ttdef"><b>Definition</b> <a href="_function_2_i_r_2_ops_8h_8inc_source.html#l00478">Ops.h.inc:478</a></div></div>
<div class="ttc" id="aclassllzk_1_1polymorphic_1_1_type_var_type_html"><div class="ttname"><a href="classllzk_1_1polymorphic_1_1_type_var_type.html">llzk::polymorphic::TypeVarType</a></div><div class="ttdef"><b>Definition</b> <a href="_polymorphic_2_i_r_2_types_8h_8inc_source.html#l00023">Types.h.inc:23</a></div></div>
<div class="ttc" id="anamespacellzk_html"><div class="ttname"><a href="namespacellzk.html">llzk</a></div><div class="ttdef"><b>Definition</b> <a href="_call_graph_8cpp_source.html#l00029">CallGraph.cpp:29</a></div></div>
<div class="ttc" id="anamespacellzk_html_a06f8a74431f12f0298cc7033691f84ec"><div class="ttname"><a href="namespacellzk.html#a06f8a74431f12f0298cc7033691f84ec">llzk::assertValidAttrForParamOfType</a></div><div class="ttdeci">void assertValidAttrForParamOfType(Attribute attr)</div><div class="ttdef"><b>Definition</b> <a href="_type_helper_8cpp_source.html#l00779">TypeHelper.cpp:779</a></div></div>
<div class="ttc" id="anamespacellzk_html_a17e5f2ed35eb7b924e98864bc950b296"><div class="ttname"><a href="namespacellzk.html#a17e5f2ed35eb7b924e98864bc950b296">llzk::getPathFromRoot</a></div><div class="ttdeci">FailureOr&lt; SymbolRefAttr &gt; getPathFromRoot(StructDefOp &amp;to)</div><div class="ttdef"><b>Definition</b> <a href="#l00204">SymbolHelper.cpp:204</a></div></div>
<div class="ttc" id="anamespacellzk_html_a1834ce0bbea39a5089abc81e496ea685"><div class="ttname"><a href="namespacellzk.html#a1834ce0bbea39a5089abc81e496ea685">llzk::appendLeafName</a></div><div class="ttdeci">SymbolRefAttr appendLeafName(SymbolRefAttr orig, const Twine &amp;newLeafSuffix)</div><div class="ttdef"><b>Definition</b> <a href="#l00184">SymbolHelper.cpp:184</a></div></div>
<div class="ttc" id="anamespacellzk_html_a1b66c1ee1b386cb29f255332f586e96d"><div class="ttname"><a href="namespacellzk.html#a1b66c1ee1b386cb29f255332f586e96d">llzk::LANG_ATTR_NAME</a></div><div class="ttdeci">constexpr char LANG_ATTR_NAME[]</div><div class="ttdoc">Name of the attribute on the top-level ModuleOp that specifies the IR language name.</div><div class="ttdef"><b>Definition</b> <a href="_constants_8h_source.html#l00031">Constants.h:31</a></div></div>
<div class="ttc" id="anamespacellzk_html_a2cb8dbb7c515a29aa35b18fb74516a42"><div class="ttname"><a href="namespacellzk.html#a2cb8dbb7c515a29aa35b18fb74516a42">llzk::hasUsesWithin</a></div><div class="ttdeci">bool hasUsesWithin(Operation *symbol, Operation *from)</div><div class="ttdef"><b>Definition</b> <a href="#l00225">SymbolHelper.cpp:225</a></div></div>
<div class="ttc" id="anamespacellzk_html_a301a571a8339726388d6173ba81b5283"><div class="ttname"><a href="namespacellzk.html#a301a571a8339726388d6173ba81b5283">llzk::getFlatSymbolRefAttr</a></div><div class="ttdeci">mlir::FlatSymbolRefAttr getFlatSymbolRefAttr(mlir::MLIRContext *context, const mlir::Twine &amp;twine)</div><div class="ttdoc">Construct a FlatSymbolRefAttr with the given content.</div><div class="ttdef"><b>Definition</b> <a href="_symbol_helper_8h_source.html#l00034">SymbolHelper.h:34</a></div></div>
<div class="ttc" id="anamespacellzk_html_a3073035b30825ce363ac236f14fe289a"><div class="ttname"><a href="namespacellzk.html#a3073035b30825ce363ac236f14fe289a">llzk::lookupTopLevelSymbol</a></div><div class="ttdeci">mlir::FailureOr&lt; SymbolLookupResultUntyped &gt; lookupTopLevelSymbol(mlir::SymbolTableCollection &amp;tables, mlir::SymbolRefAttr symbol, mlir::Operation *origin, bool reportMissing=true)</div><div class="ttdef"><b>Definition</b> <a href="_symbol_lookup_8h_source.html#l00134">SymbolLookup.h:134</a></div></div>
<div class="ttc" id="anamespacellzk_html_a3395beb30b5d17bc8a968b14eb3638d6"><div class="ttname"><a href="namespacellzk.html#a3395beb30b5d17bc8a968b14eb3638d6">llzk::getNames</a></div><div class="ttdeci">llvm::SmallVector&lt; StringRef &gt; getNames(SymbolRefAttr ref)</div><div class="ttdef"><b>Definition</b> <a href="#l00138">SymbolHelper.cpp:138</a></div></div>
<div class="ttc" id="anamespacellzk_html_a449db750fee6d61e2ec3aa36a969d483"><div class="ttname"><a href="namespacellzk.html#a449db750fee6d61e2ec3aa36a969d483">llzk::structTypesUnify</a></div><div class="ttdeci">bool structTypesUnify(StructType lhs, StructType rhs, ArrayRef&lt; StringRef &gt; rhsReversePrefix, UnificationMap *unifications)</div><div class="ttdef"><b>Definition</b> <a href="_type_helper_8cpp_source.html#l00680">TypeHelper.cpp:680</a></div></div>
<div class="ttc" id="anamespacellzk_html_a44fd8ecd88f8e6b80079bf6c1328412a"><div class="ttname"><a href="namespacellzk.html#a44fd8ecd88f8e6b80079bf6c1328412a">llzk::getRootModule</a></div><div class="ttdeci">FailureOr&lt; ModuleOp &gt; getRootModule(Operation *from)</div><div class="ttdef"><b>Definition</b> <a href="#l00199">SymbolHelper.cpp:199</a></div></div>
<div class="ttc" id="anamespacellzk_html_a5a8f8e48ae6b42bbfbccc3b9a58e642d"><div class="ttname"><a href="namespacellzk.html#a5a8f8e48ae6b42bbfbccc3b9a58e642d">llzk::appendLeaf</a></div><div class="ttdeci">SymbolRefAttr appendLeaf(SymbolRefAttr orig, FlatSymbolRefAttr newLeaf)</div><div class="ttdef"><b>Definition</b> <a href="#l00180">SymbolHelper.cpp:180</a></div></div>
<div class="ttc" id="anamespacellzk_html_a6233c90d2afb42113aa36eddeebd8f76"><div class="ttname"><a href="namespacellzk.html#a6233c90d2afb42113aa36eddeebd8f76">llzk::replaceLeaf</a></div><div class="ttdeci">SymbolRefAttr replaceLeaf(SymbolRefAttr orig, FlatSymbolRefAttr newLeaf)</div><div class="ttdef"><b>Definition</b> <a href="#l00170">SymbolHelper.cpp:170</a></div></div>
<div class="ttc" id="anamespacellzk_html_a75f8539d20e1d1066b30e5b8d15b0546"><div class="ttname"><a href="namespacellzk.html#a75f8539d20e1d1066b30e5b8d15b0546">llzk::verifyStructTypeResolution</a></div><div class="ttdeci">FailureOr&lt; StructDefOp &gt; verifyStructTypeResolution(SymbolTableCollection &amp;tables, StructType ty, Operation *origin)</div><div class="ttdef"><b>Definition</b> <a href="#l00300">SymbolHelper.cpp:300</a></div></div>
<div class="ttc" id="anamespacellzk_html_a75fdc2fe83e3eca6b6c048deac2b22ab"><div class="ttname"><a href="namespacellzk.html#a75fdc2fe83e3eca6b6c048deac2b22ab">llzk::getPathFromTopRoot</a></div><div class="ttdeci">FailureOr&lt; SymbolRefAttr &gt; getPathFromTopRoot(StructDefOp &amp;to)</div><div class="ttdef"><b>Definition</b> <a href="#l00217">SymbolHelper.cpp:217</a></div></div>
<div class="ttc" id="anamespacellzk_html_a858ad75166540367bf85ae38bc875707"><div class="ttname"><a href="namespacellzk.html#a858ad75166540367bf85ae38bc875707">llzk::getTopRootModule</a></div><div class="ttdeci">FailureOr&lt; ModuleOp &gt; getTopRootModule(Operation *from)</div><div class="ttdef"><b>Definition</b> <a href="#l00212">SymbolHelper.cpp:212</a></div></div>
<div class="ttc" id="anamespacellzk_html_a8a20668e5af9ce080f868692b9d199a6"><div class="ttname"><a href="namespacellzk.html#a8a20668e5af9ce080f868692b9d199a6">llzk::verifyTypeResolution</a></div><div class="ttdeci">LogicalResult verifyTypeResolution(SymbolTableCollection &amp;tables, Operation *origin, Type ty)</div><div class="ttdef"><b>Definition</b> <a href="#l00324">SymbolHelper.cpp:324</a></div></div>
<div class="ttc" id="anamespacellzk_html_aaa90d2946d0210b5c3be6279175cf786"><div class="ttname"><a href="namespacellzk.html#aaa90d2946d0210b5c3be6279175cf786">llzk::verifyParamsOfType</a></div><div class="ttdeci">LogicalResult verifyParamsOfType(SymbolTableCollection &amp;tables, ArrayRef&lt; Attribute &gt; tyParams, Type parameterizedType, Operation *origin)</div><div class="ttdef"><b>Definition</b> <a href="#l00276">SymbolHelper.cpp:276</a></div></div>
<div class="ttc" id="anamespacellzk_html_ab1ef6741a40f7e02fc0b94c979c8b3be"><div class="ttname"><a href="namespacellzk.html#ab1ef6741a40f7e02fc0b94c979c8b3be">llzk::asSymbolRefAttr</a></div><div class="ttdeci">mlir::SymbolRefAttr asSymbolRefAttr(mlir::StringAttr root, mlir::SymbolRefAttr tail)</div><div class="ttdoc">Build a SymbolRefAttr that prepends tail with root, i.e. root::tail.</div><div class="ttdef"><b>Definition</b> <a href="_symbol_helper_8h_source.html#l00039">SymbolHelper.h:39</a></div></div>
<div class="ttc" id="anamespacellzk_html_adb5ab0e54d49d74723127a7315e8ba22"><div class="ttname"><a href="namespacellzk.html#adb5ab0e54d49d74723127a7315e8ba22">llzk::verifyParamOfType</a></div><div class="ttdeci">LogicalResult verifyParamOfType(SymbolTableCollection &amp;tables, SymbolRefAttr param, Type parameterizedType, Operation *origin)</div><div class="ttdef"><b>Definition</b> <a href="#l00248">SymbolHelper.cpp:248</a></div></div>
<div class="ttc" id="anamespacellzk_html_ae01374002b3f4f48046cccee2a7087e4"><div class="ttname"><a href="namespacellzk.html#ae01374002b3f4f48046cccee2a7087e4">llzk::getParentOfType</a></div><div class="ttdeci">mlir::FailureOr&lt; OpType &gt; getParentOfType(mlir::Operation *op)</div><div class="ttdoc">Return the closest surrounding parent operation that is of type &#39;OpType&#39;.</div><div class="ttdef"><b>Definition</b> <a href="_op_helpers_8h_source.html#l00032">OpHelpers.h:32</a></div></div>
<div class="ttc" id="anamespacellzk_html_aefd24a67a7806996a53b63a5014c82a2"><div class="ttname"><a href="namespacellzk.html#aefd24a67a7806996a53b63a5014c82a2">llzk::getPieces</a></div><div class="ttdeci">llvm::SmallVector&lt; FlatSymbolRefAttr &gt; getPieces(SymbolRefAttr ref)</div><div class="ttdef"><b>Definition</b> <a href="#l00147">SymbolHelper.cpp:147</a></div></div>
<div class="ttc" id="anamespacemlir_html"><div class="ttname"><a href="namespacemlir.html">mlir</a></div><div class="ttdef"><b>Definition</b> <a href="_array_2_i_r_2_types_8h_8inc_source.html#l00013">Types.h.inc:13</a></div></div>
</div><!-- fragment --></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.13.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_862d3276083eaac55caed79b9120bf29.html">Util</a></li><li class="navelem"><a class="el" href="_symbol_helper_8cpp.html">SymbolHelper.cpp</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
    <li class="footer">Copyright 2025 Veridise Inc. under the Apache License v2.0.</li>
  </ul>
</div>
</body>
</html>
