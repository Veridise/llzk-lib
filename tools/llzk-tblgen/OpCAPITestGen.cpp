//===- OpCAPITestGen.cpp - C API test generator for operations -----------===//
//
// Part of the LLZK Project, under the Apache License v2.0.
// See LICENSE.txt for license information.
// Copyright 2025 Veridise Inc.
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//
//
// OpCAPITestGen generates unit tests for the C API operations generated by
// OpCAPIGen. These are link-time tests that ensure all generated functions
// compile and link properly, using a pattern where the C API function is
// wrapped in a conditional that is always false but the compiler still ensures
// the function within will link correctly.
//
// Test Strategy:
// - Each test creates a dummy operation from a different dialect (arith.constant)
// - Tests then call the generated C API functions inside an if statement that
//   checks if the dummy op is of the target type (always false)
// - The compiler still verifies the function signatures and the linker ensures
//   the symbols are defined, even though the code never executes at runtime
//
// These tests will catch the following kinds of issues:
// - Functions declared but not defined (link errors)
// - Signature mismatches between header and implementation
// - Missing functions in the build system
// - ABI compatibility issues
// - Refactoring breaks
//
// However, the following issues will NOT be caught:
// - Generator logic bugs (if generator is wrong, tests will be wrong too)
// - Runtime behavior
// - Semantic correctness
//
//===----------------------------------------------------------------------===//

#include <mlir/TableGen/GenInfo.h>
#include <mlir/TableGen/Operator.h>

#include <llvm/ADT/StringExtras.h>
#include <llvm/Support/CommandLine.h>
#include <llvm/Support/FormatVariadic.h>
#include <llvm/TableGen/Record.h>
#include <llvm/TableGen/TableGenBackend.h>

#include "CommonCAPIGen.h"

using namespace mlir;
using namespace mlir::tblgen;

namespace {

/// @brief Generator for operation C API tests
///
/// This class generates link-time tests for operation C APIs. The tests verify
/// that all generated functions compile and link correctly by wrapping calls
/// in conditions that are always false at runtime.
struct OpTestGenerator : public Generator {
  /// @brief Construct an operation test generator
  /// @param outputStream The output stream for generated code
  OpTestGenerator(llvm::raw_ostream &outputStream)
      : Generator("Operation", outputStream), testDialect("arith"), testOpName("constant") {}

  /// @brief Generate test for an extra method from extraClassDeclaration
  virtual void genExtraMethod(const ExtraMethod &method) const override {
    // Convert return type to C API type, skip if it can't be converted
    std::optional<std::string> capiReturnTypeOpt = tryCppTypeToCapiType(method.returnType);
    if (!capiReturnTypeOpt.has_value()) {
      return;
    }

    // Build parameter list for dummy values
    std::string dummyParams;
    std::string paramList;

    for (const auto &param : method.parameters) {
      // Convert C++ type to C API type for parameter, skip if it can't be converted
      std::optional<std::string> capiParamTypeOpt = tryCppTypeToCapiType(param.type);
      if (!capiParamTypeOpt.has_value()) {
        return;
      }
      std::string capiParamType = capiParamTypeOpt.value();
      std::string name = param.name;

      // Generate dummy value creation for each parameter
      if (capiParamType == "MlirValue") {
        dummyParams += "    auto " + name + " = mlirOperationGetResult(testOp, 0);\n";
      } else if (capiParamType == "MlirType") {
        dummyParams += "    auto " + name + " = mlirIndexTypeGet(context);\n";
      } else if (capiParamType == "MlirAttribute") {
        dummyParams +=
            "    auto " + name + " = mlirIntegerAttrGet(mlirIndexTypeGet(context), 0);\n";
      } else if (capiParamType == "intptr_t" || capiParamType == "int" ||
                 capiParamType == "int64_t") {
        dummyParams += "    " + capiParamType + " " + name + " = 0;\n";
      } else if (capiParamType == "bool") {
        dummyParams += "    bool " + name + " = false;\n";
      } else {
        // For unknown types, create a default-initialized variable
        dummyParams += "    " + capiParamType + " " + name + " = {};\n";
      }

      paramList += ", " + name;
    }

    std::string capitalizedMethodName = toPascalCase(method.methodName);

    static constexpr char fmt[] = R"(
TEST_F({0}OpLinkTests, {1}_{2}_{3}) {{
  // This test ensures {4}{2}{3} links properly.
  auto testOp = createTestOp();
  
  if ({5}(testOp)) {{
{6}
    (void){4}{2}{3}(testOp{7});
  }
  
  mlirOperationDestroy(testOp);
}
)";
    assert(!className.empty() && "className must be set");
    os << llvm::formatv(
        fmt,
        dialectNameCapitalized, // {0}
        FunctionPrefix,         // {1}
        className,              // {2}
        capitalizedMethodName,  // {3}
        testPrefix,             // {4}
        isACheck,               // {5}
        dummyParams,            // {6}
        paramList               // {7}
    );
  }

  /// @brief Generate the test class prologue
  void genTestClassPrologue() const {
    static constexpr char fmt[] =
        R"(#include "llzk-c/Dialect/{0}.h"

#include <mlir-c/BuiltinAttributes.h>
#include <mlir-c/BuiltinTypes.h>
#include <mlir-c/IR.h>

class {0}OpLinkTests : public CAPITest {{
protected:
  // Helper to create a simple test operation from {1} dialect
  MlirOperation createTestOp() {{
    auto name = mlirStringRefCreateFromCString("{1}.{2}");
    auto location = mlirLocationUnknownGet(context);
    auto indexType = mlirIndexTypeGet(context);
    
    auto op_state = mlirOperationStateGet(name, location);
    mlirOperationStateAddResults(&op_state, 1, &indexType);
    
    // Add a simple attribute
    auto attr_name = mlirIdentifierGet(context, mlirStringRefCreateFromCString("value"));
    auto attr_value = mlirIntegerAttrGet(indexType, 0);
    auto attr = mlirNamedAttributeGet(attr_name, attr_value);
    mlirOperationStateAddAttributes(&op_state, 1, &attr);
    
    return mlirOperationCreate(&op_state);
  }
};
)";
    os << llvm::formatv(fmt, dialectNameCapitalized, testDialect, testOpName);
  }

  /// @brief Generate IsA test for an operation
  void genIsATest() const {
    static constexpr char fmt[] = R"(
TEST_F({0}OpLinkTests, IsA_{0}{1}) {{
  // This test ensures llzkOperationIsA{0}{1} links properly.
  auto testOp = createTestOp();
  
  // This should always return false since testOp is from {2} dialect
  EXPECT_FALSE(llzkOperationIsA{0}{1}(testOp));
  
  mlirOperationDestroy(testOp);
}
)";
    assert(!className.empty() && "className must be set");
    os << llvm::formatv(fmt, dialectNameCapitalized, className, testDialect);
  }

  /// @brief Generate create function test for an operation
  /// @param op The operation definition
  void genCreateOpTest(const Operator &op) const {
    static constexpr char fmt[] = R"(
TEST_F({0}OpLinkTests, {1}{2}_Create) {{
  // This test ensures {3}{2}Create links properly.
  // We create a {4}.{5} op, which will never match the {2} dialect check.
  auto testOp = createTestOp();
  
  // This condition is always false, so the function is never actually called.
  // We only verify it compiles and links correctly.
  if ({6}(testOp)) {{
    auto location = mlirLocationUnknownGet(context);
{7}
    (void){3}{2}Create(context, location{8});
  }
  
  mlirOperationDestroy(testOp);
}
)";

    assert(!className.empty() && "className must be set");
    std::string dummyParams = generateDummyParams(op);
    std::string paramList = generateParamList(op);

    os << llvm::formatv(
        fmt, dialectNameCapitalized, FunctionPrefix, className, testPrefix, testDialect, testOpName,
        isACheck, dummyParams, paramList
    );
  }

  /// @brief Generate operand getter and setter tests
  /// @param op The operation definition
  void genOperandTests(const Operator &op) const {
    static constexpr char OperandGetterTest[] = R"(
TEST_F({0}OpLinkTests, {1}_{2}_Get{3}) {{
  auto testOp = createTestOp();
  
  if ({4}(testOp)) {{
    (void){5}{2}Get{3}(testOp);
  }
  
  mlirOperationDestroy(testOp);
}
)";

    static constexpr char OperandSetterTest[] = R"(
TEST_F({0}OpLinkTests, {1}_{2}_Set{3}) {{
  auto testOp = createTestOp();
  
  if ({4}(testOp)) {{
    auto dummyValue = mlirOperationGetResult(testOp, 0);
    {5}{2}Set{3}(testOp, dummyValue);
  }
  
  mlirOperationDestroy(testOp);
}
)";

    static constexpr char VariadicOperandCountGetterTest[] = R"(
TEST_F({0}OpLinkTests, {1}_{2}_Get{3}Count) {{
  auto testOp = createTestOp();
  
  if ({4}(testOp)) {{
    (void){5}{2}Get{3}Count(testOp);
  }
  
  mlirOperationDestroy(testOp);
}
)";

    static constexpr char VariadicOperandIndexedGetterTest[] = R"(
TEST_F({0}OpLinkTests, {1}_{2}_Get{3}_Indexed) {{
  auto testOp = createTestOp();
  
  if ({4}(testOp)) {{
    (void){5}{2}Get{3}(testOp, 0);
  }
  
  mlirOperationDestroy(testOp);
}
)";

    static constexpr char VariadicOperandSetterTest[] = R"(
TEST_F({0}OpLinkTests, {1}_{2}_Set{3}_Variadic) {{
  auto testOp = createTestOp();
  
  if ({4}(testOp)) {{
    auto dummyValue = mlirOperationGetResult(testOp, 0);
    MlirValue values[] = {{dummyValue};
    {5}{2}Set{3}(testOp, 1, values);
  }
  
  mlirOperationDestroy(testOp);
}
)";
    assert(!className.empty() && "className must be set");

    for (int i = 0, e = op.getNumOperands(); i < e; ++i) {
      const auto &operand = op.getOperand(i);
      std::string capName = toPascalCase(operand.name);
      if (operand.isVariadic()) {
        if (GenOpOperandGetters) {
          os << llvm::formatv(
              VariadicOperandCountGetterTest, dialectNameCapitalized, FunctionPrefix, className,
              capName, isACheck, testPrefix
          );
          os << llvm::formatv(
              VariadicOperandIndexedGetterTest, dialectNameCapitalized, FunctionPrefix, className,
              capName, isACheck, testPrefix
          );
        }
        if (GenOpOperandSetters) {
          os << llvm::formatv(
              VariadicOperandSetterTest, dialectNameCapitalized, FunctionPrefix, className, capName,
              isACheck, testPrefix
          );
        }
      } else {
        if (GenOpOperandGetters) {
          os << llvm::formatv(
              OperandGetterTest, dialectNameCapitalized, FunctionPrefix, className, capName,
              isACheck, testPrefix
          );
        }
        if (GenOpOperandSetters) {
          os << llvm::formatv(
              OperandSetterTest, dialectNameCapitalized, FunctionPrefix, className, capName,
              isACheck, testPrefix
          );
        }
      }
    }
  }

  /// @brief Generate attribute getter and setter tests
  /// @param op The operation definition
  void genAttributeTests(const Operator &op) const {
    static constexpr char AttributeGetterTest[] = R"(
TEST_F({0}OpLinkTests, {1}_{2}_Get{3}Attr) {{
  auto testOp = createTestOp();
  
  if ({4}(testOp)) {{
    (void){5}{2}Get{3}(testOp);
  }
  
  mlirOperationDestroy(testOp);
}
)";

    static constexpr char AttributeSetterTest[] = R"(
TEST_F({0}OpLinkTests, {1}_{2}_Set{3}Attr) {{
  auto testOp = createTestOp();
  
  if ({4}(testOp)) {{
    auto dummyAttr = mlirIntegerAttrGet(mlirIndexTypeGet(context), 0);
    {5}{2}Set{3}(testOp, dummyAttr);
  }
  
  mlirOperationDestroy(testOp);
}
)";
    assert(!className.empty() && "className must be set");

    for (const auto &namedAttr : op.getAttributes()) {
      std::string capName = toPascalCase(namedAttr.name);
      if (GenOpAttributeGetters) {
        os << llvm::formatv(
            AttributeGetterTest, dialectNameCapitalized, FunctionPrefix, className, capName,
            isACheck, testPrefix
        );
      }
      if (GenOpAttributeSetters) {
        os << llvm::formatv(
            AttributeSetterTest, dialectNameCapitalized, FunctionPrefix, className, capName,
            isACheck, testPrefix
        );
      }
    }
  }

  /// @brief Generate result getter tests
  /// @param op The operation definition
  void genResultTests(const Operator &op) const {
    static constexpr char ResultGetterTest[] = R"(
TEST_F({0}OpLinkTests, {1}_{2}_Get{3}) {{
  auto testOp = createTestOp();
  
  if ({4}(testOp)) {{
    (void){5}{2}Get{3}(testOp);
  }
  
  mlirOperationDestroy(testOp);
}
)";

    static constexpr char VariadicResultCountGetterTest[] = R"(
TEST_F({0}OpLinkTests, {1}_{2}_Get{3}Count) {{
  auto testOp = createTestOp();
  
  if ({4}(testOp)) {{
    (void){5}{2}Get{3}Count(testOp);
  }
  
  mlirOperationDestroy(testOp);
}
)";

    static constexpr char VariadicResultIndexedGetterTest[] = R"(
TEST_F({0}OpLinkTests, {1}_{2}_Get{3}_Indexed) {{
  auto testOp = createTestOp();
  
  if ({4}(testOp)) {{
    (void){5}{2}Get{3}(testOp, 0);
  }
  
  mlirOperationDestroy(testOp);
}
)";
    assert(!className.empty() && "className must be set");

    for (int i = 0, e = op.getNumResults(); i < e; ++i) {
      const auto &result = op.getResult(i);
      std::string resultName =
          result.name.empty() ? llvm::formatv("Result{0}", i).str() : result.name.str();
      std::string capName = toPascalCase(resultName);

      if (result.isVariadic()) {
        os << llvm::formatv(
            VariadicResultCountGetterTest, dialectNameCapitalized, FunctionPrefix, className,
            capName, isACheck, testPrefix
        );
        os << llvm::formatv(
            VariadicResultIndexedGetterTest, dialectNameCapitalized, FunctionPrefix, className,
            capName, isACheck, testPrefix
        );
      } else {
        os << llvm::formatv(
            ResultGetterTest, dialectNameCapitalized, FunctionPrefix, className, capName, isACheck,
            testPrefix
        );
      }
    }
  }

  /// @brief Generate region getter tests
  /// @param op The operation definition
  void genRegionTests(const Operator &op) const {
    static constexpr char RegionGetterTest[] = R"(
TEST_F({0}OpLinkTests, {1}_{2}_Get{3}Region) {{
  auto testOp = createTestOp();
  
  if ({4}(testOp)) {{
    (void){5}{2}Get{3}(testOp);
  }
  
  mlirOperationDestroy(testOp);
}
)";

    static constexpr char VariadicRegionCountGetterTest[] = R"(
TEST_F({0}OpLinkTests, {1}_{2}_Get{3}Count) {{
  auto testOp = createTestOp();
  
  if ({4}(testOp)) {{
    (void){5}{2}Get{3}Count(testOp);
  }
  
  mlirOperationDestroy(testOp);
}
)";

    static constexpr char VariadicRegionIndexedGetterTest[] = R"(
TEST_F({0}OpLinkTests, {1}_{2}_Get{3}_Indexed) {{
  auto testOp = createTestOp();
  
  if ({4}(testOp)) {{
    (void){5}{2}Get{3}(testOp, 0);
  }
  
  mlirOperationDestroy(testOp);
}
)";
    assert(!className.empty() && "className must be set");

    for (int i = 0, e = op.getNumRegions(); i < e; ++i) {
      const auto &region = op.getRegion(i);
      std::string regionName =
          region.name.empty() ? llvm::formatv("Region{0}", i).str() : region.name.str();
      std::string capName = toPascalCase(regionName);

      if (region.isVariadic()) {
        os << llvm::formatv(
            VariadicRegionCountGetterTest, dialectNameCapitalized, FunctionPrefix, className,
            capName, isACheck, testPrefix
        );
        os << llvm::formatv(
            VariadicRegionIndexedGetterTest, dialectNameCapitalized, FunctionPrefix, className,
            capName, isACheck, testPrefix
        );
      } else {
        os << llvm::formatv(
            RegionGetterTest, dialectNameCapitalized, FunctionPrefix, className, capName, isACheck,
            testPrefix
        );
      }
    }
  }

  /// @brief Generate operation name getter test
  void genOperationNameGetterTest() const {
    static constexpr char OperationNameGetterTest[] = R"(
TEST_F({0}OpLinkTests, {1}_{2}_GetOperationName) {{
  auto testOp = createTestOp();
  
  if ({3}(testOp)) {{
    (void){1}{0}{2}GetOperationName(testOp);
  }
  
  mlirOperationDestroy(testOp);
}
)";
    assert(!className.empty() && "className must be set");
    os << llvm::formatv(
        OperationNameGetterTest, dialectNameCapitalized, FunctionPrefix, className, isACheck
    );
  }

  /// @brief Generate all tests for a complete operation record
  /// @param op The operation definition
  void genCompleteRecord(const Operator &op) {
    const Dialect &defDialect = op.getDialect();

    // Generate for the selected dialect only
    if (defDialect.getName() != DialectName) {
      return;
    }

    this->setDialectAndClassName(&defDialect, op.getCppClassName());

    if (GenIsA) {
      this->genIsATest();
    }
    if (GenOpCreate && !op.skipDefaultBuilders()) {
      this->genCreateOpTest(op);
    }
    if (GenOpNameGetter) {
      this->genOperationNameGetterTest();
    }
    if (GenOpOperandGetters || GenOpOperandSetters) {
      this->genOperandTests(op);
    }
    if (GenOpAttributeGetters || GenOpAttributeSetters) {
      this->genAttributeTests(op);
    }
    if (GenOpRegionGetters) {
      this->genRegionTests(op);
    }
    if (GenOpResultGetters) {
      this->genResultTests(op);
    }
    if (GenExtraClassMethods) {
      this->genExtraMethods(op.getExtraClassDeclaration());
    }
  }

protected:
  virtual void setDialectAndClassName(const Dialect *d, StringRef cppClassName) override {
    Generator::setDialectAndClassName(d, cppClassName);
    assert(!className.empty() && "className must be set");
    this->testPrefix = llvm::formatv("{0}{1}", FunctionPrefix, this->dialectNameCapitalized).str();
    this->isACheck =
        llvm::formatv(
            "{0}OperationIsA{1}{2}", FunctionPrefix, this->dialectNameCapitalized, this->className
        )
            .str();
  }

  std::string testDialect;
  std::string testOpName;
  std::string testPrefix;
  std::string isACheck;

private:
  /// @brief Generate dummy parameters for create function based on operation
  /// @param op The operation definition
  /// @return String containing dummy parameter declarations
  static std::string generateDummyParams(const Operator &op) {
    // Use raw_string_ostream for efficient string building
    std::string paramsBuffer;
    llvm::raw_string_ostream paramsStream(paramsBuffer);

    // Declare dummyValue first
    paramsStream << "    auto dummyValue = mlirOperationGetResult(testOp, 0);\n";

    // Add operands
    for (const auto &operand : op.getOperands()) {
      // per `generateParamList()` only need to create something additional in case
      // of variadic operand, otherwise `dummyValue` is used directly.
      if (operand.isVariadic()) {
        paramsStream << llvm::formatv(
            "    MlirValue {0}Values[] = {{dummyValue};\n"
            "    intptr_t {0}Size = 0;\n",
            operand.name
        );
      }
    }

    // Add attributes
    for (const auto &namedAttr : op.getAttributes()) {
      std::string rhs;
      std::optional<std::string> attrType = tryCppTypeToCapiType(namedAttr.attr.getStorageType());
      if (attrType.has_value() && attrType.value() == "MlirIdentifier") {
        rhs = "mlirOperationGetName(testOp)";
      } else {
        rhs = "mlirIntegerAttrGet(mlirIndexTypeGet(context), 0)";
      }
      paramsStream << llvm::formatv("    auto {0}Attr = {1};\n", namedAttr.name, rhs);
    }

    // Add result types if not inferred
    if (!op.allResultTypesKnown()) {
      for (int i = 0, e = op.getNumResults(); i < e; ++i) {
        const auto &result = op.getResult(i);
        std::string resultName =
            result.name.empty() ? llvm::formatv("result{0}", i).str() : result.name.str();
        if (result.isVariadic()) {
          paramsStream << llvm::formatv(
              "    auto {0}TypeArray = mlirIndexTypeGet(context);\n"
              "    MlirType {0}Types[] = {{{0}TypeArray};\n"
              "    intptr_t {0}Size = 0;\n",
              resultName
          );
        } else {
          paramsStream << llvm::formatv(
              "    auto {0}Type = mlirIndexTypeGet(context);\n", resultName
          );
        }
      }
    }

    // Add regions
    for (int i = 0, e = op.getNumRegions(); i < e; ++i) {
      const auto &region = op.getRegion(i);
      std::string regionName =
          region.name.empty() ? llvm::formatv("region{0}", i).str() : region.name.str();
      if (region.isVariadic()) {
        paramsStream << llvm::formatv(
            "    auto {0}Array = mlirRegionCreate();\n"
            "    MlirRegion {0}[] = {{{0}Array};\n"
            "    intptr_t {0}Size = 0;\n",
            regionName
        );
      } else {
        paramsStream << llvm::formatv("    auto {0} = mlirRegionCreate();\n", regionName);
      }
    }

    return paramsStream.str();
  }

  /// @brief Generate parameter list for create function call
  /// @param op The operation definition
  /// @return String containing the parameter list
  static std::string generateParamList(const Operator &op) {
    // Use raw_string_ostream for efficient string building
    std::string paramsBuffer;
    llvm::raw_string_ostream paramsStream(paramsBuffer);

    // Add operands
    for (const auto &operand : op.getOperands()) {
      if (operand.isVariadic()) {
        paramsStream << llvm::formatv(", {0}Size, {0}Values", operand.name);
      } else {
        paramsStream << ", dummyValue";
      }
    }

    // Add attributes
    for (const auto &namedAttr : op.getAttributes()) {
      paramsStream << llvm::formatv(", {0}Attr", namedAttr.name);
    }

    // Add result types if not inferred
    if (!op.allResultTypesKnown()) {
      for (int i = 0, e = op.getNumResults(); i < e; ++i) {
        const auto &result = op.getResult(i);
        std::string resultName =
            result.name.empty() ? llvm::formatv("result{0}", i).str() : result.name.str();
        if (result.isVariadic()) {
          paramsStream << llvm::formatv(", {0}Size, {0}Types", resultName);
        } else {
          paramsStream << llvm::formatv(", {0}Type", resultName);
        }
      }
    }

    // Add regions
    for (int i = 0, e = op.getNumRegions(); i < e; ++i) {
      const auto &region = op.getRegion(i);
      std::string regionName =
          region.name.empty() ? llvm::formatv("region{0}", i).str() : region.name.str();
      if (region.isVariadic()) {
        paramsStream << llvm::formatv(", {0}Size, {0}", regionName);
      } else {
        paramsStream << llvm::formatv(", {0}", regionName);
      }
    }

    return paramsStream.str();
  }
};

} // namespace

/// Emit C API tests for operations
static bool emitOpCAPITests(const llvm::RecordKeeper &records, raw_ostream &os) {
  // Generate file header
  emitSourceFileHeader("Op C API Tests", os, records);

  // Create generator
  OpTestGenerator generator(os);

  // Generate test class prologue
  generator.genTestClassPrologue();

  // Generate tests for each operation
  for (const auto *def : records.getAllDerivedDefinitions("Op")) {
    Operator op(def);
    generator.genCompleteRecord(op);
  }

  return false;
}

static mlir::GenRegistration
    genOpCAPITests("gen-op-capi-tests", "Generate operation C API unit tests", &emitOpCAPITests);
