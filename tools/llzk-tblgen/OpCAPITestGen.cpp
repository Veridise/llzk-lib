//===- OpCAPITestGen.cpp - C API test generator for operations ------------===//
//
// Part of the LLZK Project, under the Apache License v2.0.
// See LICENSE.txt for license information.
// Copyright 2025 Veridise Inc.
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//
//
// OpCAPITestGen generates unit tests for the C API operations generated by
// OpCAPIGen. These are link-time tests that ensure all generated functions
// compile and link properly, using a pattern where the C API function is
// wrapped in a conditional that is always false but the compiler still ensures
// the function within will link correctly.
//
// Test Strategy:
// - Each test creates a dummy operation from a different dialect (arith.constant)
// - Tests then call the generated C API functions inside an if statement that
//   checks if the dummy op is of the target type (always false)
// - The compiler still verifies the function signatures and the linker ensures
//   the symbols are defined, even though the code never executes at runtime
//
// These tests will catch the following kinds of issues:
// - Functions declared but not defined (link errors)
// - Signature mismatches between header and implementation
// - Missing functions in the build system
// - ABI compatibility issues
// - Refactoring breaks
//
// However, the following issues will NOT be caught:
// - Generator logic bugs (if generator is wrong, tests will be wrong too)
// - Runtime behavior
// - Semantic correctness
//
//===----------------------------------------------------------------------===//

#include <mlir/TableGen/GenInfo.h>
#include <mlir/TableGen/Operator.h>

#include <llvm/ADT/StringExtras.h>
#include <llvm/Support/CommandLine.h>
#include <llvm/Support/FormatVariadic.h>
#include <llvm/TableGen/Record.h>
#include <llvm/TableGen/TableGenBackend.h>

#include "CommonCAPIGen.h"

using namespace mlir;
using namespace mlir::tblgen;

namespace {

/// @brief Generator for operation C API tests
///
/// This class generates link-time tests for operation C APIs. The tests verify
/// that all generated functions compile and link correctly by wrapping calls
/// in conditions that are always false at runtime.
struct OpTestGenerator : public TestGenerator {
  /// @brief Construct an operation test generator
  /// @param outputStream The output stream for generated code
  OpTestGenerator(llvm::raw_ostream &outputStream) : TestGenerator("Operation", outputStream) {}

  /// @brief Generate cleanup code for operation tests
  /// @return The name of the cleanup function for operations
  ///
  /// Operations require explicit destruction via mlirOperationDestroy(),
  /// so this override returns the function name rather than a comment.
  virtual std::string genCleanup() const override { return "mlirOperationDestroy"; };

  /// @brief Generate create function test for an operation
  /// @param op The operation definition
  void genCreateOpTest(const Operator &op) const {
    static constexpr char fmt[] = R"(
// This test ensures {0}{1}{2}Create links properly.
TEST_F({1}OperationLinkTests, {0}{2}_Create) {{
  // Returns an `arith.constant` op, which will never match the {2} dialect check.
  auto testOp = createIndexOperation();
  
  // This condition is always false, so the function is never actually called.
  // We only verify it compiles and links correctly.
  if ({0}OperationIsA{1}{2}(testOp)) {{
    auto location = mlirLocationUnknownGet(context);
{3}
    (void){0}{1}{2}Create(context, location{4});
  }
  
  mlirOperationDestroy(testOp);
}
)";

    assert(!className.empty() && "className must be set");
    os << llvm::formatv(
        fmt,
        FunctionPrefix,          // {0}
        dialectNameCapitalized,  // {1}
        className,               // {2}
        generateDummyParams(op), // {3}
        generateParamList(op)    // {4}
    );
  }

  /// @brief Generate operand getter and setter tests
  /// @param op The operation definition
  void genOperandTests(const Operator &op) const {
    static constexpr char OperandGetterTest[] = R"(
TEST_F({1}OperationLinkTests, {0}_{2}_Get{3}) {{
  auto testOp = createIndexOperation();
  
  if ({0}OperationIsA{1}{2}(testOp)) {{
    (void){0}{1}{2}Get{3}(testOp);
  }
  
  mlirOperationDestroy(testOp);
}
)";

    static constexpr char OperandSetterTest[] = R"(
TEST_F({1}OperationLinkTests, {0}_{2}_Set{3}) {{
  auto testOp = createIndexOperation();
  
  if ({0}OperationIsA{1}{2}(testOp)) {{
    auto dummyValue = mlirOperationGetResult(testOp, 0);
    {0}{1}{2}Set{3}(testOp, dummyValue);
  }
  
  mlirOperationDestroy(testOp);
}
)";

    static constexpr char VariadicOperandGetterTest[] = R"(
TEST_F({1}OperationLinkTests, {0}_{2}_Get{3}Count) {{
  auto testOp = createIndexOperation();
  
  if ({0}OperationIsA{1}{2}(testOp)) {{
    (void){0}{1}{2}Get{3}Count(testOp);
  }
  
  mlirOperationDestroy(testOp);
}

TEST_F({1}OperationLinkTests, {0}_{2}_Get{3}At) {{
  auto testOp = createIndexOperation();
  
  if ({0}OperationIsA{1}{2}(testOp)) {{
    (void){0}{1}{2}Get{3}At(testOp, 0);
  }
  
  mlirOperationDestroy(testOp);
}
)";

    static constexpr char VariadicOperandSetterTest[] = R"(
TEST_F({1}OperationLinkTests, {0}_{2}_Set{3}_Variadic) {{
  auto testOp = createIndexOperation();
  
  if ({0}OperationIsA{1}{2}(testOp)) {{
    auto dummyValue = mlirOperationGetResult(testOp, 0);
    MlirValue values[] = {{dummyValue};
    {0}{1}{2}Set{3}(testOp, 1, values);
  }
  
  mlirOperationDestroy(testOp);
}
)";
    assert(!className.empty() && "className must be set");

    for (int i = 0, e = op.getNumOperands(); i < e; ++i) {
      const auto &operand = op.getOperand(i);
      std::string capName = toPascalCase(operand.name);
      if (operand.isVariadic()) {
        if (GenOpOperandGetters) {
          os << llvm::formatv(
              VariadicOperandGetterTest,
              FunctionPrefix,         // {0}
              dialectNameCapitalized, // {1}
              className,              // {2}
              capName                 // {3}
          );
        }
        if (GenOpOperandSetters) {
          os << llvm::formatv(
              VariadicOperandSetterTest,
              FunctionPrefix,         // {0}
              dialectNameCapitalized, // {1}
              className,              // {2}
              capName                 // {3}
          );
        }
      } else {
        if (GenOpOperandGetters) {
          os << llvm::formatv(
              OperandGetterTest,
              FunctionPrefix,         // {0}
              dialectNameCapitalized, // {1}
              className,              // {2}
              capName                 // {3}
          );
        }
        if (GenOpOperandSetters) {
          os << llvm::formatv(
              OperandSetterTest,
              FunctionPrefix,         // {0}
              dialectNameCapitalized, // {1}
              className,              // {2}
              capName                 // {3}
          );
        }
      }
    }
  }

  /// @brief Generate attribute getter and setter tests
  /// @param op The operation definition
  void genAttributeTests(const Operator &op) const {
    static constexpr char AttributeGetterTest[] = R"(
TEST_F({1}OperationLinkTests, {0}_{2}_Get{3}Attr) {{
  auto testOp = createIndexOperation();
  
  if ({0}OperationIsA{1}{2}(testOp)) {{
    (void){0}{1}{2}Get{3}(testOp);
  }
  
  mlirOperationDestroy(testOp);
}
)";

    static constexpr char AttributeSetterTest[] = R"(
TEST_F({1}OperationLinkTests, {0}_{2}_Set{3}Attr) {{
  auto testOp = createIndexOperation();
  
  if ({0}OperationIsA{1}{2}(testOp)) {{
    {0}{1}{2}Set{3}(testOp, createIndexAttribute());
  }
  
  mlirOperationDestroy(testOp);
}
)";
    assert(!className.empty() && "className must be set");

    for (const auto &namedAttr : op.getAttributes()) {
      std::string capName = toPascalCase(namedAttr.name);
      if (GenOpAttributeGetters) {
        os << llvm::formatv(
            AttributeGetterTest,
            FunctionPrefix,         // {0}
            dialectNameCapitalized, // {1}
            className,              // {2}
            capName                 // {3}
        );
      }
      if (GenOpAttributeSetters) {
        os << llvm::formatv(
            AttributeSetterTest,
            FunctionPrefix,         // {0}
            dialectNameCapitalized, // {1}
            className,              // {2}
            capName                 // {3}
        );
      }
    }
  }

  /// @brief Generate result getter tests
  /// @param op The operation definition
  void genResultTests(const Operator &op) const {
    static constexpr char ResultGetterTest[] = R"(
TEST_F({1}OperationLinkTests, {0}_{2}_Get{3}) {{
  auto testOp = createIndexOperation();
  
  if ({0}OperationIsA{1}{2}(testOp)) {{
    (void){0}{1}{2}Get{3}(testOp);
  }
  
  mlirOperationDestroy(testOp);
}
)";

    static constexpr char VariadicResultGetterTest[] = R"(
TEST_F({1}OperationLinkTests, {0}_{2}_Get{3}Count) {{
  auto testOp = createIndexOperation();
  
  if ({0}OperationIsA{1}{2}(testOp)) {{
    (void){0}{1}{2}Get{3}Count(testOp);
  }
  
  mlirOperationDestroy(testOp);
}

TEST_F({1}OperationLinkTests, {0}_{2}_Get{3}At) {{
  auto testOp = createIndexOperation();
  
  if ({0}OperationIsA{1}{2}(testOp)) {{
    (void){0}{1}{2}Get{3}At(testOp, 0);
  }
  
  mlirOperationDestroy(testOp);
}
)";
    assert(!className.empty() && "className must be set");

    for (int i = 0, e = op.getNumResults(); i < e; ++i) {
      const auto &result = op.getResult(i);
      std::string resultName =
          result.name.empty() ? llvm::formatv("Result{0}", i).str() : result.name.str();
      std::string capName = toPascalCase(resultName);

      if (result.isVariadic()) {
        os << llvm::formatv(
            VariadicResultGetterTest,
            FunctionPrefix,         // {0}
            dialectNameCapitalized, // {1}
            className,              // {2}
            capName                 // {3}
        );
      } else {
        os << llvm::formatv(
            ResultGetterTest,
            FunctionPrefix,         // {0}
            dialectNameCapitalized, // {1}
            className,              // {2}
            capName                 // {3}
        );
      }
    }
  }

  /// @brief Generate region getter tests
  /// @param op The operation definition
  void genRegionTests(const Operator &op) const {
    static constexpr char RegionGetterTest[] = R"(
TEST_F({1}OperationLinkTests, {0}_{2}_Get{3}Region) {{
  auto testOp = createIndexOperation();
  
  if ({0}OperationIsA{1}{2}(testOp)) {{
    (void){0}{1}{2}Get{3}(testOp);
  }
  
  mlirOperationDestroy(testOp);
}
)";

    static constexpr char VariadicRegionGetterTest[] = R"(
TEST_F({1}OperationLinkTests, {0}_{2}_Get{3}Count) {{
  auto testOp = createIndexOperation();
  
  if ({0}OperationIsA{1}{2}(testOp)) {{
    (void){0}{1}{2}Get{3}Count(testOp);
  }
  
  mlirOperationDestroy(testOp);
}

TEST_F({1}OperationLinkTests, {0}_{2}_Get{3}At) {{
  auto testOp = createIndexOperation();
  
  if ({0}OperationIsA{1}{2}(testOp)) {{
    (void){0}{1}{2}Get{3}At(testOp, 0);
  }
  
  mlirOperationDestroy(testOp);
}
)";
    assert(!className.empty() && "className must be set");

    for (int i = 0, e = op.getNumRegions(); i < e; ++i) {
      const auto &region = op.getRegion(i);
      std::string regionName =
          region.name.empty() ? llvm::formatv("Region{0}", i).str() : region.name.str();
      std::string capName = toPascalCase(regionName);

      if (region.isVariadic()) {
        os << llvm::formatv(
            VariadicRegionGetterTest,
            FunctionPrefix,         // {0}
            dialectNameCapitalized, // {1}
            className,              // {2}
            capName                 // {3}
        );
      } else {
        os << llvm::formatv(
            RegionGetterTest,
            FunctionPrefix,         // {0}
            dialectNameCapitalized, // {1}
            className,              // {2}
            capName                 // {3}
        );
      }
    }
  }

  /// @brief Generate all tests for a complete operation record
  /// @param op The operation definition
  void genCompleteRecord(const Operator &op) {
    const Dialect &defDialect = op.getDialect();

    // Generate for the selected dialect only
    if (defDialect.getName() != DialectName) {
      return;
    }

    this->setDialectAndClassName(&defDialect, op.getCppClassName());

    if (GenIsA) {
      this->genIsATest();
    }
    if (GenOpCreate && !op.skipDefaultBuilders()) {
      this->genCreateOpTest(op);
    }
    if (GenOpOperandGetters || GenOpOperandSetters) {
      this->genOperandTests(op);
    }
    if (GenOpAttributeGetters || GenOpAttributeSetters) {
      this->genAttributeTests(op);
    }
    if (GenOpRegionGetters) {
      this->genRegionTests(op);
    }
    if (GenOpResultGetters) {
      this->genResultTests(op);
    }
    if (GenExtraClassMethods) {
      this->genExtraMethods(op.getExtraClassDeclaration());
    }
  }

private:
  /// @brief Generate dummy parameters for create function based on operation
  /// @param op The operation definition
  /// @return String containing dummy parameter declarations
  static std::string generateDummyParams(const Operator &op) {
    // Use raw_string_ostream for efficient string building
    std::string paramsBuffer;
    // Reserve approximate space: ~100 chars per operand/attribute/result/region
    paramsBuffer.reserve(
        100 *
        (op.getNumOperands() + op.getNumAttributes() + op.getNumResults() + op.getNumRegions() + 1)
    );
    llvm::raw_string_ostream paramsStream(paramsBuffer);

    // Declare dummyValue first
    paramsStream << "    auto dummyValue = mlirOperationGetResult(testOp, 0);\n";

    // Add operands
    for (const auto &operand : op.getOperands()) {
      // per `generateParamList()` only need to create something additional in case
      // of variadic operand, otherwise `dummyValue` is used directly.
      if (operand.isVariadic()) {
        paramsStream << llvm::formatv(
            "    MlirValue {0}Values[] = {{dummyValue};\n"
            "    intptr_t {0}Size = 0;\n",
            operand.name
        );
      }
    }

    // Add attributes
    for (const auto &namedAttr : op.getAttributes()) {
      std::string rhs;
      std::optional<std::string> attrType = tryCppTypeToCapiType(namedAttr.attr.getStorageType());
      if (attrType.has_value() && attrType.value() == "MlirIdentifier") {
        rhs = "mlirOperationGetName(testOp)";
      } else {
        rhs = "createIndexAttribute()";
      }
      paramsStream << llvm::formatv("    auto {0}Attr = {1};\n", namedAttr.name, rhs);
    }

    // Add result types if not inferred
    if (!op.allResultTypesKnown()) {
      for (int i = 0, e = op.getNumResults(); i < e; ++i) {
        const auto &result = op.getResult(i);
        const std::string resultName =
            result.name.empty() ? llvm::formatv("result{0}", i).str() : result.name.str();
        if (result.isVariadic()) {
          paramsStream << llvm::formatv(
              "    auto {0}TypeArray = createIndexType();\n"
              "    MlirType {0}Types[] = {{{0}TypeArray};\n"
              "    intptr_t {0}Size = 0;\n",
              resultName
          );
        } else {
          paramsStream << llvm::formatv("    auto {0}Type = createIndexType();\n", resultName);
        }
      }
    }

    // Add regions
    for (int i = 0, e = op.getNumRegions(); i < e; ++i) {
      const auto &region = op.getRegion(i);
      const std::string regionName =
          region.name.empty() ? llvm::formatv("region{0}", i).str() : region.name.str();
      if (region.isVariadic()) {
        paramsStream << llvm::formatv(
            "    auto {0}Array = mlirRegionCreate();\n"
            "    MlirRegion {0}[] = {{{0}Array};\n"
            "    intptr_t {0}Size = 0;\n",
            regionName
        );
      } else {
        paramsStream << llvm::formatv("    auto {0} = mlirRegionCreate();\n", regionName);
      }
    }

    return paramsBuffer;
  }

  /// @brief Generate parameter list for create function call
  /// @param op The operation definition
  /// @return String containing the parameter list
  static std::string generateParamList(const Operator &op) {
    // Use raw_string_ostream for efficient string building
    std::string paramsBuffer;
    // Reserve approximate space: ~30 chars per operand/attribute/result/region
    paramsBuffer.reserve(
        30 * (op.getNumOperands() + op.getNumAttributes() + op.getNumResults() + op.getNumRegions())
    );
    llvm::raw_string_ostream paramsStream(paramsBuffer);

    // Add operands
    for (const auto &operand : op.getOperands()) {
      if (operand.isVariadic()) {
        paramsStream << llvm::formatv(", {0}Size, {0}Values", operand.name);
      } else {
        paramsStream << ", dummyValue";
      }
    }

    // Add attributes
    for (const auto &namedAttr : op.getAttributes()) {
      paramsStream << llvm::formatv(", {0}Attr", namedAttr.name);
    }

    // Add result types if not inferred
    if (!op.allResultTypesKnown()) {
      for (int i = 0, e = op.getNumResults(); i < e; ++i) {
        const auto &result = op.getResult(i);
        const std::string resultName =
            result.name.empty() ? llvm::formatv("result{0}", i).str() : result.name.str();
        if (result.isVariadic()) {
          paramsStream << llvm::formatv(", {0}Size, {0}Types", resultName);
        } else {
          paramsStream << llvm::formatv(", {0}Type", resultName);
        }
      }
    }

    // Add regions
    for (int i = 0, e = op.getNumRegions(); i < e; ++i) {
      const auto &region = op.getRegion(i);
      const std::string regionName =
          region.name.empty() ? llvm::formatv("region{0}", i).str() : region.name.str();
      if (region.isVariadic()) {
        paramsStream << llvm::formatv(", {0}Size, {0}", regionName);
      } else {
        paramsStream << llvm::formatv(", {0}", regionName);
      }
    }

    return paramsBuffer;
  }
};

} // namespace

/// Emit C API tests for operations
static bool emitOpCAPITests(const llvm::RecordKeeper &records, raw_ostream &os) {
  // Generate file header
  emitSourceFileHeader("Op C API Tests", os, records);

  // Create generator
  OpTestGenerator generator(os);

  // Generate test class prologue
  generator.genTestClassPrologue();

  // Generate tests for each operation
  for (const auto *def : records.getAllDerivedDefinitions("Op")) {
    Operator op(def);
    generator.genCompleteRecord(op);
  }

  return false;
}

static mlir::GenRegistration
    genOpCAPITests("gen-op-capi-tests", "Generate operation C API unit tests", &emitOpCAPITests);
