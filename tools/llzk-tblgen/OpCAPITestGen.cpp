//===- OpCAPITestGen.cpp - C API test generator for operations -----------===//
//
// Part of the LLZK Project, under the Apache License v2.0.
// See LICENSE.txt for license information.
// Copyright 2025 Veridise Inc.
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//
//
// OpCAPITestGen generates unit tests for the C API operations generated by
// OpCAPIGen. These are link-time tests that ensure all generated functions
// compile and link properly, using a pattern where the C API function is
// wrapped in a conditional that is always false but the compiler still ensures
// the function within will link correctly.
//
// Test Strategy:
// - Each test creates a dummy operation from a different dialect (arith.constant)
// - Tests then call the generated C API functions inside an if statement that
//   checks if the dummy op is of the target type (always false)
// - The compiler still verifies the function signatures and the linker ensures
//   the symbols are defined, even though the code never executes at runtime
//
// These tests will catch the following kinds of issues:
// - Functions declared but not defined (link errors)
// - Signature mismatches between header and implementation
// - Missing functions in the build system
// - ABI compatibility issues
// - Refactoring breaks
//
// However, the following issues will NOT be caught:
// - Generator logic bugs (if generator is wrong, tests will be wrong too)
// - Runtime behavior
// - Semantic correctness
//
//===----------------------------------------------------------------------===//

#include <mlir/TableGen/GenInfo.h>
#include <mlir/TableGen/Operator.h>

#include <llvm/ADT/StringExtras.h>
#include <llvm/Support/CommandLine.h>
#include <llvm/Support/FormatVariadic.h>
#include <llvm/TableGen/Record.h>
#include <llvm/TableGen/TableGenBackend.h>

#include "CommonCAPIGen.h"

using namespace mlir;
using namespace mlir::tblgen;

static llvm::cl::opt<bool> GenOpCreateTests(
    "gen-create-tests", llvm::cl::desc("Generate tests for operation create functions"),
    llvm::cl::init(true), llvm::cl::cat(OpGenCat)
);

static llvm::cl::opt<bool> GenOpOperandTests(
    "gen-operand-tests", llvm::cl::desc("Generate tests for operand getters/setters"),
    llvm::cl::init(true), llvm::cl::cat(OpGenCat)
);

static llvm::cl::opt<bool> GenOpAttributeTests(
    "gen-attribute-tests", llvm::cl::desc("Generate tests for attribute getters/setters"),
    llvm::cl::init(true), llvm::cl::cat(OpGenCat)
);

static llvm::cl::opt<bool> GenOpResultTests(
    "gen-result-tests", llvm::cl::desc("Generate tests for result getters"), llvm::cl::init(true),
    llvm::cl::cat(OpGenCat)
);

static llvm::cl::opt<bool> GenOpRegionTests(
    "gen-region-tests", llvm::cl::desc("Generate tests for region getters"), llvm::cl::init(true),
    llvm::cl::cat(OpGenCat)
);

namespace {

/// @brief Generator for operation C API tests
///
/// This class generates link-time tests for operation C APIs. The tests verify
/// that all generated functions compile and link correctly by wrapping calls
/// in conditions that are always false at runtime.
struct OpTestGenerator : public Generator {
  /// @brief Construct an operation test generator
  /// @param outputStream The output stream for generated code
  OpTestGenerator(llvm::raw_ostream &outputStream)
      : Generator("Operation", outputStream), testDialect("arith"), testOpName("constant") {}

  /// @brief Generate test for an extra method from extraClassDeclaration
  virtual void genExtraMethod(const ExtraMethod &method) const override {
    llvm_unreachable("Not implemented"); // TODO
  }

  /// @brief Generate the test class prologue
  void genTestClassPrologue() const {
    static constexpr char fmt[] =
        R"(#include "llzk-c/Dialect/{0}.h"

#include <mlir-c/BuiltinAttributes.h>
#include <mlir-c/BuiltinTypes.h>
#include <mlir-c/IR.h>

class {0}OpLinkTests : public CAPITest {{
protected:
  // Helper to create a simple test operation from {1} dialect
  MlirOperation createTestOp() {{
    auto name = mlirStringRefCreateFromCString("{1}.{2}");
    auto location = mlirLocationUnknownGet(context);
    auto indexType = mlirIndexTypeGet(context);
    
    auto op_state = mlirOperationStateGet(name, location);
    mlirOperationStateAddResults(&op_state, 1, &indexType);
    
    // Add a simple attribute
    auto attr_name = mlirIdentifierGet(context, mlirStringRefCreateFromCString("value"));
    auto attr_value = mlirIntegerAttrGet(indexType, 0);
    auto attr = mlirNamedAttributeGet(attr_name, attr_value);
    mlirOperationStateAddAttributes(&op_state, 1, &attr);
    
    return mlirOperationCreate(&op_state);
  }
};
)";
    os << llvm::formatv(fmt, dialectNameCapitalized, testDialect, testOpName);
  }

  /// @brief Generate IsA test for an operation
  void genIsATest() const {
    static constexpr char fmt[] = R"(
TEST_F({0}OpLinkTests, IsA_{0}{1}) {{
  // This test ensures llzkOperationIsA{0}{1} links properly.
  auto testOp = createTestOp();
  
  // This should always return false since testOp is from {2} dialect
  EXPECT_FALSE(llzkOperationIsA{0}{1}(testOp));
  
  mlirOperationDestroy(testOp);
}
)";
    assert(!className.empty() && "className must be set");
    os << llvm::formatv(fmt, dialectNameCapitalized, className, testDialect);
  }

  /// @brief Generate create function test for an operation
  /// @param op The operation definition
  void genCreateOpTest(const Operator &op) const {
    static constexpr char fmt[] = R"(
TEST_F({0}OpLinkTests, {1}{2}_Create) {{
  // This test ensures {3}{2}Create links properly.
  // We create a {4}.{5} op, which will never match the {2} dialect check.
  auto testOp = createTestOp();
  
  // This condition is always false, so the function is never actually called.
  // We only verify it compiles and links correctly.
  if ({6}(testOp)) {{
    auto location = mlirLocationUnknownGet(context);
{7}
    (void){3}{2}Create(context, location{8});
  }
  
  mlirOperationDestroy(testOp);
}
)";

    assert(!className.empty() && "className must be set");
    std::string dummyParams = generateDummyParams(op);
    std::string paramList = generateParamList(op);

    os << llvm::formatv(
        fmt, dialectNameCapitalized, FunctionPrefix, className, testPrefix, testDialect, testOpName,
        isACheck, dummyParams, paramList
    );
  }

  /// @brief Generate operand getter and setter tests
  /// @param op The operation definition
  void genOperandTests(const Operator &op) const {
    static constexpr char OperandGetterTest[] = R"(
TEST_F({0}OpLinkTests, {1}_{2}_Get{3}) {{
  auto testOp = createTestOp();
  
  if ({4}(testOp)) {{
    (void){5}{2}Get{3}(testOp);
  }
  
  mlirOperationDestroy(testOp);
}
)";

    static constexpr char OperandSetterTest[] = R"(
TEST_F({0}OpLinkTests, {1}_{2}_Set{3}) {{
  auto testOp = createTestOp();
  
  if ({4}(testOp)) {{
    auto dummyValue = mlirOperationGetResult(testOp, 0);
    {5}{2}Set{3}(testOp, dummyValue);
  }
  
  mlirOperationDestroy(testOp);
}
)";

    static constexpr char VariadicOperandCountGetterTest[] = R"(
TEST_F({0}OpLinkTests, {1}_{2}_Get{3}Count) {{
  auto testOp = createTestOp();
  
  if ({4}(testOp)) {{
    (void){5}{2}Get{3}Count(testOp);
  }
  
  mlirOperationDestroy(testOp);
}
)";

    static constexpr char VariadicOperandIndexedGetterTest[] = R"(
TEST_F({0}OpLinkTests, {1}_{2}_Get{3}_Indexed) {{
  auto testOp = createTestOp();
  
  if ({4}(testOp)) {{
    (void){5}{2}Get{3}(testOp, 0);
  }
  
  mlirOperationDestroy(testOp);
}
)";

    static constexpr char VariadicOperandSetterTest[] = R"(
TEST_F({0}OpLinkTests, {1}_{2}_Set{3}_Variadic) {{
  auto testOp = createTestOp();
  
  if ({4}(testOp)) {{
    auto dummyValue = mlirOperationGetResult(testOp, 0);
    MlirValue values[] = {{dummyValue};
    {5}{2}Set{3}(testOp, 1, values);
  }
  
  mlirOperationDestroy(testOp);
}
)";
    assert(!className.empty() && "className must be set");

    for (int i = 0, e = op.getNumOperands(); i < e; ++i) {
      const auto &operand = op.getOperand(i);
      std::string capName = toPascalCase(operand.name);

      if (!operand.isVariadic()) {
        os << llvm::formatv(
            OperandGetterTest, dialectNameCapitalized, FunctionPrefix, className, capName, isACheck,
            testPrefix
        );
        os << llvm::formatv(
            OperandSetterTest, dialectNameCapitalized, FunctionPrefix, className, capName, isACheck,
            testPrefix
        );
      } else {
        os << llvm::formatv(
            VariadicOperandCountGetterTest, dialectNameCapitalized, FunctionPrefix, className,
            capName, isACheck, testPrefix
        );
        os << llvm::formatv(
            VariadicOperandIndexedGetterTest, dialectNameCapitalized, FunctionPrefix, className,
            capName, isACheck, testPrefix
        );
        os << llvm::formatv(
            VariadicOperandSetterTest, dialectNameCapitalized, FunctionPrefix, className, capName,
            isACheck, testPrefix
        );
      }
    }
  }

  /// @brief Generate attribute getter and setter tests
  /// @param op The operation definition
  void genAttributeTests(const Operator &op) const {
    static constexpr char AttributeGetterTest[] = R"(
TEST_F({0}OpLinkTests, {1}_{2}_Get{3}Attr) {{
  auto testOp = createTestOp();
  
  if ({4}(testOp)) {{
    (void){5}{2}Get{3}(testOp);
  }
  
  mlirOperationDestroy(testOp);
}
)";

    static constexpr char AttributeSetterTest[] = R"(
TEST_F({0}OpLinkTests, {1}_{2}_Set{3}Attr) {{
  auto testOp = createTestOp();
  
  if ({4}(testOp)) {{
    auto dummyAttr = mlirIntegerAttrGet(mlirIndexTypeGet(context), 0);
    {5}{2}Set{3}(testOp, dummyAttr);
  }
  
  mlirOperationDestroy(testOp);
}
)";
    assert(!className.empty() && "className must be set");

    for (const auto &namedAttr : op.getAttributes()) {
      std::string capName = toPascalCase(namedAttr.name);

      // Getter test
      os << llvm::formatv(
          AttributeGetterTest, dialectNameCapitalized, FunctionPrefix, className, capName, isACheck,
          testPrefix
      );

      // Setter test
      os << llvm::formatv(
          AttributeSetterTest, dialectNameCapitalized, FunctionPrefix, className, capName, isACheck,
          testPrefix
      );
    }
  }

  /// @brief Generate result getter tests
  /// @param op The operation definition
  void genResultTests(const Operator &op) const {
    static constexpr char ResultGetterTest[] = R"(
TEST_F({0}OpLinkTests, {1}_{2}_Get{3}) {{
  auto testOp = createTestOp();
  
  if ({4}(testOp)) {{
    (void){5}{2}Get{3}(testOp);
  }
  
  mlirOperationDestroy(testOp);
}
)";

    static constexpr char VariadicResultCountGetterTest[] = R"(
TEST_F({0}OpLinkTests, {1}_{2}_Get{3}Count) {{
  auto testOp = createTestOp();
  
  if ({4}(testOp)) {{
    (void){5}{2}Get{3}Count(testOp);
  }
  
  mlirOperationDestroy(testOp);
}
)";

    static constexpr char VariadicResultIndexedGetterTest[] = R"(
TEST_F({0}OpLinkTests, {1}_{2}_Get{3}_Indexed) {{
  auto testOp = createTestOp();
  
  if ({4}(testOp)) {{
    (void){5}{2}Get{3}(testOp, 0);
  }
  
  mlirOperationDestroy(testOp);
}
)";
    assert(!className.empty() && "className must be set");

    for (int i = 0, e = op.getNumResults(); i < e; ++i) {
      const auto &result = op.getResult(i);
      std::string resultName =
          result.name.empty() ? llvm::formatv("Result{0}", i).str() : result.name.str();
      std::string capName = toPascalCase(resultName);

      if (!result.isVariadic()) {
        os << llvm::formatv(
            ResultGetterTest, dialectNameCapitalized, FunctionPrefix, className, capName, isACheck,
            testPrefix
        );
      } else {
        os << llvm::formatv(
            VariadicResultCountGetterTest, dialectNameCapitalized, FunctionPrefix, className,
            capName, isACheck, testPrefix
        );
        os << llvm::formatv(
            VariadicResultIndexedGetterTest, dialectNameCapitalized, FunctionPrefix, className,
            capName, isACheck, testPrefix
        );
      }
    }
  }

  /// @brief Generate region getter tests
  /// @param op The operation definition
  void genRegionTests(const Operator &op) const {
    static constexpr char RegionGetterTest[] = R"(
TEST_F({0}OpLinkTests, {1}_{2}_Get{3}Region) {{
  auto testOp = createTestOp();
  
  if ({4}(testOp)) {{
    (void){5}{2}Get{3}(testOp);
  }
  
  mlirOperationDestroy(testOp);
}
)";

    static constexpr char VariadicRegionCountGetterTest[] = R"(
TEST_F({0}OpLinkTests, {1}_{2}_Get{3}Count) {{
  auto testOp = createTestOp();
  
  if ({4}(testOp)) {{
    (void){5}{2}Get{3}Count(testOp);
  }
  
  mlirOperationDestroy(testOp);
}
)";

    static constexpr char VariadicRegionIndexedGetterTest[] = R"(
TEST_F({0}OpLinkTests, {1}_{2}_Get{3}_Indexed) {{
  auto testOp = createTestOp();
  
  if ({4}(testOp)) {{
    (void){5}{2}Get{3}(testOp, 0);
  }
  
  mlirOperationDestroy(testOp);
}
)";
    assert(!className.empty() && "className must be set");

    for (int i = 0, e = op.getNumRegions(); i < e; ++i) {
      const auto &region = op.getRegion(i);
      std::string regionName =
          region.name.empty() ? llvm::formatv("Region{0}", i).str() : region.name.str();
      std::string capName = toPascalCase(regionName);

      if (!region.isVariadic()) {
        os << llvm::formatv(
            RegionGetterTest, dialectNameCapitalized, FunctionPrefix, className, capName, isACheck,
            testPrefix
        );
      } else {
        os << llvm::formatv(
            VariadicRegionCountGetterTest, dialectNameCapitalized, FunctionPrefix, className,
            capName, isACheck, testPrefix
        );
        os << llvm::formatv(
            VariadicRegionIndexedGetterTest, dialectNameCapitalized, FunctionPrefix, className,
            capName, isACheck, testPrefix
        );
      }
    }
  }

  /// @brief Generate operation name getter test
  void genOperationNameGetterTest() const {
    static constexpr char OperationNameGetterTest[] = R"(
TEST_F({0}OpLinkTests, {1}_{2}_GetOperationName) {{
  auto testOp = createTestOp();
  
  if ({3}(testOp)) {{
    (void){1}{0}{2}GetOperationName(testOp);
  }
  
  mlirOperationDestroy(testOp);
}
)";
    assert(!className.empty() && "className must be set");
    os << llvm::formatv(
        OperationNameGetterTest, dialectNameCapitalized, FunctionPrefix, className, isACheck
    );
  }

  /// @brief Generate all tests for a complete operation record
  /// @param op The operation definition
  void genCompleteRecord(const Operator &op) {
    const Dialect &dialect = op.getDialect();

    // Generate for the selected dialect only
    if (dialect.getName() != DialectName) {
      return;
    }

    this->setDialectAndClassName(&dialect, op.getCppClassName());

    // Generate IsA test
    if (GenIsATests) {
      this->genIsATest();
    }

    // Generate create function test
    if (GenOpCreateTests && !op.skipDefaultBuilders()) {
      this->genCreateOpTest(op);
    }

    // Generate operand tests
    if (GenOpOperandTests) {
      this->genOperandTests(op);
    }

    // Generate attribute tests
    if (GenOpAttributeTests) {
      this->genAttributeTests(op);
    }

    // Generate result tests
    if (GenOpResultTests) {
      this->genResultTests(op);
    }

    // Generate region tests
    if (GenOpRegionTests) {
      this->genRegionTests(op);
    }

    // Generate operation name getter test
    this->genOperationNameGetterTest();
  }

protected:
  virtual void setDialectAndClassName(const Dialect *d, StringRef cppClassName) override {
    Generator::setDialectAndClassName(d, cppClassName);
    assert(!className.empty() && "className must be set");
    this->testPrefix = llvm::formatv("{0}{1}", FunctionPrefix, this->dialectNameCapitalized).str();
    this->isACheck =
        llvm::formatv(
            "{0}OperationIsA{1}{2}", FunctionPrefix, this->dialectNameCapitalized, this->className
        )
            .str();
  }

  std::string testDialect;
  std::string testOpName;
  std::string testPrefix;
  std::string isACheck;

private:
  /// @brief Generate dummy parameters for create function based on operation
  /// @param op The operation definition
  /// @return String containing dummy parameter declarations
  static std::string generateDummyParams(const Operator &op) {
    // Use raw_string_ostream for efficient string building
    std::string paramsBuffer;
    llvm::raw_string_ostream paramsStream(paramsBuffer);

    // Declare dummyValue first
    paramsStream << "    auto dummyValue = mlirOperationGetResult(testOp, 0);\n";

    // Add operands
    for (const auto &operand : op.getOperands()) {
      if (operand.isVariadic()) {
        paramsStream << llvm::formatv(
            "    MlirValue {0}Values[] = {{dummyValue};\n"
            "    intptr_t {0}Size = 0;\n",
            operand.name
        );
      }
    }

    // Add attributes
    for (const auto &namedAttr : op.getAttributes()) {
      paramsStream << llvm::formatv(
          "    auto {0}Attr = mlirIntegerAttrGet(mlirIndexTypeGet(context), 0);\n", namedAttr.name
      );
    }

    // Add result types if not inferred
    if (!op.allResultTypesKnown()) {
      for (int i = 0, e = op.getNumResults(); i < e; ++i) {
        const auto &result = op.getResult(i);
        std::string resultName =
            result.name.empty() ? llvm::formatv("result{0}", i).str() : result.name.str();
        if (result.isVariadic()) {
          paramsStream << llvm::formatv(
              "    auto {0}TypeArray = mlirIndexTypeGet(context);\n"
              "    MlirType {0}Types[] = {{{0}TypeArray};\n"
              "    intptr_t {0}Size = 0;\n",
              resultName
          );
        } else {
          paramsStream << llvm::formatv(
              "    auto {0}Type = mlirIndexTypeGet(context);\n", resultName
          );
        }
      }
    }

    // Add regions
    for (int i = 0, e = op.getNumRegions(); i < e; ++i) {
      const auto &region = op.getRegion(i);
      std::string regionName =
          region.name.empty() ? llvm::formatv("region{0}", i).str() : region.name.str();
      if (region.isVariadic()) {
        paramsStream << llvm::formatv(
            "    auto {0}Array = mlirRegionCreate();\n"
            "    MlirRegion {0}[] = {{{0}Array};\n"
            "    intptr_t {0}Size = 0;\n",
            regionName
        );
      } else {
        paramsStream << llvm::formatv("    auto {0} = mlirRegionCreate();\n", regionName);
      }
    }

    return paramsStream.str();
  }

  /// @brief Generate parameter list for create function call
  /// @param op The operation definition
  /// @return String containing the parameter list
  static std::string generateParamList(const Operator &op) {
    // Use raw_string_ostream for efficient string building
    std::string paramsBuffer;
    llvm::raw_string_ostream paramsStream(paramsBuffer);

    // Add operands
    for (const auto &operand : op.getOperands()) {
      if (operand.isVariadic()) {
        paramsStream << llvm::formatv(", {0}Size, {0}Values", operand.name);
      } else {
        paramsStream << ", dummyValue";
      }
    }

    // Add attributes
    for (const auto &namedAttr : op.getAttributes()) {
      paramsStream << llvm::formatv(", {0}Attr", namedAttr.name);
    }

    // Add result types if not inferred
    if (!op.allResultTypesKnown()) {
      for (int i = 0, e = op.getNumResults(); i < e; ++i) {
        const auto &result = op.getResult(i);
        std::string resultName =
            result.name.empty() ? llvm::formatv("result{0}", i).str() : result.name.str();
        if (result.isVariadic()) {
          paramsStream << llvm::formatv(", {0}Size, {0}Types", resultName);
        } else {
          paramsStream << llvm::formatv(", {0}Type", resultName);
        }
      }
    }

    // Add regions
    for (int i = 0, e = op.getNumRegions(); i < e; ++i) {
      const auto &region = op.getRegion(i);
      std::string regionName =
          region.name.empty() ? llvm::formatv("region{0}", i).str() : region.name.str();
      if (region.isVariadic()) {
        paramsStream << llvm::formatv(", {0}Size, {0}", regionName);
      } else {
        paramsStream << llvm::formatv(", {0}", regionName);
      }
    }

    return paramsStream.str();
  }
};

} // namespace

/// Emit C API tests for operations
static bool emitOpCAPITests(const llvm::RecordKeeper &records, raw_ostream &os) {
  // Generate file header
  emitSourceFileHeader("Op C API Tests", os, records);

  // Create generator
  OpTestGenerator generator(os);

  // Generate test class prologue
  generator.genTestClassPrologue();

  // Generate tests for each operation
  for (const auto *def : records.getAllDerivedDefinitions("Op")) {
    Operator op(def);
    generator.genCompleteRecord(op);
  }

  return false;
}

static mlir::GenRegistration
    genOpCAPITests("gen-op-capi-tests", "Generate operation C API unit tests", &emitOpCAPITests);
