//===- OpCAPITestGen.cpp - C API test generator for operations -----------===//
//
// Part of the LLZK Project, under the Apache License v2.0.
// See LICENSE.txt for license information.
// Copyright 2025 Veridise Inc.
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//
//
// OpCAPITestGen generates unit tests for the C API operations generated by
// OpCAPIGen. These are link-time tests that ensure all generated functions
// compile and link properly, using a pattern where the C API function is
// wrapped in a conditional that is always false but the compiler still ensures
// the function within will link correctly.
//
// Test Strategy:
// - Each test creates a dummy operation from a different dialect (arith.constant)
// - Tests then call the generated C API functions inside an if statement that
//   checks if the dummy op is of the target type (always false)
// - The compiler still verifies the function signatures and the linker ensures
//   the symbols are defined, even though the code never executes at runtime
//
// These tests will catch the following kinds of issues:
// - Functions declared but not defined (link errors)
// - Signature mismatches between header and implementation
// - Missing functions in the build system
// - ABI compatibility issues
// - Refactoring breaks
//
// However, the following issues will NOT be caught:
// - Generator logic bugs (if generator is wrong, tests will be wrong too)
// - Runtime behavior
// - Semantic correctness
//
//===----------------------------------------------------------------------===//

#include <mlir/TableGen/GenInfo.h>
#include <mlir/TableGen/Operator.h>

#include <llvm/ADT/StringExtras.h>
#include <llvm/Support/CommandLine.h>
#include <llvm/Support/FormatVariadic.h>
#include <llvm/TableGen/Record.h>
#include <llvm/TableGen/TableGenBackend.h>

#include "CommonCAPIGen.h"

using namespace mlir;
using namespace mlir::tblgen;

namespace {

/// @brief Generator for operation C API tests
///
/// This class generates link-time tests for operation C APIs. The tests verify
/// that all generated functions compile and link correctly by wrapping calls
/// in conditions that are always false at runtime.
struct OpTestGenerator : public Generator {
  /// @brief Construct an operation test generator
  /// @param outputStream The output stream for generated code
  OpTestGenerator(llvm::raw_ostream &outputStream) : Generator("Operation", outputStream) {}

  /// @brief Generate test for an extra method from extraClassDeclaration
  virtual void genExtraMethod(const ExtraMethod &method) const override {
    // Convert return type to C API type, skip if it can't be converted
    std::optional<std::string> capiReturnTypeOpt = tryCppTypeToCapiType(method.returnType);
    if (!capiReturnTypeOpt.has_value()) {
      return;
    }

    // Build parameter list for dummy values
    std::string dummyParams;
    llvm::raw_string_ostream dummyParamsStream(dummyParams);
    std::string paramList;
    llvm::raw_string_ostream paramListStream(paramList);

    for (const auto &param : method.parameters) {
      // Convert C++ type to C API type for parameter, skip if it can't be converted
      std::optional<std::string> capiParamTypeOpt = tryCppTypeToCapiType(param.type);
      if (!capiParamTypeOpt.has_value()) {
        return;
      }
      std::string capiParamType = capiParamTypeOpt.value();
      std::string name = param.name;

      // Generate dummy value creation for each parameter
      if (capiParamType == "bool") {
        dummyParamsStream << "    bool " << name << " = false;\n";
      } else if (capiParamType == "MlirValue") {
        dummyParamsStream << "    auto " << name << " = mlirOperationGetResult(testOp, 0);\n";
      } else if (capiParamType == "MlirType") {
        dummyParamsStream << "    auto " << name << " = mlirIndexTypeGet(context);\n";
      } else if (capiParamType == "MlirAttribute") {
        dummyParamsStream << "    auto " << name
                          << " = mlirIntegerAttrGet(mlirIndexTypeGet(context), 0);\n";
      } else if (capiParamType == "intptr_t" || capiParamType == "int" ||
                 capiParamType == "int64_t") {
        dummyParamsStream << "    " << capiParamType << " " << name << " = 0;\n";
      } else {
        // For unknown types, create a default-initialized variable
        dummyParamsStream << "    " << capiParamType << " " << name << " = {};\n";
      }

      paramListStream << ", " << name;
    }

    static constexpr char fmt[] = R"(
// This test ensures {4}{2}{3} links properly.
TEST_F({1}OpLinkTests, {0}_{2}_{3}) {{
  auto testOp = createIndexConstOp();
  
  if ({5}(testOp)) {{
{6}
    (void){4}{2}{3}(testOp{7});
  }
  
  mlirOperationDestroy(testOp);
}
)";
    assert(!className.empty() && "className must be set");
    os << llvm::formatv(
        fmt,
        FunctionPrefix,                  // {0}
        dialectNameCapitalized,          // {1}
        className,                       // {2}
        toPascalCase(method.methodName), // {3}
        testPrefix,                      // {4}
        isACheck,                        // {5}
        dummyParams,                     // {6}
        paramList                        // {7}
    );
  }

  /// @brief Generate the test class prologue
  void genTestClassPrologue() const {
    static constexpr char fmt[] = "class {0}OpLinkTests : public CAPITest {{};\n";
    os << llvm::formatv(fmt, dialectNameCapitalized);
  }

  /// @brief Generate IsA test for an operation
  void genIsATest() const {
    static constexpr char fmt[] = R"(
// This test ensures {0}OperationIsA{1}{2} links properly.
TEST_F({1}OpLinkTests, IsA_{1}{2}) {{
  auto testOp = createIndexConstOp();
  
  // This should always return false since testOp is from `arith` dialect
  EXPECT_FALSE({0}OperationIsA{1}{2}(testOp));
  
  mlirOperationDestroy(testOp);
}
)";
    assert(!className.empty() && "className must be set");
    os << llvm::formatv(
        fmt,
        FunctionPrefix,         // {0}
        dialectNameCapitalized, // {1}
        className               // {2}
    );
  }

  /// @brief Generate create function test for an operation
  /// @param op The operation definition
  void genCreateOpTest(const Operator &op) const {
    static constexpr char fmt[] = R"(
// This test ensures {3}{2}Create links properly.
TEST_F({1}OpLinkTests, {0}{2}_Create) {{
  // Returns an `arith.constant` op, which will never match the {2} dialect check.
  auto testOp = createIndexConstOp();
  
  // This condition is always false, so the function is never actually called.
  // We only verify it compiles and links correctly.
  if ({4}(testOp)) {{
    auto location = mlirLocationUnknownGet(context);
{5}
    (void){3}{2}Create(context, location{6});
  }
  
  mlirOperationDestroy(testOp);
}
)";

    assert(!className.empty() && "className must be set");
    os << llvm::formatv(
        fmt,
        FunctionPrefix,          // {0}
        dialectNameCapitalized,  // {1}
        className,               // {2}
        testPrefix,              // {3}
        isACheck,                // {4}
        generateDummyParams(op), // {5}
        generateParamList(op)    // {6}
    );
  }

  /// @brief Generate operand getter and setter tests
  /// @param op The operation definition
  void genOperandTests(const Operator &op) const {
    static constexpr char OperandGetterTest[] = R"(
TEST_F({1}OpLinkTests, {0}_{2}_Get{3}) {{
  auto testOp = createIndexConstOp();
  
  if ({4}(testOp)) {{
    (void){0}{1}{2}Get{3}(testOp);
  }
  
  mlirOperationDestroy(testOp);
}
)";

    static constexpr char OperandSetterTest[] = R"(
TEST_F({1}OpLinkTests, {0}_{2}_Set{3}) {{
  auto testOp = createIndexConstOp();
  
  if ({4}(testOp)) {{
    auto dummyValue = mlirOperationGetResult(testOp, 0);
    {0}{1}{2}Set{3}(testOp, dummyValue);
  }
  
  mlirOperationDestroy(testOp);
}
)";

    static constexpr char VariadicOperandCountGetterTest[] = R"(
TEST_F({1}OpLinkTests, {0}_{2}_Get{3}Count) {{
  auto testOp = createIndexConstOp();
  
  if ({4}(testOp)) {{
    (void){0}{1}{2}Get{3}Count(testOp);
  }
  
  mlirOperationDestroy(testOp);
}
)";

    static constexpr char VariadicOperandIndexedGetterTest[] = R"(
TEST_F({1}OpLinkTests, {0}_{2}_Get{3}_Indexed) {{
  auto testOp = createIndexConstOp();
  
  if ({4}(testOp)) {{
    (void){0}{1}{2}Get{3}(testOp, 0);
  }
  
  mlirOperationDestroy(testOp);
}
)";

    static constexpr char VariadicOperandSetterTest[] = R"(
TEST_F({1}OpLinkTests, {0}_{2}_Set{3}_Variadic) {{
  auto testOp = createIndexConstOp();
  
  if ({4}(testOp)) {{
    auto dummyValue = mlirOperationGetResult(testOp, 0);
    MlirValue values[] = {{dummyValue};
    {0}{1}{2}Set{3}(testOp, 1, values);
  }
  
  mlirOperationDestroy(testOp);
}
)";
    assert(!className.empty() && "className must be set");

    for (int i = 0, e = op.getNumOperands(); i < e; ++i) {
      const auto &operand = op.getOperand(i);
      std::string capName = toPascalCase(operand.name);
      if (operand.isVariadic()) {
        if (GenOpOperandGetters) {
          os << llvm::formatv(
              VariadicOperandCountGetterTest,
              FunctionPrefix,         // {0}
              dialectNameCapitalized, // {1}
              className,              // {2}
              capName,                // {3}
              isACheck                // {4}
          );
          os << llvm::formatv(
              VariadicOperandIndexedGetterTest,
              FunctionPrefix,         // {0}
              dialectNameCapitalized, // {1}
              className,              // {2}
              capName,                // {3}
              isACheck                // {4}
          );
        }
        if (GenOpOperandSetters) {
          os << llvm::formatv(
              VariadicOperandSetterTest,
              FunctionPrefix,         // {0}
              dialectNameCapitalized, // {1}
              className,              // {2}
              capName,                // {3}
              isACheck                // {4}
          );
        }
      } else {
        if (GenOpOperandGetters) {
          os << llvm::formatv(
              OperandGetterTest,
              FunctionPrefix,         // {0}
              dialectNameCapitalized, // {1}
              className,              // {2}
              capName,                // {3}
              isACheck                // {4}
          );
        }
        if (GenOpOperandSetters) {
          os << llvm::formatv(
              OperandSetterTest,
              FunctionPrefix,         // {0}
              dialectNameCapitalized, // {1}
              className,              // {2}
              capName,                // {3}
              isACheck                // {4}
          );
        }
      }
    }
  }

  /// @brief Generate attribute getter and setter tests
  /// @param op The operation definition
  void genAttributeTests(const Operator &op) const {
    static constexpr char AttributeGetterTest[] = R"(
TEST_F({1}OpLinkTests, {0}_{2}_Get{3}Attr) {{
  auto testOp = createIndexConstOp();
  
  if ({4}(testOp)) {{
    (void){0}{1}{2}Get{3}(testOp);
  }
  
  mlirOperationDestroy(testOp);
}
)";

    static constexpr char AttributeSetterTest[] = R"(
TEST_F({1}OpLinkTests, {0}_{2}_Set{3}Attr) {{
  auto testOp = createIndexConstOp();
  
  if ({4}(testOp)) {{
    auto dummyAttr = mlirIntegerAttrGet(mlirIndexTypeGet(context), 0);
    {0}{1}{2}Set{3}(testOp, dummyAttr);
  }
  
  mlirOperationDestroy(testOp);
}
)";
    assert(!className.empty() && "className must be set");

    for (const auto &namedAttr : op.getAttributes()) {
      std::string capName = toPascalCase(namedAttr.name);
      if (GenOpAttributeGetters) {
        os << llvm::formatv(
            AttributeGetterTest,
            FunctionPrefix,         // {0}
            dialectNameCapitalized, // {1}
            className,              // {2}
            capName,                // {3}
            isACheck                // {4}
        );
      }
      if (GenOpAttributeSetters) {
        os << llvm::formatv(
            AttributeSetterTest,
            FunctionPrefix,         // {0}
            dialectNameCapitalized, // {1}
            className,              // {2}
            capName,                // {3}
            isACheck                // {4}
        );
      }
    }
  }

  /// @brief Generate result getter tests
  /// @param op The operation definition
  void genResultTests(const Operator &op) const {
    static constexpr char ResultGetterTest[] = R"(
TEST_F({1}OpLinkTests, {0}_{2}_Get{3}) {{
  auto testOp = createIndexConstOp();
  
  if ({4}(testOp)) {{
    (void){0}{1}{2}Get{3}(testOp);
  }
  
  mlirOperationDestroy(testOp);
}
)";

    static constexpr char VariadicResultCountGetterTest[] = R"(
TEST_F({1}OpLinkTests, {0}_{2}_Get{3}Count) {{
  auto testOp = createIndexConstOp();
  
  if ({4}(testOp)) {{
    (void){0}{1}{2}Get{3}Count(testOp);
  }
  
  mlirOperationDestroy(testOp);
}
)";

    static constexpr char VariadicResultIndexedGetterTest[] = R"(
TEST_F({1}OpLinkTests, {0}_{2}_Get{3}_Indexed) {{
  auto testOp = createIndexConstOp();
  
  if ({4}(testOp)) {{
    (void){0}{1}{2}Get{3}(testOp, 0);
  }
  
  mlirOperationDestroy(testOp);
}
)";
    assert(!className.empty() && "className must be set");

    for (int i = 0, e = op.getNumResults(); i < e; ++i) {
      const auto &result = op.getResult(i);
      std::string resultName =
          result.name.empty() ? llvm::formatv("Result{0}", i).str() : result.name.str();
      std::string capName = toPascalCase(resultName);

      if (result.isVariadic()) {
        os << llvm::formatv(
            VariadicResultCountGetterTest,
            FunctionPrefix,         // {0}
            dialectNameCapitalized, // {1}
            className,              // {2}
            capName, isACheck       // {3}
        );
        os << llvm::formatv(
            VariadicResultIndexedGetterTest,
            FunctionPrefix,         // {0}
            dialectNameCapitalized, // {1}
            className,              // {2}
            capName, isACheck       // {3}
        );
      } else {
        os << llvm::formatv(
            ResultGetterTest,
            FunctionPrefix,         // {0}
            dialectNameCapitalized, // {1}
            className,              // {2}
            capName,                // {3}
            isACheck                // {4}
        );
      }
    }
  }

  /// @brief Generate region getter tests
  /// @param op The operation definition
  void genRegionTests(const Operator &op) const {
    static constexpr char RegionGetterTest[] = R"(
TEST_F({1}OpLinkTests, {0}_{2}_Get{3}Region) {{
  auto testOp = createIndexConstOp();
  
  if ({4}(testOp)) {{
    (void){0}{1}{2}Get{3}(testOp);
  }
  
  mlirOperationDestroy(testOp);
}
)";

    static constexpr char VariadicRegionCountGetterTest[] = R"(
TEST_F({1}OpLinkTests, {0}_{2}_Get{3}Count) {{
  auto testOp = createIndexConstOp();
  
  if ({4}(testOp)) {{
    (void){0}{1}{2}Get{3}Count(testOp);
  }
  
  mlirOperationDestroy(testOp);
}
)";

    static constexpr char VariadicRegionIndexedGetterTest[] = R"(
TEST_F({1}OpLinkTests, {0}_{2}_Get{3}_Indexed) {{
  auto testOp = createIndexConstOp();
  
  if ({4}(testOp)) {{
    (void){0}{1}{2}Get{3}(testOp, 0);
  }
  
  mlirOperationDestroy(testOp);
}
)";
    assert(!className.empty() && "className must be set");

    for (int i = 0, e = op.getNumRegions(); i < e; ++i) {
      const auto &region = op.getRegion(i);
      std::string regionName =
          region.name.empty() ? llvm::formatv("Region{0}", i).str() : region.name.str();
      std::string capName = toPascalCase(regionName);

      if (region.isVariadic()) {
        os << llvm::formatv(
            VariadicRegionCountGetterTest,
            FunctionPrefix,         // {0}
            dialectNameCapitalized, // {1}
            className,              // {2}
            capName,                // {3}
            isACheck                // {4}
        );
        os << llvm::formatv(
            VariadicRegionIndexedGetterTest,
            FunctionPrefix,         // {0}
            dialectNameCapitalized, // {1}
            className,              // {2}
            capName,                // {3}
            isACheck                // {4}
        );
      } else {
        os << llvm::formatv(
            RegionGetterTest,
            FunctionPrefix,         // {0}
            dialectNameCapitalized, // {1}
            className,              // {2}
            capName,                // {3}
            isACheck                // {4}
        );
      }
    }
  }

  /// @brief Generate operation name getter test
  void genOperationNameGetterTest() const {
    static constexpr char OperationNameGetterTest[] = R"(
TEST_F({1}OpLinkTests, {0}_{2}_GetOperationName) {{
  auto testOp = createIndexConstOp();
  
  if ({3}(testOp)) {{
    (void){0}{1}{2}GetOperationName(testOp);
  }
  
  mlirOperationDestroy(testOp);
}
)";
    assert(!className.empty() && "className must be set");
    os << llvm::formatv(
        OperationNameGetterTest,
        FunctionPrefix,         // {0}
        dialectNameCapitalized, // {1}
        className,              // {2}
        isACheck                // {3}
    );
  }

  /// @brief Generate all tests for a complete operation record
  /// @param op The operation definition
  void genCompleteRecord(const Operator &op) {
    const Dialect &defDialect = op.getDialect();

    // Generate for the selected dialect only
    if (defDialect.getName() != DialectName) {
      return;
    }

    this->setDialectAndClassName(&defDialect, op.getCppClassName());

    if (GenIsA) {
      this->genIsATest();
    }
    if (GenOpCreate && !op.skipDefaultBuilders()) {
      this->genCreateOpTest(op);
    }
    if (GenOpNameGetter) {
      this->genOperationNameGetterTest();
    }
    if (GenOpOperandGetters || GenOpOperandSetters) {
      this->genOperandTests(op);
    }
    if (GenOpAttributeGetters || GenOpAttributeSetters) {
      this->genAttributeTests(op);
    }
    if (GenOpRegionGetters) {
      this->genRegionTests(op);
    }
    if (GenOpResultGetters) {
      this->genResultTests(op);
    }
    if (GenExtraClassMethods) {
      this->genExtraMethods(op.getExtraClassDeclaration());
    }
  }

protected:
  virtual void setDialectAndClassName(const Dialect *d, StringRef cppClassName) override {
    Generator::setDialectAndClassName(d, cppClassName);
    assert(!className.empty() && "className must be set");
    this->testPrefix = llvm::formatv(
                           "{0}{1}",
                           FunctionPrefix,              // {0}
                           this->dialectNameCapitalized // {1}
    )
                           .str();
    this->isACheck = llvm::formatv(
                         "{0}OperationIsA{1}{2}",
                         FunctionPrefix,               // {0}
                         this->dialectNameCapitalized, // {1}
                         this->className               // {2}
    )
                         .str();
  }

  std::string testPrefix;
  std::string isACheck;

private:
  /// @brief Generate dummy parameters for create function based on operation
  /// @param op The operation definition
  /// @return String containing dummy parameter declarations
  static std::string generateDummyParams(const Operator &op) {
    // Use raw_string_ostream for efficient string building
    std::string paramsBuffer;
    llvm::raw_string_ostream paramsStream(paramsBuffer);

    // Declare dummyValue first
    paramsStream << "    auto dummyValue = mlirOperationGetResult(testOp, 0);\n";

    // Add operands
    for (const auto &operand : op.getOperands()) {
      // per `generateParamList()` only need to create something additional in case
      // of variadic operand, otherwise `dummyValue` is used directly.
      if (operand.isVariadic()) {
        paramsStream << llvm::formatv(
            "    MlirValue {0}Values[] = {{dummyValue};\n"
            "    intptr_t {0}Size = 0;\n",
            operand.name
        );
      }
    }

    // Add attributes
    for (const auto &namedAttr : op.getAttributes()) {
      std::string rhs;
      std::optional<std::string> attrType = tryCppTypeToCapiType(namedAttr.attr.getStorageType());
      if (attrType.has_value() && attrType.value() == "MlirIdentifier") {
        rhs = "mlirOperationGetName(testOp)";
      } else {
        rhs = "mlirIntegerAttrGet(mlirIndexTypeGet(context), 0)";
      }
      paramsStream << llvm::formatv("    auto {0}Attr = {1};\n", namedAttr.name, rhs);
    }

    // Add result types if not inferred
    if (!op.allResultTypesKnown()) {
      for (int i = 0, e = op.getNumResults(); i < e; ++i) {
        const auto &result = op.getResult(i);
        std::string resultName =
            result.name.empty() ? llvm::formatv("result{0}", i).str() : result.name.str();
        if (result.isVariadic()) {
          paramsStream << llvm::formatv(
              "    auto {0}TypeArray = mlirIndexTypeGet(context);\n"
              "    MlirType {0}Types[] = {{{0}TypeArray};\n"
              "    intptr_t {0}Size = 0;\n",
              resultName
          );
        } else {
          paramsStream << llvm::formatv(
              "    auto {0}Type = mlirIndexTypeGet(context);\n", resultName
          );
        }
      }
    }

    // Add regions
    for (int i = 0, e = op.getNumRegions(); i < e; ++i) {
      const auto &region = op.getRegion(i);
      std::string regionName =
          region.name.empty() ? llvm::formatv("region{0}", i).str() : region.name.str();
      if (region.isVariadic()) {
        paramsStream << llvm::formatv(
            "    auto {0}Array = mlirRegionCreate();\n"
            "    MlirRegion {0}[] = {{{0}Array};\n"
            "    intptr_t {0}Size = 0;\n",
            regionName
        );
      } else {
        paramsStream << llvm::formatv("    auto {0} = mlirRegionCreate();\n", regionName);
      }
    }

    return paramsBuffer;
  }

  /// @brief Generate parameter list for create function call
  /// @param op The operation definition
  /// @return String containing the parameter list
  static std::string generateParamList(const Operator &op) {
    // Use raw_string_ostream for efficient string building
    std::string paramsBuffer;
    llvm::raw_string_ostream paramsStream(paramsBuffer);

    // Add operands
    for (const auto &operand : op.getOperands()) {
      if (operand.isVariadic()) {
        paramsStream << llvm::formatv(", {0}Size, {0}Values", operand.name);
      } else {
        paramsStream << ", dummyValue";
      }
    }

    // Add attributes
    for (const auto &namedAttr : op.getAttributes()) {
      paramsStream << llvm::formatv(", {0}Attr", namedAttr.name);
    }

    // Add result types if not inferred
    if (!op.allResultTypesKnown()) {
      for (int i = 0, e = op.getNumResults(); i < e; ++i) {
        const auto &result = op.getResult(i);
        std::string resultName =
            result.name.empty() ? llvm::formatv("result{0}", i).str() : result.name.str();
        if (result.isVariadic()) {
          paramsStream << llvm::formatv(", {0}Size, {0}Types", resultName);
        } else {
          paramsStream << llvm::formatv(", {0}Type", resultName);
        }
      }
    }

    // Add regions
    for (int i = 0, e = op.getNumRegions(); i < e; ++i) {
      const auto &region = op.getRegion(i);
      std::string regionName =
          region.name.empty() ? llvm::formatv("region{0}", i).str() : region.name.str();
      if (region.isVariadic()) {
        paramsStream << llvm::formatv(", {0}Size, {0}", regionName);
      } else {
        paramsStream << llvm::formatv(", {0}", regionName);
      }
    }

    return paramsBuffer;
  }
};

} // namespace

/// Emit C API tests for operations
static bool emitOpCAPITests(const llvm::RecordKeeper &records, raw_ostream &os) {
  // Generate file header
  emitSourceFileHeader("Op C API Tests", os, records);

  // Create generator
  OpTestGenerator generator(os);

  // Generate test class prologue
  generator.genTestClassPrologue();

  // Generate tests for each operation
  for (const auto *def : records.getAllDerivedDefinitions("Op")) {
    Operator op(def);
    generator.genCompleteRecord(op);
  }

  return false;
}

static mlir::GenRegistration
    genOpCAPITests("gen-op-capi-tests", "Generate operation C API unit tests", &emitOpCAPITests);
