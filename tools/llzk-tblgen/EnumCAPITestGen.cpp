//===- EnumCAPITestGen.cpp - C API test generator for enums --------------===//
//
// Part of the LLZK Project, under the Apache License v2.0.
// See LICENSE.txt for license information.
// Copyright 2025 Veridise Inc.
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//
//
// EnumCAPITestGen generates unit tests for the C API enums generated by
// EnumCAPIGen. These are link-time tests that ensure all generated enum
// declarations and wrap/unwrap functions compile and link properly.
//
// Test Strategy:
// - Tests verify enum values can be assigned and compared
// - Tests verify wrap/unwrap functions compile and link (though the C++ type
//   doesn't exist in test context, the functions still need to link)
// - This ensures all enum cases are properly declared and wrap/unwrap functions
//   have correct signatures
//
//===----------------------------------------------------------------------===//

#include <mlir/TableGen/Attribute.h>
#include <mlir/TableGen/GenInfo.h>

#include <llvm/ADT/StringExtras.h>
#include <llvm/Support/CommandLine.h>
#include <llvm/Support/FormatVariadic.h>
#include <llvm/TableGen/Record.h>
#include <llvm/TableGen/TableGenBackend.h>

#include "CommonCAPIGen.h"

using namespace mlir;
using namespace mlir::tblgen;

namespace {

/// @brief Generator for enum C API tests
///
/// This class generates link-time tests for enum C APIs. The tests verify
/// that all generated enums and wrap/unwrap functions compile and link correctly.
struct EnumTestGenerator : public Generator {
  /// @brief Construct an enum test generator
  /// @param outputStream The output stream for generated code
  EnumTestGenerator(llvm::raw_ostream &outputStream) : Generator("Enum", outputStream) {}

  virtual void genExtraMethod(const ExtraMethod &method) const override {
    llvm_unreachable("Enums cannot have extra methods");
  }

  /// @brief Generate the test class prologue
  void genTestClassPrologue() const {
    static constexpr char fmt[] =
        R"(#include "llzk-c/Dialect/{0}.h"

#include <mlir-c/IR.h>

class {0}EnumLinkTests : public CAPITest {{};
)";
    os << llvm::formatv(fmt, dialectNameCapitalized);
  }

  /// @brief Generate enum usage test
  /// @param cEnumName The C enum name
  /// @param firstCaseValue The first enum case value
  void genEnumUsageTest(StringRef cEnumName, StringRef firstCaseValue) const {
    static constexpr char fmt[] = R"(
// This test ensures the {1} enum compiles and links properly.
TEST_F({0}EnumLinkTests, Enum_{1}_Usage) {{
  // We create a variable and check that enum values can be assigned.
  {1} enumValue = {2};
  (void)enumValue;
  
  // Verify we can compare enum values
  EXPECT_EQ(enumValue, {2});
}
)";
    os << llvm::formatv(fmt, dialectNameCapitalized, cEnumName, firstCaseValue);
  }

  /// @brief Generate wrap/unwrap test
  /// @param cEnumName The C enum name
  /// @param firstCaseValue The first enum case value
  void genWrapUnwrapTest(StringRef cEnumName, StringRef firstCaseValue) const {
    static constexpr char fmt[] = R"(
// This test ensures wrap/unwrap functions for {1} compile and link.
TEST_F({0}EnumLinkTests, Enum_{1}_WrapUnwrap) {{
  // We use the first enum case value for testing.
  {1} cValue = {2};
  
  // Test that wrap and unwrap are inverses (at compile/link time)
  // The actual C++ type doesn't exist in test context, so we just
  // verify the functions exist and link.
  {1} roundTrip = wrap(unwrap(cValue));
  EXPECT_EQ(cValue, roundTrip);
}
)";
    os << llvm::formatv(fmt, dialectNameCapitalized, cEnumName, firstCaseValue);
  }

  /// @brief Generate all tests for a complete enum record
  /// @param enumInfo The enum attribute definition
  void genCompleteRecord(const EnumAttr &enumInfo) {
    // EnumAttr does not contain a Dialect reference, so filter by C++ namespace instead.
    if (!DialectName.empty() && !enumInfo.getCppNamespace().contains_insensitive(DialectName)) {
      return;
    }

    std::vector<EnumAttrCase> enumCases = enumInfo.getAllCases();
    if (enumCases.empty()) {
      return;
    }

    // Get enum name
    std::string enumClassName = enumInfo.getEnumClassName().str();
    std::string cEnumName =
        toPascalCase(FunctionPrefix) + toPascalCase(DialectName) + toPascalCase(enumClassName);

    // Get first enum case for testing
    std::string firstCase = enumCases[0].getSymbol().upper();
    std::string firstCaseValue = llvm::formatv("{0}_{1}", cEnumName, firstCase).str();

    // Generate enum usage test
    this->genEnumUsageTest(cEnumName, firstCaseValue);

    // Generate wrap/unwrap test
    this->genWrapUnwrapTest(cEnumName, firstCaseValue);
  }
};

} // namespace

/// Emit C API tests for enums
static bool emitEnumCAPITests(const llvm::RecordKeeper &records, raw_ostream &os) {
  // Generate file header
  emitSourceFileHeader("Enum C API Tests", os, records);

  // Create generator
  EnumTestGenerator generator(os);

  // Generate test class prologue
  generator.genTestClassPrologue();

  // Generate tests for each enum
  for (const auto *def : records.getAllDerivedDefinitionsIfDefined("EnumAttrInfo")) {
    EnumAttr enumInfo(def);
    generator.genCompleteRecord(enumInfo);
  }

  return false;
}

static mlir::GenRegistration
    genEnumCAPITests("gen-enum-capi-tests", "Generate enum C API unit tests", &emitEnumCAPITests);
