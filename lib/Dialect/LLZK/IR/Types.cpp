#include "llzk/Dialect/LLZK/IR/Ops.h"
#include "llzk/Dialect/LLZK/IR/Types.h"
#include "llzk/Dialect/LLZK/Util/SymbolHelper.h"

#include <mlir/IR/BuiltinTypeInterfaces.h>
#include <mlir/Support/LogicalResult.h>

#include <llvm/ADT/SmallVector.h>

namespace llzk {

/// Checks if the type is a LLZK Array and it also contains
/// a valid LLZK type.
bool isValidArrayType(mlir::Type type) {
  return llvm::isa<llzk::ArrayType>(type) &&
         isValidType(llvm::cast<::llzk::ArrayType>(type).getElementType());
}

// valid types: I1, Index, LLZK_FeltType, LLZK_StructType, LLZK_ArrayType
bool isValidType(mlir::Type type) {
  return type.isSignlessInteger(1) || llvm::isa<::mlir::IndexType>(type) ||
         llvm::isa<llzk::FeltType>(type) || llvm::isa<llzk::StructType>(type) ||
         isValidArrayType(type);
}

// valid types: I1, Index, LLZK_FeltType, LLZK_ArrayType
bool isValidEmitEqType(mlir::Type type) {
  return type.isSignlessInteger(1) || llvm::isa<::mlir::IndexType>(type) ||
         llvm::isa<llzk::FeltType>(type) ||
         (llvm::isa<llzk::ArrayType>(type) &&
          isValidEmitEqType(llvm::cast<::llzk::ArrayType>(type).getElementType()));
}

bool areSameType(mlir::Type lhs, mlir::Type rhs, std::vector<llvm::StringRef> rhsRevPrefix) {
  if (lhs == rhs) {
    return true;
  }
  if (llvm::isa<llzk::StructType>(lhs) && llvm::isa<llzk::StructType>(rhs)) {
    llvm::SmallVector<mlir::StringRef> lhsNames =
        getNames(llvm::cast<StructType>(lhs).getNameRef());
    llvm::SmallVector<mlir::StringRef> rhsNames =
        getNames(llvm::cast<StructType>(rhs).getNameRef());
    rhsNames.insert(rhsNames.begin(), rhsRevPrefix.rbegin(), rhsRevPrefix.rend());

    return lhsNames == rhsNames;
  }
  return false;
}

mlir::FailureOr<SymbolLookupResult<StructDefOp>>
StructType::getDefinition(mlir::SymbolTableCollection &symbolTable, mlir::Operation *op) {
  auto def = lookupTopLevelSymbol<StructDefOp>(symbolTable, getNameRef(), op);
  if (mlir::failed(def)) {
    return op->emitError() << "no '" << StructDefOp::getOperationName() << "' named \""
                           << getNameRef() << "\"";
  } else {
    return def;
  }
}

mlir::LogicalResult
StructType::verifySymbolRef(mlir::SymbolTableCollection &symbolTable, mlir::Operation *op) {
  return getDefinition(symbolTable, op);
}

mlir::LogicalResult ArrayType::verify(
    llvm::function_ref<mlir::InFlightDiagnostic()> emitError, mlir::Type elementType,
    llvm::ArrayRef<int64_t> shape
) {

  // If a user of LLZK needs the shape to be statically defined
  // it should check it here. How to communicate that need to the type is TBD.
  if (shape.size() <= 0) {
    return emitError() << "array must have a shape of at least one element";
  }
  // An array can hold any LLZK type bar Arrays
  auto typeCheckResult = checkValidType(emitError, elementType);
  if (mlir::succeeded(typeCheckResult)) {
    if (llvm::isa<llzk::ArrayType>(elementType)) {
      return emitError() << "array inner type cannot be array";
    }
  }
  return typeCheckResult;
}

bool ArrayType::hasRank() const {
  return true; // A LLZK Array is ranked by construction.
}

ArrayType
ArrayType::cloneWith(std::optional<llvm::ArrayRef<int64_t>> shape, mlir::Type elementType) const {
  llvm::ArrayRef<int64_t> newShape = getShape();
  if (shape.has_value()) {
    newShape = *shape;
  }
  return ArrayType::get(elementType.getContext(), elementType, newShape);
}

int64_t ArrayType::getNumElements() const { return mlir::ShapedType::getNumElements(getShape()); }

// The code for these two methods was based on
// the autogenerated code by TableGen

/// A LLZK Array has a similar format to tensors
/// and memref types: <$shape x $type>
/// i.e. !llzk.array<2x2x!llzk.felt>
///   This will produce a shape of [2,2]
///   and a type of LLZK's Felt
mlir::Type ArrayType::parse(mlir::AsmParser &parser) {
  ::mlir::Builder odsBuilder(parser.getContext());
  ::llvm::SMLoc loc = parser.getCurrentLocation();
  // Parse literal '<'
  if (parser.parseLess()) {
    return {};
  }

  // I worry this array may dissapear early can cause
  // an Use-After-Free but the MLIR code I studied did
  // it too so it may be fine.  -- Dani
  llvm::SmallVector<int64_t> parsedShape;

  // The default configuration is good for our purpose
  //   allowDynamic = true
  //    This allows ? values.
  //    Wether an unknown dimension size is allowed or
  //    not will depend on the semantics the array finds
  //    itself in.
  //   withTrailing = true
  //    The parser will consume a literal `x` token
  //    if its trailing after the rest of the shape has been
  //    parsed. This leaves the head right at the type declaration.
  auto _result_shape = parser.parseDimensionList(parsedShape);

  // Parse variable 'elementType'
  auto _result_elementType = ::mlir::FieldParser<::mlir::Type>::parse(parser);
  if (::mlir::failed(_result_elementType)) {
    parser.emitError(
        parser.getCurrentLocation(),
        "failed to parse LLZK_ArrayType parameter 'elementType' which is to be a `::mlir::Type`"
    );
    return {};
  }
  // Parse literal '>'
  if (parser.parseGreater()) {
    return {};
  }

  assert(::mlir::succeeded(_result_elementType));
  assert(::mlir::succeeded(_result_shape));

  return parser.getChecked<ArrayType>(
      loc, parser.getContext(), ::mlir::Type(*_result_elementType),
      ::llvm::ArrayRef<int64_t>(parsedShape)
  );
}

/// Prints the array type with the following format
/// <$shape x $type>
/// i.e. !llzk.array<2x2 x !llzk.felt>
void ArrayType::print(mlir::AsmPrinter &printer) const {
  mlir::Builder odsBuilder(getContext());
  printer << "<";
  printer.printDimensionList(getShape());
  printer << " x ";
  printer.printStrippedAttrOrType(getElementType());
  printer << ">";
}

} // namespace llzk
