<!-- HTML header for doxygen 1.13.2-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LLZK: llzk Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<!-- doxygen-awesome extensions -->
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeParagraphLink.init()
    DoxygenAwesomeInteractiveToc.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LLZK<span id="projectnumber">&#160;0.1.0</span>
   </div>
   <div id="projectbrief">Veridise&#39;s ZK Language IR</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('namespacellzk.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#concepts">Concepts</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">llzk Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellzk_1_1affine_map_helpers.html">affineMapHelpers</a></td></tr>
<tr class="memdesc:namespacellzk_1_1affine_map_helpers"><td class="mdescLeft">&#160;</td><td class="mdescRight">Group together all implementation related to AffineMap type parameters. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellzk_1_1array.html">array</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellzk_1_1boolean.html">boolean</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellzk_1_1cast.html">cast</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellzk_1_1component.html">component</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellzk_1_1constrain.html">constrain</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellzk_1_1dataflow.html">dataflow</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellzk_1_1debug.html">debug</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellzk_1_1felt.html">felt</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellzk_1_1function.html">function</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellzk_1_1global.html">global</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellzk_1_1impl.html">impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellzk_1_1include.html">include</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellzk_1_1polymorphic.html">polymorphic</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellzk_1_1string.html">string</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellzk_1_1undef.html">undef</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllzk_1_1_call_graph.html">CallGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a port of mlir::CallGraph that has been adapted to use the custom symbol lookup helpers (see <a class="el" href="_symbol_helper_8h.html">SymbolHelper.h</a>).  <a href="classllzk_1_1_call_graph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllzk_1_1_call_graph_analysis.html">CallGraphAnalysis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An analysis wrapper to compute the <code><a class="el" href="classllzk_1_1_call_graph.html" title="This is a port of mlir::CallGraph that has been adapted to use the custom symbol lookup helpers (see ...">CallGraph</a></code> for a <code>Module</code>.  <a href="classllzk_1_1_call_graph_analysis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllzk_1_1_call_graph_node.html">CallGraphNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a simple port of the mlir::CallGraphNode with <a class="el" href="classllzk_1_1_call_graph.html" title="This is a port of mlir::CallGraph that has been adapted to use the custom symbol lookup helpers (see ...">llzk::CallGraph</a> as a friend class, for mlir::CallGraphNode has a private constructor and can only be constructed by mlir::CallGraph.  <a href="classllzk_1_1_call_graph_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllzk_1_1_call_graph_printer_pass.html">CallGraphPrinterPass</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllzk_1_1_call_graph_reachability_analysis.html">CallGraphReachabilityAnalysis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lazily-constructed reachability analysis.  <a href="classllzk_1_1_call_graph_reachability_analysis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllzk_1_1_call_graph_s_c_cs_printer_pass.html">CallGraphSCCsPrinterPass</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllzk_1_1_constrain_ref.html">ConstrainRef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a reference to a llzk object within a constrain function call.  <a href="classllzk_1_1_constrain_ref.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllzk_1_1_constrain_ref_analysis.html">ConstrainRefAnalysis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The dataflow analysis that computes the set of references that LLZK operations use and produce.  <a href="classllzk_1_1_constrain_ref_analysis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllzk_1_1_constrain_ref_index.html">ConstrainRefIndex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines an index into an LLZK object.  <a href="classllzk_1_1_constrain_ref_index.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllzk_1_1_constrain_ref_lattice.html">ConstrainRefLattice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A lattice for use in dense analysis.  <a href="classllzk_1_1_constrain_ref_lattice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllzk_1_1_constrain_ref_lattice_value.html">ConstrainRefLatticeValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A value at a given point of the <a class="el" href="classllzk_1_1_constrain_ref_lattice.html" title="A lattice for use in dense analysis.">ConstrainRefLattice</a>.  <a href="classllzk_1_1_constrain_ref_lattice_value.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllzk_1_1_constrain_ref_set.html">ConstrainRefSet</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllzk_1_1_constraint_dependency_graph.html">ConstraintDependencyGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dependency graph of constraints enforced by an LLZK struct.  <a href="classllzk_1_1_constraint_dependency_graph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllzk_1_1_constraint_dependency_graph_module_analysis.html">ConstraintDependencyGraphModuleAnalysis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A module-level analysis for constructing <a class="el" href="classllzk_1_1_constraint_dependency_graph.html" title="A dependency graph of constraints enforced by an LLZK struct.">ConstraintDependencyGraph</a> objects for all structs in the given LLZK module.  <a href="classllzk_1_1_constraint_dependency_graph_module_analysis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllzk_1_1_constraint_dependency_graph_printer_pass.html">ConstraintDependencyGraphPrinterPass</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllzk_1_1_constraint_dependency_graph_struct_analysis.html">ConstraintDependencyGraphStructAnalysis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An analysis wrapper around the <a class="el" href="classllzk_1_1_constraint_dependency_graph.html" title="A dependency graph of constraints enforced by an LLZK struct.">ConstraintDependencyGraph</a> for a given struct.  <a href="classllzk_1_1_constraint_dependency_graph_struct_analysis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllzk_1_1_expression_value.html">ExpressionValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tracks a solver expression and an interval range for that expression.  <a href="classllzk_1_1_expression_value.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllzk_1_1_field.html">Field</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about the prime finite field used for the interval analysis.  <a href="classllzk_1_1_field.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllzk_1_1filtered__raw__ostream.html">filtered_raw_ostream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for <code>llvm::raw_ostream</code> that filters out certain characters selected by a function.  <a href="classllzk_1_1filtered__raw__ostream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllzk_1_1_global_source_mgr.html">GlobalSourceMgr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllzk_1_1_interval.html">Interval</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intervals over a finite field.  <a href="classllzk_1_1_interval.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllzk_1_1_interval_analysis_context.html">IntervalAnalysisContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters and shared objects to pass to child analyses.  <a href="structllzk_1_1_interval_analysis_context.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllzk_1_1_interval_analysis_lattice.html">IntervalAnalysisLattice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps mlir::Values to LatticeValues.  <a href="classllzk_1_1_interval_analysis_lattice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllzk_1_1_interval_analysis_lattice_value.html">IntervalAnalysisLatticeValue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllzk_1_1_interval_analysis_printer_pass.html">IntervalAnalysisPrinterPass</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllzk_1_1_interval_analysis_printer_pass_options.html">IntervalAnalysisPrinterPassOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllzk_1_1_interval_data_flow_analysis.html">IntervalDataFlowAnalysis</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllzk_1_1_l_l_z_k_dialect.html">LLZKDialect</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllzk_1_1_l_l_z_k_dialect_bytecode_interface.html">LLZKDialectBytecodeInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This implements the bytecode interface for the LLZK dialect.  <a href="structllzk_1_1_l_l_z_k_dialect_bytecode_interface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllzk_1_1_l_l_z_k_dialect_version.html">LLZKDialectVersion</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllzk_1_1_module_analysis.html">ModuleAnalysis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An analysis wrapper that runs the given <code>StructAnalysisTy</code> struct analysis over all of the struct contained within the module.  <a href="classllzk_1_1_module_analysis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllzk_1_1_module_builder.html">ModuleBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds out a LLZK-compliant module and provides utilities for populating that module.  <a href="classllzk_1_1_module_builder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllzk_1_1_module_interval_analysis.html">ModuleIntervalAnalysis</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllzk_1_1_named_op_location_less.html">NamedOpLocationLess</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllzk_1_1_no_context.html">NoContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An empty struct that is used for convenience for analyses that do not require any context.  <a href="structllzk_1_1_no_context.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllzk_1_1_op_hash.html">OpHash</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllzk_1_1_op_location_less.html">OpLocationLess</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllzk_1_1_short_type_stringifier.html">ShortTypeStringifier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Note: If any symbol refs in an input Type/Attribute use any of the special characters that this class generates, they are not escaped.  <a href="classllzk_1_1_short_type_stringifier.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllzk_1_1_struct_analysis.html">StructAnalysis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the base class for a dataflow analysis designed to run on a single struct (i.e., a single component).  <a href="classllzk_1_1_struct_analysis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllzk_1_1_struct_interval_analysis.html">StructIntervalAnalysis</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllzk_1_1_struct_intervals.html">StructIntervals</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllzk_1_1_symbol_lookup_result.html">SymbolLookupResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllzk_1_1_symbol_lookup_result_untyped.html">SymbolLookupResultUntyped</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllzk_1_1_unreduced_interval.html">UnreducedInterval</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An inclusive interval [a, b] where a and b are arbitrary integers not necessarily bound to a given field.  <a href="classllzk_1_1_unreduced_interval.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllzk_1_1_unused_declaration_elimination_pass_options.html">UnusedDeclarationEliminationPassOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllzk_1_1_verify_sizes_for_multi_affine_ops.html">VerifySizesForMultiAffineOps</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produces errors if there is an inconsistency in the various attributes/values that are used to support affine map instantiation in the Op marked with this Trait.  <a href="structllzk_1_1_verify_sizes_for_multi_affine_ops.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllzk_1_1_within.html">Within</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="concepts" name="concepts"></a>
Concepts</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptllzk_1_1_struct_analysis_type.html">StructAnalysisType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Any type that is a subclass of <code>StructAnalysis</code>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptllzk_1_1_op_comparable.html">OpComparable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptllzk_1_1_named_op_comparable.html">NamedOpComparable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptllzk_1_1_op_hashable.html">OpHashable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:af0c320a86bace53ee6eb99056458f7d8" id="r_af0c320a86bace53ee6eb99056458f7d8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af0c320a86bace53ee6eb99056458f7d8">TranslationMap</a></td></tr>
<tr class="separator:af0c320a86bace53ee6eb99056458f7d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ec981cf9fcf4cfee0a3ae42183bfa95" id="r_a6ec981cf9fcf4cfee0a3ae42183bfa95"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ec981cf9fcf4cfee0a3ae42183bfa95">ConstrainRefRemappings</a> = std::vector&lt;std::pair&lt;<a class="el" href="classllzk_1_1_constrain_ref.html">ConstrainRef</a>, <a class="el" href="classllzk_1_1_constrain_ref_lattice_value.html">ConstrainRefLatticeValue</a>&gt;&gt;</td></tr>
<tr class="separator:a6ec981cf9fcf4cfee0a3ae42183bfa95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36a2156534c7f7ae6aadbf0d8d8fa869" id="r_a36a2156534c7f7ae6aadbf0d8d8fa869"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a36a2156534c7f7ae6aadbf0d8d8fa869">EmitErrorFn</a> = llvm::function_ref&lt;mlir::InFlightDiagnostic()&gt;</td></tr>
<tr class="separator:a36a2156534c7f7ae6aadbf0d8d8fa869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7357b1ebd2b125f62a0a2fd3bf559af1" id="r_a7357b1ebd2b125f62a0a2fd3bf559af1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7357b1ebd2b125f62a0a2fd3bf559af1">OwningEmitErrorFn</a> = std::function&lt;mlir::InFlightDiagnostic()&gt;</td></tr>
<tr class="separator:a7357b1ebd2b125f62a0a2fd3bf559af1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79668426b2b2e76d9dde555e6ddb3852" id="r_a79668426b2b2e76d9dde555e6ddb3852"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a79668426b2b2e76d9dde555e6ddb3852">ManagedResources</a></td></tr>
<tr class="separator:a79668426b2b2e76d9dde555e6ddb3852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a513acdd19d4296f6623ca75ed5eeb904" id="r_a513acdd19d4296f6623ca75ed5eeb904"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a513acdd19d4296f6623ca75ed5eeb904">UnificationMap</a> = mlir::DenseMap&lt;std::pair&lt;mlir::SymbolRefAttr, <a class="el" href="#a2a5039e04435e7c0f3883c08db97e95a">Side</a>&gt;, mlir::Attribute&gt;</td></tr>
<tr class="memdesc:a513acdd19d4296f6623ca75ed5eeb904"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optional result from type unifications.  <br /></td></tr>
<tr class="separator:a513acdd19d4296f6623ca75ed5eeb904"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a2a5039e04435e7c0f3883c08db97e95a" id="r_a2a5039e04435e7c0f3883c08db97e95a"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2a5039e04435e7c0f3883c08db97e95a">Side</a> { <a class="el" href="#a2a5039e04435e7c0f3883c08db97e95aaba2b45bdc11e2a4a6e86aab2ac693cbb">EMPTY</a> = 0
, <a class="el" href="#a2a5039e04435e7c0f3883c08db97e95aa8cbc0fb889c6cc21e0be26227a2b468b">LHS</a>
, <a class="el" href="#a2a5039e04435e7c0f3883c08db97e95aae80302656805aeec44dc5d789d653c6b">RHS</a>
, <a class="el" href="#a2a5039e04435e7c0f3883c08db97e95aad347574c48f5bbb0a804da9bb77d67a3">TOMB</a>
 }</td></tr>
<tr class="separator:a2a5039e04435e7c0f3883c08db97e95a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a81bdf67dd777af0f515ba3c876468bcd" id="r_a81bdf67dd777af0f515ba3c876468bcd"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; mlir::Pass &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a81bdf67dd777af0f515ba3c876468bcd">createCallGraphPrinterPass</a> (llvm::raw_ostream &amp;os=llvm::errs())</td></tr>
<tr class="separator:a81bdf67dd777af0f515ba3c876468bcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80271c2440367129b787c6a3d49528ff" id="r_a80271c2440367129b787c6a3d49528ff"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; mlir::Pass &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a80271c2440367129b787c6a3d49528ff">createCallGraphSCCsPrinterPass</a> (llvm::raw_ostream &amp;os=llvm::errs())</td></tr>
<tr class="separator:a80271c2440367129b787c6a3d49528ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6a0f6fb78eb7be834847f3b789940d9" id="r_ad6a0f6fb78eb7be834847f3b789940d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllzk_1_1_symbol_lookup_result.html">SymbolLookupResult</a>&lt; <a class="el" href="classllzk_1_1component_1_1_struct_def_op.html">StructDefOp</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad6a0f6fb78eb7be834847f3b789940d9">getStructDef</a> (mlir::SymbolTableCollection &amp;tables, mlir::ModuleOp <a class="el" href="#ad46fd35b4b51297b4c6f9ed6fe923b4e">mod</a>, <a class="el" href="classllzk_1_1component_1_1_struct_type.html">StructType</a> ty)</td></tr>
<tr class="memdesc:ad6a0f6fb78eb7be834847f3b789940d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup a <code><a class="el" href="classllzk_1_1component_1_1_struct_def_op.html">StructDefOp</a></code> from a given <code><a class="el" href="classllzk_1_1component_1_1_struct_type.html">StructType</a></code>.  <br /></td></tr>
<tr class="separator:ad6a0f6fb78eb7be834847f3b789940d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1532c216a389f0b2852d1673bd153f8a" id="r_a1532c216a389f0b2852d1673bd153f8a"><td class="memItemLeft" align="right" valign="top">mlir::raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1532c216a389f0b2852d1673bd153f8a">operator&lt;&lt;</a> (mlir::raw_ostream &amp;os, const <a class="el" href="classllzk_1_1_constrain_ref.html">ConstrainRef</a> &amp;rhs)</td></tr>
<tr class="separator:a1532c216a389f0b2852d1673bd153f8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a382c1e1748ae2213b67f93dfc08becac" id="r_a382c1e1748ae2213b67f93dfc08becac"><td class="memItemLeft" align="right" valign="top">mlir::raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a382c1e1748ae2213b67f93dfc08becac">operator&lt;&lt;</a> (mlir::raw_ostream &amp;os, const <a class="el" href="classllzk_1_1_constrain_ref_set.html">ConstrainRefSet</a> &amp;rhs)</td></tr>
<tr class="separator:a382c1e1748ae2213b67f93dfc08becac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf201c6da5261a21b1d31970bc71da0" id="r_adbf201c6da5261a21b1d31970bc71da0"><td class="memItemLeft" align="right" valign="top">mlir::raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adbf201c6da5261a21b1d31970bc71da0">operator&lt;&lt;</a> (mlir::raw_ostream &amp;os, const <a class="el" href="classllzk_1_1_constrain_ref_lattice_value.html">ConstrainRefLatticeValue</a> &amp;v)</td></tr>
<tr class="separator:adbf201c6da5261a21b1d31970bc71da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c811a1921fe5348e526e41525f1baf5" id="r_a0c811a1921fe5348e526e41525f1baf5"><td class="memItemLeft" align="right" valign="top">llvm::raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c811a1921fe5348e526e41525f1baf5">operator&lt;&lt;</a> (llvm::raw_ostream &amp;os, const <a class="el" href="classllzk_1_1_constrain_ref_lattice.html">ConstrainRefLattice</a> &amp;lattice)</td></tr>
<tr class="separator:a0c811a1921fe5348e526e41525f1baf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a580c97b052e21d14057b861edfb047b9" id="r_a580c97b052e21d14057b861edfb047b9"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; mlir::Pass &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a580c97b052e21d14057b861edfb047b9">createConstraintDependencyGraphPrinterPass</a> (llvm::raw_ostream &amp;os=llvm::errs())</td></tr>
<tr class="separator:a580c97b052e21d14057b861edfb047b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad13198c26cc750d881f4b0e53a5955a8" id="r_ad13198c26cc750d881f4b0e53a5955a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllzk_1_1_unreduced_interval.html">UnreducedInterval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad13198c26cc750d881f4b0e53a5955a8">operator+</a> (const <a class="el" href="classllzk_1_1_unreduced_interval.html">UnreducedInterval</a> &amp;lhs, const <a class="el" href="classllzk_1_1_unreduced_interval.html">UnreducedInterval</a> &amp;rhs)</td></tr>
<tr class="separator:ad13198c26cc750d881f4b0e53a5955a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92d9e6ddc8de341fe1c6799854ba6585" id="r_a92d9e6ddc8de341fe1c6799854ba6585"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllzk_1_1_unreduced_interval.html">UnreducedInterval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92d9e6ddc8de341fe1c6799854ba6585">operator-</a> (const <a class="el" href="classllzk_1_1_unreduced_interval.html">UnreducedInterval</a> &amp;lhs, const <a class="el" href="classllzk_1_1_unreduced_interval.html">UnreducedInterval</a> &amp;rhs)</td></tr>
<tr class="separator:a92d9e6ddc8de341fe1c6799854ba6585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abade7b1a147e413c2cddee3e147d6e18" id="r_abade7b1a147e413c2cddee3e147d6e18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllzk_1_1_unreduced_interval.html">UnreducedInterval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abade7b1a147e413c2cddee3e147d6e18">operator*</a> (const <a class="el" href="classllzk_1_1_unreduced_interval.html">UnreducedInterval</a> &amp;lhs, const <a class="el" href="classllzk_1_1_unreduced_interval.html">UnreducedInterval</a> &amp;rhs)</td></tr>
<tr class="separator:abade7b1a147e413c2cddee3e147d6e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e9a147744897bef293d3a64a10dedc0" id="r_a8e9a147744897bef293d3a64a10dedc0"><td class="memItemLeft" align="right" valign="top">std::strong_ordering&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e9a147744897bef293d3a64a10dedc0">operator&lt;=&gt;</a> (const <a class="el" href="classllzk_1_1_unreduced_interval.html">UnreducedInterval</a> &amp;lhs, const <a class="el" href="classllzk_1_1_unreduced_interval.html">UnreducedInterval</a> &amp;rhs)</td></tr>
<tr class="separator:a8e9a147744897bef293d3a64a10dedc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40449a39011029007b6c1b32e0537d51" id="r_a40449a39011029007b6c1b32e0537d51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllzk_1_1_interval.html">Interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a40449a39011029007b6c1b32e0537d51">operator+</a> (const <a class="el" href="classllzk_1_1_interval.html">Interval</a> &amp;lhs, const <a class="el" href="classllzk_1_1_interval.html">Interval</a> &amp;rhs)</td></tr>
<tr class="separator:a40449a39011029007b6c1b32e0537d51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdac41547ae59c95df683ecca710db95" id="r_acdac41547ae59c95df683ecca710db95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllzk_1_1_interval.html">Interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acdac41547ae59c95df683ecca710db95">operator-</a> (const <a class="el" href="classllzk_1_1_interval.html">Interval</a> &amp;lhs, const <a class="el" href="classllzk_1_1_interval.html">Interval</a> &amp;rhs)</td></tr>
<tr class="separator:acdac41547ae59c95df683ecca710db95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06bf01ff7ac76db96afcaadea1fd29c1" id="r_a06bf01ff7ac76db96afcaadea1fd29c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllzk_1_1_interval.html">Interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06bf01ff7ac76db96afcaadea1fd29c1">operator*</a> (const <a class="el" href="classllzk_1_1_interval.html">Interval</a> &amp;lhs, const <a class="el" href="classllzk_1_1_interval.html">Interval</a> &amp;rhs)</td></tr>
<tr class="separator:a06bf01ff7ac76db96afcaadea1fd29c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54bf00755ecf536427677ca6f0ecffcf" id="r_a54bf00755ecf536427677ca6f0ecffcf"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classllzk_1_1_interval.html">Interval</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a54bf00755ecf536427677ca6f0ecffcf">operator/</a> (const <a class="el" href="classllzk_1_1_interval.html">Interval</a> &amp;lhs, const <a class="el" href="classllzk_1_1_interval.html">Interval</a> &amp;rhs)</td></tr>
<tr class="separator:a54bf00755ecf536427677ca6f0ecffcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55d0cf465a99fe73abdc138f5ba0815f" id="r_a55d0cf465a99fe73abdc138f5ba0815f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllzk_1_1_interval.html">Interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a55d0cf465a99fe73abdc138f5ba0815f">operator%</a> (const <a class="el" href="classllzk_1_1_interval.html">Interval</a> &amp;lhs, const <a class="el" href="classllzk_1_1_interval.html">Interval</a> &amp;rhs)</td></tr>
<tr class="separator:a55d0cf465a99fe73abdc138f5ba0815f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acec2696fdf94e6c65ea2acd5863039b2" id="r_acec2696fdf94e6c65ea2acd5863039b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllzk_1_1_expression_value.html">ExpressionValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acec2696fdf94e6c65ea2acd5863039b2">intersection</a> (llvm::SMTSolverRef solver, const <a class="el" href="classllzk_1_1_expression_value.html">ExpressionValue</a> &amp;lhs, const <a class="el" href="classllzk_1_1_expression_value.html">ExpressionValue</a> &amp;rhs)</td></tr>
<tr class="separator:acec2696fdf94e6c65ea2acd5863039b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4133cf302b40a27435b317f0c953c18e" id="r_a4133cf302b40a27435b317f0c953c18e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllzk_1_1_expression_value.html">ExpressionValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4133cf302b40a27435b317f0c953c18e">add</a> (llvm::SMTSolverRef solver, const <a class="el" href="classllzk_1_1_expression_value.html">ExpressionValue</a> &amp;lhs, const <a class="el" href="classllzk_1_1_expression_value.html">ExpressionValue</a> &amp;rhs)</td></tr>
<tr class="separator:a4133cf302b40a27435b317f0c953c18e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11351aaca0b8ece3f9e0c586d2b8b909" id="r_a11351aaca0b8ece3f9e0c586d2b8b909"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllzk_1_1_expression_value.html">ExpressionValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a11351aaca0b8ece3f9e0c586d2b8b909">sub</a> (llvm::SMTSolverRef solver, const <a class="el" href="classllzk_1_1_expression_value.html">ExpressionValue</a> &amp;lhs, const <a class="el" href="classllzk_1_1_expression_value.html">ExpressionValue</a> &amp;rhs)</td></tr>
<tr class="separator:a11351aaca0b8ece3f9e0c586d2b8b909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61c3eb680cebfce54212fc0643edc731" id="r_a61c3eb680cebfce54212fc0643edc731"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllzk_1_1_expression_value.html">ExpressionValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a61c3eb680cebfce54212fc0643edc731">mul</a> (llvm::SMTSolverRef solver, const <a class="el" href="classllzk_1_1_expression_value.html">ExpressionValue</a> &amp;lhs, const <a class="el" href="classllzk_1_1_expression_value.html">ExpressionValue</a> &amp;rhs)</td></tr>
<tr class="separator:a61c3eb680cebfce54212fc0643edc731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0949b4dc945939f8fed321b9e93c9684" id="r_a0949b4dc945939f8fed321b9e93c9684"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllzk_1_1_expression_value.html">ExpressionValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0949b4dc945939f8fed321b9e93c9684">div</a> (llvm::SMTSolverRef solver, <a class="el" href="classllzk_1_1felt_1_1_div_felt_op.html">felt::DivFeltOp</a> op, const <a class="el" href="classllzk_1_1_expression_value.html">ExpressionValue</a> &amp;lhs, const <a class="el" href="classllzk_1_1_expression_value.html">ExpressionValue</a> &amp;rhs)</td></tr>
<tr class="separator:a0949b4dc945939f8fed321b9e93c9684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad46fd35b4b51297b4c6f9ed6fe923b4e" id="r_ad46fd35b4b51297b4c6f9ed6fe923b4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllzk_1_1_expression_value.html">ExpressionValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad46fd35b4b51297b4c6f9ed6fe923b4e">mod</a> (llvm::SMTSolverRef solver, const <a class="el" href="classllzk_1_1_expression_value.html">ExpressionValue</a> &amp;lhs, const <a class="el" href="classllzk_1_1_expression_value.html">ExpressionValue</a> &amp;rhs)</td></tr>
<tr class="separator:ad46fd35b4b51297b4c6f9ed6fe923b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa450de4115eb980c84b45aa6f2ad1ff5" id="r_aa450de4115eb980c84b45aa6f2ad1ff5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllzk_1_1_expression_value.html">ExpressionValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa450de4115eb980c84b45aa6f2ad1ff5">cmp</a> (llvm::SMTSolverRef solver, <a class="el" href="classllzk_1_1boolean_1_1_cmp_op.html">boolean::CmpOp</a> op, const <a class="el" href="classllzk_1_1_expression_value.html">ExpressionValue</a> &amp;lhs, const <a class="el" href="classllzk_1_1_expression_value.html">ExpressionValue</a> &amp;rhs)</td></tr>
<tr class="separator:aa450de4115eb980c84b45aa6f2ad1ff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ac563acc740dbd4b5989188cb54203" id="r_ac4ac563acc740dbd4b5989188cb54203"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllzk_1_1_expression_value.html">ExpressionValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac4ac563acc740dbd4b5989188cb54203">fallbackBinaryOp</a> (llvm::SMTSolverRef solver, Operation *op, const <a class="el" href="classllzk_1_1_expression_value.html">ExpressionValue</a> &amp;lhs, const <a class="el" href="classllzk_1_1_expression_value.html">ExpressionValue</a> &amp;rhs)</td></tr>
<tr class="separator:ac4ac563acc740dbd4b5989188cb54203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc7ec18ae2ac3dba2aa3e969d291e687" id="r_acc7ec18ae2ac3dba2aa3e969d291e687"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllzk_1_1_expression_value.html">ExpressionValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc7ec18ae2ac3dba2aa3e969d291e687">neg</a> (llvm::SMTSolverRef solver, const <a class="el" href="classllzk_1_1_expression_value.html">ExpressionValue</a> &amp;val)</td></tr>
<tr class="separator:acc7ec18ae2ac3dba2aa3e969d291e687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae690ef2a4497229e66730a3c8ae84e0c" id="r_ae690ef2a4497229e66730a3c8ae84e0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllzk_1_1_expression_value.html">ExpressionValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae690ef2a4497229e66730a3c8ae84e0c">notOp</a> (llvm::SMTSolverRef solver, const <a class="el" href="classllzk_1_1_expression_value.html">ExpressionValue</a> &amp;val)</td></tr>
<tr class="separator:ae690ef2a4497229e66730a3c8ae84e0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3bdbdf664bef76f70ff55c971b36618" id="r_af3bdbdf664bef76f70ff55c971b36618"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllzk_1_1_expression_value.html">ExpressionValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af3bdbdf664bef76f70ff55c971b36618">fallbackUnaryOp</a> (llvm::SMTSolverRef solver, Operation *op, const <a class="el" href="classllzk_1_1_expression_value.html">ExpressionValue</a> &amp;val)</td></tr>
<tr class="separator:af3bdbdf664bef76f70ff55c971b36618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59d66a0caa073316e9e8ccf5f96be707" id="r_a59d66a0caa073316e9e8ccf5f96be707"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; mlir::Pass &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59d66a0caa073316e9e8ccf5f96be707">createIntervalAnalysisPrinterPass</a> (llvm::raw_ostream &amp;os=llvm::errs())</td></tr>
<tr class="separator:a59d66a0caa073316e9e8ccf5f96be707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9338ef0435a6cb734c7aebea355d4a36" id="r_a9338ef0435a6cb734c7aebea355d4a36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9338ef0435a6cb734c7aebea355d4a36">registerAllDialects</a> (mlir::DialectRegistry &amp;registry)</td></tr>
<tr class="separator:a9338ef0435a6cb734c7aebea355d4a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47e44fbda81e2f164ab37d3696457eff" id="r_a47e44fbda81e2f164ab37d3696457eff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47e44fbda81e2f164ab37d3696457eff">printAttrs</a> (AsmPrinter &amp;printer, ArrayRef&lt; Attribute &gt; attrs, const StringRef &amp;separator)</td></tr>
<tr class="separator:a47e44fbda81e2f164ab37d3696457eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb8b8c23db146a0a520f07c965318ba4" id="r_aeb8b8c23db146a0a520f07c965318ba4"><td class="memItemLeft" align="right" valign="top">OwningOpRef&lt; ModuleOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb8b8c23db146a0a520f07c965318ba4">createLLZKModule</a> (MLIRContext *context, Location loc)</td></tr>
<tr class="separator:aeb8b8c23db146a0a520f07c965318ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1625d8ebd06095492c891b4fe65d5ef" id="r_ad1625d8ebd06095492c891b4fe65d5ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad1625d8ebd06095492c891b4fe65d5ef">addLangAttrForLLZKDialect</a> (mlir::ModuleOp <a class="el" href="#ad46fd35b4b51297b4c6f9ed6fe923b4e">mod</a>)</td></tr>
<tr class="separator:ad1625d8ebd06095492c891b4fe65d5ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27132e28370fc61e82609260869dedfd" id="r_a27132e28370fc61e82609260869dedfd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a27132e28370fc61e82609260869dedfd">registerTransformationPassPipelines</a> ()</td></tr>
<tr class="separator:a27132e28370fc61e82609260869dedfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44afaec28adf69a4547eab55e5c65cbe" id="r_a44afaec28adf69a4547eab55e5c65cbe"><td class="memItemLeft" align="right" valign="top">llvm::APSInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a44afaec28adf69a4547eab55e5c65cbe">expandingAdd</a> (const llvm::APSInt &amp;lhs, const llvm::APSInt &amp;rhs)</td></tr>
<tr class="memdesc:a44afaec28adf69a4547eab55e5c65cbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safely add lhs and rhs, expanding the width of the result as necessary.  <br /></td></tr>
<tr class="separator:a44afaec28adf69a4547eab55e5c65cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13e9b9e2292a93b9f0e116c399f42cfd" id="r_a13e9b9e2292a93b9f0e116c399f42cfd"><td class="memItemLeft" align="right" valign="top">llvm::APSInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a13e9b9e2292a93b9f0e116c399f42cfd">expandingSub</a> (const llvm::APSInt &amp;lhs, const llvm::APSInt &amp;rhs)</td></tr>
<tr class="memdesc:a13e9b9e2292a93b9f0e116c399f42cfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safely subtract lhs and rhs, expanding the width of the result as necessary.  <br /></td></tr>
<tr class="separator:a13e9b9e2292a93b9f0e116c399f42cfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79f6018c1853e974f7cadc0e3ba4b363" id="r_a79f6018c1853e974f7cadc0e3ba4b363"><td class="memItemLeft" align="right" valign="top">llvm::APSInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a79f6018c1853e974f7cadc0e3ba4b363">expandingMul</a> (const llvm::APSInt &amp;lhs, const llvm::APSInt &amp;rhs)</td></tr>
<tr class="memdesc:a79f6018c1853e974f7cadc0e3ba4b363"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safely multiple lhs and rhs, expanding the width of the result as necessary.  <br /></td></tr>
<tr class="separator:a79f6018c1853e974f7cadc0e3ba4b363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21ddb33b632574b5123ac797e7cf1354" id="r_a21ddb33b632574b5123ac797e7cf1354"><td class="memItemLeft" align="right" valign="top">std::strong_ordering&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a21ddb33b632574b5123ac797e7cf1354">safeCmp</a> (const llvm::APSInt &amp;lhs, const llvm::APSInt &amp;rhs)</td></tr>
<tr class="memdesc:a21ddb33b632574b5123ac797e7cf1354"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares lhs and rhs, regardless of the bitwidth of lhs and rhs.  <br /></td></tr>
<tr class="separator:a21ddb33b632574b5123ac797e7cf1354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3395beb30b5d17bc8a968b14eb3638d6" id="r_a3395beb30b5d17bc8a968b14eb3638d6"><td class="memItemLeft" align="right" valign="top">llvm::SmallVector&lt; StringRef &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3395beb30b5d17bc8a968b14eb3638d6">getNames</a> (SymbolRefAttr ref)</td></tr>
<tr class="separator:a3395beb30b5d17bc8a968b14eb3638d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefd24a67a7806996a53b63a5014c82a2" id="r_aefd24a67a7806996a53b63a5014c82a2"><td class="memItemLeft" align="right" valign="top">llvm::SmallVector&lt; FlatSymbolRefAttr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aefd24a67a7806996a53b63a5014c82a2">getPieces</a> (SymbolRefAttr ref)</td></tr>
<tr class="separator:aefd24a67a7806996a53b63a5014c82a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6233c90d2afb42113aa36eddeebd8f76" id="r_a6233c90d2afb42113aa36eddeebd8f76"><td class="memItemLeft" align="right" valign="top">SymbolRefAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6233c90d2afb42113aa36eddeebd8f76">replaceLeaf</a> (SymbolRefAttr orig, FlatSymbolRefAttr newLeaf)</td></tr>
<tr class="separator:a6233c90d2afb42113aa36eddeebd8f76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a8f8e48ae6b42bbfbccc3b9a58e642d" id="r_a5a8f8e48ae6b42bbfbccc3b9a58e642d"><td class="memItemLeft" align="right" valign="top">SymbolRefAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a8f8e48ae6b42bbfbccc3b9a58e642d">appendLeaf</a> (SymbolRefAttr orig, FlatSymbolRefAttr newLeaf)</td></tr>
<tr class="separator:a5a8f8e48ae6b42bbfbccc3b9a58e642d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1834ce0bbea39a5089abc81e496ea685" id="r_a1834ce0bbea39a5089abc81e496ea685"><td class="memItemLeft" align="right" valign="top">SymbolRefAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1834ce0bbea39a5089abc81e496ea685">appendLeafName</a> (SymbolRefAttr orig, const Twine &amp;newLeafSuffix)</td></tr>
<tr class="separator:a1834ce0bbea39a5089abc81e496ea685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44fd8ecd88f8e6b80079bf6c1328412a" id="r_a44fd8ecd88f8e6b80079bf6c1328412a"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; ModuleOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a44fd8ecd88f8e6b80079bf6c1328412a">getRootModule</a> (Operation *<a class="el" href="_l_i_c_e_n_s_e_8txt.html#aaf8226a059307a1b18aac1295b5cf3a2">from</a>)</td></tr>
<tr class="separator:a44fd8ecd88f8e6b80079bf6c1328412a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17e5f2ed35eb7b924e98864bc950b296" id="r_a17e5f2ed35eb7b924e98864bc950b296"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; SymbolRefAttr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a17e5f2ed35eb7b924e98864bc950b296">getPathFromRoot</a> (<a class="el" href="classllzk_1_1component_1_1_struct_def_op.html">StructDefOp</a> &amp;to)</td></tr>
<tr class="separator:a17e5f2ed35eb7b924e98864bc950b296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab257f68cb79cff1e1f3f992a3cd86168" id="r_ab257f68cb79cff1e1f3f992a3cd86168"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; SymbolRefAttr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab257f68cb79cff1e1f3f992a3cd86168">getPathFromRoot</a> (<a class="el" href="classllzk_1_1function_1_1_func_def_op.html">FuncDefOp</a> &amp;to)</td></tr>
<tr class="separator:ab257f68cb79cff1e1f3f992a3cd86168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a858ad75166540367bf85ae38bc875707" id="r_a858ad75166540367bf85ae38bc875707"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; ModuleOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a858ad75166540367bf85ae38bc875707">getTopRootModule</a> (Operation *<a class="el" href="_l_i_c_e_n_s_e_8txt.html#aaf8226a059307a1b18aac1295b5cf3a2">from</a>)</td></tr>
<tr class="separator:a858ad75166540367bf85ae38bc875707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75fdc2fe83e3eca6b6c048deac2b22ab" id="r_a75fdc2fe83e3eca6b6c048deac2b22ab"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; SymbolRefAttr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a75fdc2fe83e3eca6b6c048deac2b22ab">getPathFromTopRoot</a> (<a class="el" href="classllzk_1_1component_1_1_struct_def_op.html">StructDefOp</a> &amp;to)</td></tr>
<tr class="separator:a75fdc2fe83e3eca6b6c048deac2b22ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ad8587acfbc58f9dd98165996cce8c7" id="r_a9ad8587acfbc58f9dd98165996cce8c7"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; SymbolRefAttr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ad8587acfbc58f9dd98165996cce8c7">getPathFromTopRoot</a> (<a class="el" href="classllzk_1_1function_1_1_func_def_op.html">FuncDefOp</a> &amp;to)</td></tr>
<tr class="separator:a9ad8587acfbc58f9dd98165996cce8c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cb8dbb7c515a29aa35b18fb74516a42" id="r_a2cb8dbb7c515a29aa35b18fb74516a42"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2cb8dbb7c515a29aa35b18fb74516a42">hasUsesWithin</a> (Operation *symbol, Operation *<a class="el" href="_l_i_c_e_n_s_e_8txt.html#aaf8226a059307a1b18aac1295b5cf3a2">from</a>)</td></tr>
<tr class="separator:a2cb8dbb7c515a29aa35b18fb74516a42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb5ab0e54d49d74723127a7315e8ba22" id="r_adb5ab0e54d49d74723127a7315e8ba22"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb5ab0e54d49d74723127a7315e8ba22">verifyParamOfType</a> (SymbolTableCollection &amp;tables, SymbolRefAttr param, Type parameterizedType, Operation *origin)</td></tr>
<tr class="separator:adb5ab0e54d49d74723127a7315e8ba22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa90d2946d0210b5c3be6279175cf786" id="r_aaa90d2946d0210b5c3be6279175cf786"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa90d2946d0210b5c3be6279175cf786">verifyParamsOfType</a> (SymbolTableCollection &amp;tables, ArrayRef&lt; Attribute &gt; tyParams, Type parameterizedType, Operation *origin)</td></tr>
<tr class="separator:aaa90d2946d0210b5c3be6279175cf786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75f8539d20e1d1066b30e5b8d15b0546" id="r_a75f8539d20e1d1066b30e5b8d15b0546"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classllzk_1_1component_1_1_struct_def_op.html">StructDefOp</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a75f8539d20e1d1066b30e5b8d15b0546">verifyStructTypeResolution</a> (SymbolTableCollection &amp;tables, <a class="el" href="classllzk_1_1component_1_1_struct_type.html">StructType</a> ty, Operation *origin)</td></tr>
<tr class="separator:a75f8539d20e1d1066b30e5b8d15b0546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a20668e5af9ce080f868692b9d199a6" id="r_a8a20668e5af9ce080f868692b9d199a6"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8a20668e5af9ce080f868692b9d199a6">verifyTypeResolution</a> (SymbolTableCollection &amp;tables, Operation *origin, Type ty)</td></tr>
<tr class="separator:a8a20668e5af9ce080f868692b9d199a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bdf8232394377a0c78dbd67d63d6764" id="r_a8bdf8232394377a0c78dbd67d63d6764"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8bdf8232394377a0c78dbd67d63d6764">isValidType</a> (Type type)</td></tr>
<tr class="separator:a8bdf8232394377a0c78dbd67d63d6764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f47b3b9d1f45f35599782a8abaae2c4" id="r_a4f47b3b9d1f45f35599782a8abaae2c4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4f47b3b9d1f45f35599782a8abaae2c4">isValidColumnType</a> (Type type, SymbolTableCollection &amp;symbolTable, Operation *op)</td></tr>
<tr class="separator:a4f47b3b9d1f45f35599782a8abaae2c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d9318e202b0ec0c363d3183734e5b6a" id="r_a3d9318e202b0ec0c363d3183734e5b6a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d9318e202b0ec0c363d3183734e5b6a">isValidGlobalType</a> (Type type)</td></tr>
<tr class="separator:a3d9318e202b0ec0c363d3183734e5b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c0cb033d657913808724b49659466d8" id="r_a7c0cb033d657913808724b49659466d8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c0cb033d657913808724b49659466d8">isValidEmitEqType</a> (Type type)</td></tr>
<tr class="separator:a7c0cb033d657913808724b49659466d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdc6a963256e586da485479d34e385dc" id="r_afdc6a963256e586da485479d34e385dc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afdc6a963256e586da485479d34e385dc">isValidConstReadType</a> (Type type)</td></tr>
<tr class="separator:afdc6a963256e586da485479d34e385dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2de2a95f4fd67e14caa528a032aa00a3" id="r_a2de2a95f4fd67e14caa528a032aa00a3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2de2a95f4fd67e14caa528a032aa00a3">isValidArrayElemType</a> (Type type)</td></tr>
<tr class="separator:a2de2a95f4fd67e14caa528a032aa00a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23b1909ae78d62ab7d8906197c2f486b" id="r_a23b1909ae78d62ab7d8906197c2f486b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a23b1909ae78d62ab7d8906197c2f486b">isValidArrayType</a> (Type type)</td></tr>
<tr class="separator:a23b1909ae78d62ab7d8906197c2f486b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bbb039982f4d0a01e53f8901fdaa34d" id="r_a2bbb039982f4d0a01e53f8901fdaa34d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2bbb039982f4d0a01e53f8901fdaa34d">isConcreteType</a> (Type type, bool allowStructParams)</td></tr>
<tr class="separator:a2bbb039982f4d0a01e53f8901fdaa34d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf9dbea063159b9e1d23597d7854f224" id="r_aaf9dbea063159b9e1d23597d7854f224"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf9dbea063159b9e1d23597d7854f224">isSignalType</a> (Type type)</td></tr>
<tr class="separator:aaf9dbea063159b9e1d23597d7854f224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae51f2b772ad6edd299f653e76d7deb33" id="r_ae51f2b772ad6edd299f653e76d7deb33"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae51f2b772ad6edd299f653e76d7deb33">isSignalType</a> (<a class="el" href="classllzk_1_1component_1_1_struct_type.html">component::StructType</a> sType)</td></tr>
<tr class="memdesc:ae51f2b772ad6edd299f653e76d7deb33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> iff the given <a class="el" href="classllzk_1_1component_1_1_struct_type.html">StructType</a> is referencing the <code>COMPONENT_NAME_SIGNAL</code> struct.  <br /></td></tr>
<tr class="separator:ae51f2b772ad6edd299f653e76d7deb33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae16625d8c85094fae24fb003012b2380" id="r_ae16625d8c85094fae24fb003012b2380"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae16625d8c85094fae24fb003012b2380">hasAffineMapAttr</a> (Type type)</td></tr>
<tr class="separator:ae16625d8c85094fae24fb003012b2380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac04ef36bb784819019624d62b493ce6" id="r_aac04ef36bb784819019624d62b493ce6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac04ef36bb784819019624d62b493ce6">isDynamic</a> (IntegerAttr intAttr)</td></tr>
<tr class="separator:aac04ef36bb784819019624d62b493ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0200f46aeb61d24a1630b2eebf0abe7" id="r_ac0200f46aeb61d24a1630b2eebf0abe7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac0200f46aeb61d24a1630b2eebf0abe7">typeParamsUnify</a> (const ArrayRef&lt; Attribute &gt; &amp;lhsParams, const ArrayRef&lt; Attribute &gt; &amp;rhsParams, <a class="el" href="#a513acdd19d4296f6623ca75ed5eeb904">UnificationMap</a> *unifications)</td></tr>
<tr class="separator:ac0200f46aeb61d24a1630b2eebf0abe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65be8a8027f956741851720ef5047350" id="r_a65be8a8027f956741851720ef5047350"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a65be8a8027f956741851720ef5047350">typeParamsUnify</a> (const ArrayAttr &amp;lhsParams, const ArrayAttr &amp;rhsParams, <a class="el" href="#a513acdd19d4296f6623ca75ed5eeb904">UnificationMap</a> *unifications)</td></tr>
<tr class="memdesc:a65be8a8027f956741851720ef5047350"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> iff the two ArrayAttr instances containing <a class="el" href="classllzk_1_1component_1_1_struct_type.html">StructType</a> or <a class="el" href="classllzk_1_1array_1_1_array_type.html">ArrayType</a> parameters are equivalent or could be equivalent after full instantiation of struct parameters.  <br /></td></tr>
<tr class="separator:a65be8a8027f956741851720ef5047350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bdd2635c665c9a009596b32ceeeafec" id="r_a9bdd2635c665c9a009596b32ceeeafec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9bdd2635c665c9a009596b32ceeeafec">arrayTypesUnify</a> (<a class="el" href="classllzk_1_1array_1_1_array_type.html">ArrayType</a> lhs, <a class="el" href="classllzk_1_1array_1_1_array_type.html">ArrayType</a> rhs, ArrayRef&lt; StringRef &gt; rhsReversePrefix, <a class="el" href="#a513acdd19d4296f6623ca75ed5eeb904">UnificationMap</a> *unifications)</td></tr>
<tr class="separator:a9bdd2635c665c9a009596b32ceeeafec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a449db750fee6d61e2ec3aa36a969d483" id="r_a449db750fee6d61e2ec3aa36a969d483"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a449db750fee6d61e2ec3aa36a969d483">structTypesUnify</a> (<a class="el" href="classllzk_1_1component_1_1_struct_type.html">StructType</a> lhs, <a class="el" href="classllzk_1_1component_1_1_struct_type.html">StructType</a> rhs, ArrayRef&lt; StringRef &gt; rhsReversePrefix, <a class="el" href="#a513acdd19d4296f6623ca75ed5eeb904">UnificationMap</a> *unifications)</td></tr>
<tr class="separator:a449db750fee6d61e2ec3aa36a969d483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc5c6fc1f85b22d1d6e46755e5da1626" id="r_abc5c6fc1f85b22d1d6e46755e5da1626"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc5c6fc1f85b22d1d6e46755e5da1626">typesUnify</a> (Type lhs, Type rhs, ArrayRef&lt; StringRef &gt; rhsReversePrefix, <a class="el" href="#a513acdd19d4296f6623ca75ed5eeb904">UnificationMap</a> *unifications)</td></tr>
<tr class="separator:abc5c6fc1f85b22d1d6e46755e5da1626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac69242a61e4e25958e9c6e8fa0f8549e" id="r_ac69242a61e4e25958e9c6e8fa0f8549e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac69242a61e4e25958e9c6e8fa0f8549e">isMoreConcreteUnification</a> (Type oldTy, Type newTy, llvm::function_ref&lt; bool(Type oldTy, Type newTy)&gt; knownOldToNew)</td></tr>
<tr class="separator:ac69242a61e4e25958e9c6e8fa0f8549e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae04cf4a8e665a844e816c29283f31633" id="r_ae04cf4a8e665a844e816c29283f31633"><td class="memItemLeft" align="right" valign="top">IntegerAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae04cf4a8e665a844e816c29283f31633">forceIntType</a> (IntegerAttr attr)</td></tr>
<tr class="separator:ae04cf4a8e665a844e816c29283f31633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad905c6fd289dd14f402fd8869e19eaa5" id="r_ad905c6fd289dd14f402fd8869e19eaa5"><td class="memItemLeft" align="right" valign="top">Attribute&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad905c6fd289dd14f402fd8869e19eaa5">forceIntAttrType</a> (Attribute attr)</td></tr>
<tr class="separator:ad905c6fd289dd14f402fd8869e19eaa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45a9b85ac8a1f42ff830be63be64e36a" id="r_a45a9b85ac8a1f42ff830be63be64e36a"><td class="memItemLeft" align="right" valign="top">SmallVector&lt; Attribute &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45a9b85ac8a1f42ff830be63be64e36a">forceIntAttrTypes</a> (ArrayRef&lt; Attribute &gt; attrList)</td></tr>
<tr class="separator:a45a9b85ac8a1f42ff830be63be64e36a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26ae160de4660dc25c69d9461f065d84" id="r_a26ae160de4660dc25c69d9461f065d84"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a26ae160de4660dc25c69d9461f065d84">verifyIntAttrType</a> (<a class="el" href="#a36a2156534c7f7ae6aadbf0d8d8fa869">EmitErrorFn</a> emitError, Attribute in)</td></tr>
<tr class="separator:a26ae160de4660dc25c69d9461f065d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a016f3b59595b34b00f2b01667467aa06" id="r_a016f3b59595b34b00f2b01667467aa06"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a016f3b59595b34b00f2b01667467aa06">verifyAffineMapAttrType</a> (<a class="el" href="#a36a2156534c7f7ae6aadbf0d8d8fa869">EmitErrorFn</a> emitError, Attribute in)</td></tr>
<tr class="separator:a016f3b59595b34b00f2b01667467aa06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acea511d0810d60bdecf9d7f1e0779d8e" id="r_acea511d0810d60bdecf9d7f1e0779d8e"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acea511d0810d60bdecf9d7f1e0779d8e">verifyStructTypeParams</a> (<a class="el" href="#a36a2156534c7f7ae6aadbf0d8d8fa869">EmitErrorFn</a> emitError, ArrayAttr params)</td></tr>
<tr class="separator:acea511d0810d60bdecf9d7f1e0779d8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe6df124d315ea4af67d41601225b1a2" id="r_afe6df124d315ea4af67d41601225b1a2"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe6df124d315ea4af67d41601225b1a2">verifyArrayDimSizes</a> (<a class="el" href="#a36a2156534c7f7ae6aadbf0d8d8fa869">EmitErrorFn</a> emitError, ArrayRef&lt; Attribute &gt; dimensionSizes)</td></tr>
<tr class="separator:afe6df124d315ea4af67d41601225b1a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a499aa56be86c2cdb1852b4a402a0913a" id="r_a499aa56be86c2cdb1852b4a402a0913a"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a499aa56be86c2cdb1852b4a402a0913a">verifyArrayType</a> (<a class="el" href="#a36a2156534c7f7ae6aadbf0d8d8fa869">EmitErrorFn</a> emitError, Type elementType, ArrayRef&lt; Attribute &gt; dimensionSizes)</td></tr>
<tr class="separator:a499aa56be86c2cdb1852b4a402a0913a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06f8a74431f12f0298cc7033691f84ec" id="r_a06f8a74431f12f0298cc7033691f84ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06f8a74431f12f0298cc7033691f84ec">assertValidAttrForParamOfType</a> (Attribute attr)</td></tr>
<tr class="separator:a06f8a74431f12f0298cc7033691f84ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70f1f25bfaea0554bef926a549b1ccfd" id="r_a70f1f25bfaea0554bef926a549b1ccfd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a70f1f25bfaea0554bef926a549b1ccfd">registerCallGraphPrinterPass</a> ()</td></tr>
<tr class="separator:a70f1f25bfaea0554bef926a549b1ccfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9accc3ce245c0f1d83ec1756bdfddc7f" id="r_a9accc3ce245c0f1d83ec1756bdfddc7f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9accc3ce245c0f1d83ec1756bdfddc7f">registerCallGraphPrinterPassPass</a> ()</td></tr>
<tr class="separator:a9accc3ce245c0f1d83ec1756bdfddc7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca3ef4b6dafde7897328fef510a09e88" id="r_aca3ef4b6dafde7897328fef510a09e88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aca3ef4b6dafde7897328fef510a09e88">registerCallGraphSCCsPrinterPass</a> ()</td></tr>
<tr class="separator:aca3ef4b6dafde7897328fef510a09e88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef3801b45287da2cbf5224856fe9e58e" id="r_aef3801b45287da2cbf5224856fe9e58e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef3801b45287da2cbf5224856fe9e58e">registerCallGraphSCCsPrinterPassPass</a> ()</td></tr>
<tr class="separator:aef3801b45287da2cbf5224856fe9e58e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a735e5a39ff84a93ee3553979ad00635a" id="r_a735e5a39ff84a93ee3553979ad00635a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a735e5a39ff84a93ee3553979ad00635a">registerConstraintDependencyGraphPrinterPass</a> ()</td></tr>
<tr class="separator:a735e5a39ff84a93ee3553979ad00635a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1c6668dc1a3a4c1a2b856902a3895b0" id="r_ae1c6668dc1a3a4c1a2b856902a3895b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae1c6668dc1a3a4c1a2b856902a3895b0">registerConstraintDependencyGraphPrinterPassPass</a> ()</td></tr>
<tr class="separator:ae1c6668dc1a3a4c1a2b856902a3895b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b30dc7eea52369c92554639f9d6d73a" id="r_a4b30dc7eea52369c92554639f9d6d73a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b30dc7eea52369c92554639f9d6d73a">registerIntervalAnalysisPrinterPass</a> ()</td></tr>
<tr class="separator:a4b30dc7eea52369c92554639f9d6d73a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24c05e5e1e07f0776bcf51b8f08de546" id="r_a24c05e5e1e07f0776bcf51b8f08de546"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a24c05e5e1e07f0776bcf51b8f08de546">registerIntervalAnalysisPrinterPassPass</a> ()</td></tr>
<tr class="separator:a24c05e5e1e07f0776bcf51b8f08de546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5b5ce918cd1f943f8e9c470d968b25c" id="r_af5b5ce918cd1f943f8e9c470d968b25c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5b5ce918cd1f943f8e9c470d968b25c">registerAnalysisPasses</a> ()</td></tr>
<tr class="separator:af5b5ce918cd1f943f8e9c470d968b25c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39859e51fc665588ce50b49754e871cd" id="r_a39859e51fc665588ce50b49754e871cd"><td class="memItemLeft" align="right" valign="top">llvm::APInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a39859e51fc665588ce50b49754e871cd">toAPInt</a> (int64_t i)</td></tr>
<tr class="separator:a39859e51fc665588ce50b49754e871cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2cda245bd6615365454ebd762a24d29" id="r_ae2cda245bd6615365454ebd762a24d29"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2cda245bd6615365454ebd762a24d29">fromAPInt</a> (llvm::APInt i)</td></tr>
<tr class="separator:ae2cda245bd6615365454ebd762a24d29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a58995f554b579f9f32b1454376fa38" id="r_a5a58995f554b579f9f32b1454376fa38"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a58995f554b579f9f32b1454376fa38">isNullOrEmpty</a> (mlir::ArrayAttr a)</td></tr>
<tr class="separator:a5a58995f554b579f9f32b1454376fa38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89cd221cd3a7abc89c253af02c81538e" id="r_a89cd221cd3a7abc89c253af02c81538e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a89cd221cd3a7abc89c253af02c81538e">isNullOrEmpty</a> (mlir::DenseArrayAttr a)</td></tr>
<tr class="separator:a89cd221cd3a7abc89c253af02c81538e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a080b2e46f6958963ba7d1ff00b26fbc4" id="r_a080b2e46f6958963ba7d1ff00b26fbc4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a080b2e46f6958963ba7d1ff00b26fbc4">isNullOrEmpty</a> (mlir::DictionaryAttr a)</td></tr>
<tr class="separator:a080b2e46f6958963ba7d1ff00b26fbc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad54f2cf52138ae6282775a72362a7445" id="r_ad54f2cf52138ae6282775a72362a7445"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad54f2cf52138ae6282775a72362a7445">appendWithoutType</a> (mlir::raw_ostream &amp;os, mlir::Attribute a)</td></tr>
<tr class="separator:ad54f2cf52138ae6282775a72362a7445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53fd11575f45740ca49d163fff8c925e" id="r_a53fd11575f45740ca49d163fff8c925e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a53fd11575f45740ca49d163fff8c925e">stringWithoutType</a> (mlir::Attribute a)</td></tr>
<tr class="separator:a53fd11575f45740ca49d163fff8c925e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3aea79f1ec3c694d5d0bcf1f949c5fe" id="r_ab3aea79f1ec3c694d5d0bcf1f949c5fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3aea79f1ec3c694d5d0bcf1f949c5fe">printAttrs</a> (mlir::AsmPrinter &amp;printer, mlir::ArrayRef&lt; mlir::Attribute &gt; attrs, const mlir::StringRef &amp;separator)</td></tr>
<tr class="separator:ab3aea79f1ec3c694d5d0bcf1f949c5fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af218387a3d9b9824ec5b1d060d4989ea" id="r_af218387a3d9b9824ec5b1d060d4989ea"><td class="memItemLeft" align="right" valign="top">mlir::Location&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af218387a3d9b9824ec5b1d060d4989ea">getUnknownLoc</a> (mlir::MLIRContext *context)</td></tr>
<tr class="separator:af218387a3d9b9824ec5b1d060d4989ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fca8161d33010dac2a613d7ff184db2" id="r_a5fca8161d33010dac2a613d7ff184db2"><td class="memItemLeft" align="right" valign="top">mlir::OwningOpRef&lt; mlir::ModuleOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5fca8161d33010dac2a613d7ff184db2">createLLZKModule</a> (mlir::MLIRContext *context, mlir::Location loc)</td></tr>
<tr class="separator:a5fca8161d33010dac2a613d7ff184db2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24a8f8d60a445812f3792f04b6420f5c" id="r_a24a8f8d60a445812f3792f04b6420f5c"><td class="memItemLeft" align="right" valign="top">mlir::OwningOpRef&lt; mlir::ModuleOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a24a8f8d60a445812f3792f04b6420f5c">createLLZKModule</a> (mlir::MLIRContext *context)</td></tr>
<tr class="separator:a24a8f8d60a445812f3792f04b6420f5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace40014709812c1c57cb0aa39b87558b" id="r_ace40014709812c1c57cb0aa39b87558b"><td class="memTemplParams" colspan="2">template&lt;typename OpType&gt; </td></tr>
<tr class="memitem:ace40014709812c1c57cb0aa39b87558b"><td class="memTemplItemLeft" align="right" valign="top">llvm::StringLiteral&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ace40014709812c1c57cb0aa39b87558b">getOperationName</a> ()</td></tr>
<tr class="memdesc:ace40014709812c1c57cb0aa39b87558b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the operation name, like "constrain.eq" for the given OpType.  <br /></td></tr>
<tr class="separator:ace40014709812c1c57cb0aa39b87558b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae01374002b3f4f48046cccee2a7087e4" id="r_ae01374002b3f4f48046cccee2a7087e4"><td class="memTemplParams" colspan="2">template&lt;typename OpType&gt; </td></tr>
<tr class="memitem:ae01374002b3f4f48046cccee2a7087e4"><td class="memTemplItemLeft" align="right" valign="top">mlir::FailureOr&lt; OpType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae01374002b3f4f48046cccee2a7087e4">getParentOfType</a> (mlir::Operation *op)</td></tr>
<tr class="memdesc:ae01374002b3f4f48046cccee2a7087e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the closest surrounding parent operation that is of type 'OpType'.  <br /></td></tr>
<tr class="separator:ae01374002b3f4f48046cccee2a7087e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5a2121be9e3d0627cae5e297852772b" id="r_ad5a2121be9e3d0627cae5e297852772b"><td class="memTemplParams" colspan="2">template&lt;unsigned N&gt; </td></tr>
<tr class="memitem:ad5a2121be9e3d0627cae5e297852772b"><td class="memTemplItemLeft" align="right" valign="top">mlir::ParseResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad5a2121be9e3d0627cae5e297852772b">parseDimAndSymbolList</a> (mlir::OpAsmParser &amp;parser, mlir::SmallVector&lt; mlir::OpAsmParser::UnresolvedOperand, N &gt; &amp;mapOperands, mlir::IntegerAttr &amp;numDims)</td></tr>
<tr class="separator:ad5a2121be9e3d0627cae5e297852772b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a467753751f4011cd7f8e3e628748b92c" id="r_a467753751f4011cd7f8e3e628748b92c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a467753751f4011cd7f8e3e628748b92c">printDimAndSymbolList</a> (mlir::OpAsmPrinter &amp;printer, mlir::Operation *op, mlir::OperandRange mapOperands, mlir::IntegerAttr numDims)</td></tr>
<tr class="separator:a467753751f4011cd7f8e3e628748b92c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb80626795a01a586c626bb1cb366a6d" id="r_acb80626795a01a586c626bb1cb366a6d"><td class="memItemLeft" align="right" valign="top">mlir::ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb80626795a01a586c626bb1cb366a6d">parseMultiDimAndSymbolList</a> (mlir::OpAsmParser &amp;parser, mlir::SmallVector&lt; mlir::SmallVector&lt; mlir::OpAsmParser::UnresolvedOperand &gt; &gt; &amp;multiMapOperands, mlir::DenseI32ArrayAttr &amp;numDimsPerMap)</td></tr>
<tr class="separator:acb80626795a01a586c626bb1cb366a6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9eb2d93ae702c8d8e1d2164e77f52e8" id="r_aa9eb2d93ae702c8d8e1d2164e77f52e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa9eb2d93ae702c8d8e1d2164e77f52e8">printMultiDimAndSymbolList</a> (mlir::OpAsmPrinter &amp;printer, mlir::Operation *op, mlir::OperandRangeRange multiMapOperands, mlir::DenseI32ArrayAttr numDimsPerMap)</td></tr>
<tr class="separator:aa9eb2d93ae702c8d8e1d2164e77f52e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f3fe746926910eac20e7c7eeee63e3a" id="r_a6f3fe746926910eac20e7c7eeee63e3a"><td class="memItemLeft" align="right" valign="top">mlir::ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f3fe746926910eac20e7c7eeee63e3a">parseAttrDictWithWarnings</a> (mlir::OpAsmParser &amp;parser, mlir::NamedAttrList &amp;extraAttrs, mlir::OperationState &amp;state)</td></tr>
<tr class="separator:a6f3fe746926910eac20e7c7eeee63e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafb94145f42dd37435e37c9ce4b805a2" id="r_aafb94145f42dd37435e37c9ce4b805a2"><td class="memTemplParams" colspan="2">template&lt;typename ConcreteOp&gt; </td></tr>
<tr class="memitem:aafb94145f42dd37435e37c9ce4b805a2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aafb94145f42dd37435e37c9ce4b805a2">printAttrDictWithWarnings</a> (mlir::OpAsmPrinter &amp;printer, ConcreteOp op, mlir::DictionaryAttr extraAttrs, typename mlir::PropertiesSelector&lt; ConcreteOp &gt;::type state)</td></tr>
<tr class="separator:aafb94145f42dd37435e37c9ce4b805a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b23872eceb03786a0fc287ba896044b" id="r_a4b23872eceb03786a0fc287ba896044b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; mlir::Pass &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b23872eceb03786a0fc287ba896044b">createFlatteningPass</a> ()</td></tr>
<tr class="separator:a4b23872eceb03786a0fc287ba896044b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a764713f7354a0b4b2cf1b861a443136e" id="r_a764713f7354a0b4b2cf1b861a443136e"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; mlir::Pass &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a764713f7354a0b4b2cf1b861a443136e">createRedundantReadAndWriteEliminationPass</a> ()</td></tr>
<tr class="separator:a764713f7354a0b4b2cf1b861a443136e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02ed7b620ceb2def986e01d65617d3d4" id="r_a02ed7b620ceb2def986e01d65617d3d4"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; mlir::Pass &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a02ed7b620ceb2def986e01d65617d3d4">createRedundantOperationEliminationPass</a> ()</td></tr>
<tr class="separator:a02ed7b620ceb2def986e01d65617d3d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa81a4cdbc9130d5a1f71367fdc225ef2" id="r_aa81a4cdbc9130d5a1f71367fdc225ef2"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; mlir::Pass &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa81a4cdbc9130d5a1f71367fdc225ef2">createUnusedDeclarationEliminationPass</a> ()</td></tr>
<tr class="separator:aa81a4cdbc9130d5a1f71367fdc225ef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab494edb15dac73bb877f74a9378eab8" id="r_aab494edb15dac73bb877f74a9378eab8"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; mlir::Pass &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab494edb15dac73bb877f74a9378eab8">createArrayToScalarPass</a> ()</td></tr>
<tr class="separator:aab494edb15dac73bb877f74a9378eab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b420046418c6c1e1d5df513bf68e75" id="r_a52b420046418c6c1e1d5df513bf68e75"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52b420046418c6c1e1d5df513bf68e75">registerRedundantOperationEliminationPass</a> ()</td></tr>
<tr class="separator:a52b420046418c6c1e1d5df513bf68e75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a742cb6ba67d34d1866a3befa40e7262d" id="r_a742cb6ba67d34d1866a3befa40e7262d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a742cb6ba67d34d1866a3befa40e7262d">registerRedundantOperationEliminationPassPass</a> ()</td></tr>
<tr class="separator:a742cb6ba67d34d1866a3befa40e7262d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab402712606c35b8b57e3eb077a45e3d0" id="r_ab402712606c35b8b57e3eb077a45e3d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab402712606c35b8b57e3eb077a45e3d0">registerRedundantReadAndWriteEliminationPass</a> ()</td></tr>
<tr class="separator:ab402712606c35b8b57e3eb077a45e3d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8d4d99847c9d1dfc61349e39b132673" id="r_ac8d4d99847c9d1dfc61349e39b132673"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac8d4d99847c9d1dfc61349e39b132673">registerRedundantReadAndWriteEliminationPassPass</a> ()</td></tr>
<tr class="separator:ac8d4d99847c9d1dfc61349e39b132673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bfb781c85fcdfda09d0472c2ede1e29" id="r_a5bfb781c85fcdfda09d0472c2ede1e29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5bfb781c85fcdfda09d0472c2ede1e29">registerUnusedDeclarationEliminationPass</a> ()</td></tr>
<tr class="separator:a5bfb781c85fcdfda09d0472c2ede1e29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00a1db9f2cbc20b8b1ef3010ea7c97a5" id="r_a00a1db9f2cbc20b8b1ef3010ea7c97a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a00a1db9f2cbc20b8b1ef3010ea7c97a5">registerUnusedDeclarationEliminationPassPass</a> ()</td></tr>
<tr class="separator:a00a1db9f2cbc20b8b1ef3010ea7c97a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79f7a98b4670512b82df5098ca84e99e" id="r_a79f7a98b4670512b82df5098ca84e99e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a79f7a98b4670512b82df5098ca84e99e">registerTransformationPasses</a> ()</td></tr>
<tr class="separator:a79f7a98b4670512b82df5098ca84e99e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa089f0e4ab428c808e92c51fdc4e34c7" id="r_aa089f0e4ab428c808e92c51fdc4e34c7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa089f0e4ab428c808e92c51fdc4e34c7">safeLt</a> (const llvm::APSInt &amp;lhs, const llvm::APSInt &amp;rhs)</td></tr>
<tr class="separator:aa089f0e4ab428c808e92c51fdc4e34c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0bddd3e2491900b24bdd5691fd50879" id="r_ab0bddd3e2491900b24bdd5691fd50879"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab0bddd3e2491900b24bdd5691fd50879">safeLe</a> (const llvm::APSInt &amp;lhs, const llvm::APSInt &amp;rhs)</td></tr>
<tr class="separator:ab0bddd3e2491900b24bdd5691fd50879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94a1e3bcf698c899bfc06acbf41889ab" id="r_a94a1e3bcf698c899bfc06acbf41889ab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a94a1e3bcf698c899bfc06acbf41889ab">safeEq</a> (const llvm::APSInt &amp;lhs, const llvm::APSInt &amp;rhs)</td></tr>
<tr class="separator:a94a1e3bcf698c899bfc06acbf41889ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac29ce8caf9a069ea6b93d13876c98ed9" id="r_ac29ce8caf9a069ea6b93d13876c98ed9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac29ce8caf9a069ea6b93d13876c98ed9">safeNe</a> (const llvm::APSInt &amp;lhs, const llvm::APSInt &amp;rhs)</td></tr>
<tr class="separator:ac29ce8caf9a069ea6b93d13876c98ed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a932b4bf35161df2293fdc0d96a01f948" id="r_a932b4bf35161df2293fdc0d96a01f948"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a932b4bf35161df2293fdc0d96a01f948">safeGt</a> (const llvm::APSInt &amp;lhs, const llvm::APSInt &amp;rhs)</td></tr>
<tr class="separator:a932b4bf35161df2293fdc0d96a01f948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd6d805f7abef8f9d78cc69913697014" id="r_acd6d805f7abef8f9d78cc69913697014"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd6d805f7abef8f9d78cc69913697014">safeGe</a> (const llvm::APSInt &amp;lhs, const llvm::APSInt &amp;rhs)</td></tr>
<tr class="separator:acd6d805f7abef8f9d78cc69913697014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9c220e19757e93c8a5a42c87224763c" id="r_ae9c220e19757e93c8a5a42c87224763c"><td class="memItemLeft" align="right" valign="top">llvm::APSInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9c220e19757e93c8a5a42c87224763c">safeMin</a> (const llvm::APSInt &amp;lhs, const llvm::APSInt &amp;rhs)</td></tr>
<tr class="separator:ae9c220e19757e93c8a5a42c87224763c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50400df1f01c51207bdb8ec48544cd8f" id="r_a50400df1f01c51207bdb8ec48544cd8f"><td class="memItemLeft" align="right" valign="top">llvm::APSInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a50400df1f01c51207bdb8ec48544cd8f">safeMin</a> (std::initializer_list&lt; llvm::APSInt &gt; ilist)</td></tr>
<tr class="separator:a50400df1f01c51207bdb8ec48544cd8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f8ce5c145a392aa5c382d2c9930cc22" id="r_a4f8ce5c145a392aa5c382d2c9930cc22"><td class="memItemLeft" align="right" valign="top">llvm::APSInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4f8ce5c145a392aa5c382d2c9930cc22">safeMax</a> (const llvm::APSInt &amp;lhs, const llvm::APSInt &amp;rhs)</td></tr>
<tr class="separator:a4f8ce5c145a392aa5c382d2c9930cc22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae144a51e20e007a607c11a19a19ba736" id="r_ae144a51e20e007a607c11a19a19ba736"><td class="memItemLeft" align="right" valign="top">llvm::APSInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae144a51e20e007a607c11a19a19ba736">safeMax</a> (std::initializer_list&lt; llvm::APSInt &gt; ilist)</td></tr>
<tr class="separator:ae144a51e20e007a607c11a19a19ba736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1340324912450274219eaa15bac66362" id="r_a1340324912450274219eaa15bac66362"><td class="memTemplParams" colspan="2">template&lt;typename OpType, typename... Args&gt; </td></tr>
<tr class="memitem:a1340324912450274219eaa15bac66362"><td class="memTemplItemLeft" align="right" valign="top">OpType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1340324912450274219eaa15bac66362">delegate_to_build</a> (mlir::Location location, Args &amp;&amp;...args)</td></tr>
<tr class="separator:a1340324912450274219eaa15bac66362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb284386fff71ad94c74a27f050076b8" id="r_afb284386fff71ad94c74a27f050076b8"><td class="memTemplParams" colspan="2">template&lt;OpComparable Op&gt; </td></tr>
<tr class="memitem:afb284386fff71ad94c74a27f050076b8"><td class="memTemplItemLeft" align="right" valign="top">mlir::FailureOr&lt; bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afb284386fff71ad94c74a27f050076b8">isLocationLess</a> (const Op &amp;l, const Op &amp;r)</td></tr>
<tr class="separator:afb284386fff71ad94c74a27f050076b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b8e8dff43891ffe5045760d87d2899b" id="r_a9b8e8dff43891ffe5045760d87d2899b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a7357b1ebd2b125f62a0a2fd3bf559af1">OwningEmitErrorFn</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b8e8dff43891ffe5045760d87d2899b">getEmitOpErrFn</a> (mlir::Operation *op)</td></tr>
<tr class="separator:a9b8e8dff43891ffe5045760d87d2899b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2caf8eb59f64db262f24d563f6a16a0e" id="r_a2caf8eb59f64db262f24d563f6a16a0e"><td class="memTemplParams" colspan="2">template&lt;typename TypeClass&gt; </td></tr>
<tr class="memitem:a2caf8eb59f64db262f24d563f6a16a0e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#a7357b1ebd2b125f62a0a2fd3bf559af1">OwningEmitErrorFn</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2caf8eb59f64db262f24d563f6a16a0e">getEmitOpErrFn</a> (TypeClass *opImpl)</td></tr>
<tr class="separator:a2caf8eb59f64db262f24d563f6a16a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7075ec348ed9ce9776df5b52acb8a1b2" id="r_a7075ec348ed9ce9776df5b52acb8a1b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7075ec348ed9ce9776df5b52acb8a1b2">ensure</a> (bool condition, llvm::Twine errMsg)</td></tr>
<tr class="separator:a7075ec348ed9ce9776df5b52acb8a1b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a4057e4e77ea614edbcee1fba37b30a" id="r_a8a4057e4e77ea614edbcee1fba37b30a"><td class="memItemLeft" align="right" valign="top">llvm::SmallVector&lt; mlir::StringRef &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8a4057e4e77ea614edbcee1fba37b30a">getNames</a> (mlir::SymbolRefAttr ref)</td></tr>
<tr class="separator:a8a4057e4e77ea614edbcee1fba37b30a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e5122183c36be89ee3a9b8df87b5223" id="r_a2e5122183c36be89ee3a9b8df87b5223"><td class="memItemLeft" align="right" valign="top">llvm::SmallVector&lt; mlir::FlatSymbolRefAttr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e5122183c36be89ee3a9b8df87b5223">getPieces</a> (mlir::SymbolRefAttr ref)</td></tr>
<tr class="separator:a2e5122183c36be89ee3a9b8df87b5223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a301a571a8339726388d6173ba81b5283" id="r_a301a571a8339726388d6173ba81b5283"><td class="memItemLeft" align="right" valign="top">mlir::FlatSymbolRefAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a301a571a8339726388d6173ba81b5283">getFlatSymbolRefAttr</a> (mlir::MLIRContext *context, const mlir::Twine &amp;twine)</td></tr>
<tr class="memdesc:a301a571a8339726388d6173ba81b5283"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a FlatSymbolRefAttr with the given content.  <br /></td></tr>
<tr class="separator:a301a571a8339726388d6173ba81b5283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ef6741a40f7e02fc0b94c979c8b3be" id="r_ab1ef6741a40f7e02fc0b94c979c8b3be"><td class="memItemLeft" align="right" valign="top">mlir::SymbolRefAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab1ef6741a40f7e02fc0b94c979c8b3be">asSymbolRefAttr</a> (mlir::StringAttr root, mlir::SymbolRefAttr tail)</td></tr>
<tr class="memdesc:ab1ef6741a40f7e02fc0b94c979c8b3be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a SymbolRefAttr that prepends <code>tail</code> with <code>root</code>, i.e. <code>root::tail</code>.  <br /></td></tr>
<tr class="separator:ab1ef6741a40f7e02fc0b94c979c8b3be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e9f41024dc1c528963ac365b72906b7" id="r_a1e9f41024dc1c528963ac365b72906b7"><td class="memItemLeft" align="right" valign="top">mlir::SymbolRefAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1e9f41024dc1c528963ac365b72906b7">asSymbolRefAttr</a> (llvm::ArrayRef&lt; mlir::FlatSymbolRefAttr &gt; path)</td></tr>
<tr class="memdesc:a1e9f41024dc1c528963ac365b72906b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a SymbolRefAttr from the list of pieces.  <br /></td></tr>
<tr class="separator:a1e9f41024dc1c528963ac365b72906b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16ec473bc15954ac7583672b67388d03" id="r_a16ec473bc15954ac7583672b67388d03"><td class="memItemLeft" align="right" valign="top">mlir::SymbolRefAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a16ec473bc15954ac7583672b67388d03">asSymbolRefAttr</a> (std::vector&lt; mlir::FlatSymbolRefAttr &gt; path)</td></tr>
<tr class="memdesc:a16ec473bc15954ac7583672b67388d03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a SymbolRefAttr from the list of pieces.  <br /></td></tr>
<tr class="separator:a16ec473bc15954ac7583672b67388d03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8be495092bcd4acc4f4064a0e8ee703" id="r_ab8be495092bcd4acc4f4064a0e8ee703"><td class="memItemLeft" align="right" valign="top">mlir::SymbolRefAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab8be495092bcd4acc4f4064a0e8ee703">getTailAsSymbolRefAttr</a> (mlir::SymbolRefAttr symbol)</td></tr>
<tr class="memdesc:ab8be495092bcd4acc4f4064a0e8ee703"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return SymbolRefAttr like the one given but with the root/head element removed.  <br /></td></tr>
<tr class="separator:ab8be495092bcd4acc4f4064a0e8ee703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cc045d4128ed47c170ca4c017bf02f0" id="r_a0cc045d4128ed47c170ca4c017bf02f0"><td class="memItemLeft" align="right" valign="top">mlir::SymbolRefAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0cc045d4128ed47c170ca4c017bf02f0">getPrefixAsSymbolRefAttr</a> (mlir::SymbolRefAttr symbol)</td></tr>
<tr class="memdesc:a0cc045d4128ed47c170ca4c017bf02f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return SymbolRefAttr like the one given but with the leaf/final element removed.  <br /></td></tr>
<tr class="separator:a0cc045d4128ed47c170ca4c017bf02f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8e8b6ec5e855b620cb45245fd9ab92e" id="r_af8e8b6ec5e855b620cb45245fd9ab92e"><td class="memItemLeft" align="right" valign="top">mlir::SymbolRefAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af8e8b6ec5e855b620cb45245fd9ab92e">replaceLeaf</a> (mlir::SymbolRefAttr orig, mlir::FlatSymbolRefAttr newLeaf)</td></tr>
<tr class="memdesc:af8e8b6ec5e855b620cb45245fd9ab92e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return SymbolRefAttr like the one given but with the leaf (final) element replaced.  <br /></td></tr>
<tr class="separator:af8e8b6ec5e855b620cb45245fd9ab92e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a4d8a892b01f7f72b16fe911432e32f" id="r_a4a4d8a892b01f7f72b16fe911432e32f"><td class="memItemLeft" align="right" valign="top">mlir::SymbolRefAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a4d8a892b01f7f72b16fe911432e32f">replaceLeaf</a> (mlir::SymbolRefAttr orig, mlir::StringAttr newLeaf)</td></tr>
<tr class="separator:a4a4d8a892b01f7f72b16fe911432e32f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1971dcef957ffd67e7ee350f8841c34c" id="r_a1971dcef957ffd67e7ee350f8841c34c"><td class="memItemLeft" align="right" valign="top">mlir::SymbolRefAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1971dcef957ffd67e7ee350f8841c34c">replaceLeaf</a> (mlir::SymbolRefAttr orig, const mlir::Twine &amp;newLeaf)</td></tr>
<tr class="separator:a1971dcef957ffd67e7ee350f8841c34c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6782a6db3405d4048a5ffb345f28192" id="r_af6782a6db3405d4048a5ffb345f28192"><td class="memItemLeft" align="right" valign="top">mlir::SymbolRefAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af6782a6db3405d4048a5ffb345f28192">appendLeaf</a> (mlir::SymbolRefAttr orig, mlir::FlatSymbolRefAttr newLeaf)</td></tr>
<tr class="memdesc:af6782a6db3405d4048a5ffb345f28192"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return SymbolRefAttr like the one given but with a new leaf (final) element added.  <br /></td></tr>
<tr class="separator:af6782a6db3405d4048a5ffb345f28192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5d40b8f21a8a58c469d549bb2553c46" id="r_af5d40b8f21a8a58c469d549bb2553c46"><td class="memItemLeft" align="right" valign="top">mlir::SymbolRefAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5d40b8f21a8a58c469d549bb2553c46">appendLeaf</a> (mlir::SymbolRefAttr orig, mlir::StringAttr newLeaf)</td></tr>
<tr class="separator:af5d40b8f21a8a58c469d549bb2553c46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a425f3885d7b5a6ec7fe6f06c5233edae" id="r_a425f3885d7b5a6ec7fe6f06c5233edae"><td class="memItemLeft" align="right" valign="top">mlir::SymbolRefAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a425f3885d7b5a6ec7fe6f06c5233edae">appendLeaf</a> (mlir::SymbolRefAttr orig, const mlir::Twine &amp;newLeaf)</td></tr>
<tr class="separator:a425f3885d7b5a6ec7fe6f06c5233edae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaffefb5eebcbf303a9217ff07df7fb0" id="r_acaffefb5eebcbf303a9217ff07df7fb0"><td class="memItemLeft" align="right" valign="top">mlir::SymbolRefAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acaffefb5eebcbf303a9217ff07df7fb0">appendLeafName</a> (mlir::SymbolRefAttr orig, const mlir::Twine &amp;newLeafSuffix)</td></tr>
<tr class="memdesc:acaffefb5eebcbf303a9217ff07df7fb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return SymbolRefAttr like the one given but with the leaf (final) element appended with the given suffix.  <br /></td></tr>
<tr class="separator:acaffefb5eebcbf303a9217ff07df7fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c6b23d251765a4ab382acebfd6138fd" id="r_a6c6b23d251765a4ab382acebfd6138fd"><td class="memItemLeft" align="right" valign="top">mlir::FailureOr&lt; mlir::ModuleOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c6b23d251765a4ab382acebfd6138fd">getRootModule</a> (mlir::Operation *<a class="el" href="_l_i_c_e_n_s_e_8txt.html#aaf8226a059307a1b18aac1295b5cf3a2">from</a>)</td></tr>
<tr class="separator:a6c6b23d251765a4ab382acebfd6138fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6982559aa99cea04c0cf47ee38166ce2" id="r_a6982559aa99cea04c0cf47ee38166ce2"><td class="memItemLeft" align="right" valign="top">mlir::FailureOr&lt; mlir::ModuleOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6982559aa99cea04c0cf47ee38166ce2">getTopRootModule</a> (mlir::Operation *<a class="el" href="_l_i_c_e_n_s_e_8txt.html#aaf8226a059307a1b18aac1295b5cf3a2">from</a>)</td></tr>
<tr class="memdesc:a6982559aa99cea04c0cf47ee38166ce2"><td class="mdescLeft">&#160;</td><td class="mdescRight">With include statements, there may be root modules nested within other root modules.  <br /></td></tr>
<tr class="separator:a6982559aa99cea04c0cf47ee38166ce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76f6ee502fe0bb6ab1986e1ad9090c77" id="r_a76f6ee502fe0bb6ab1986e1ad9090c77"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a76f6ee502fe0bb6ab1986e1ad9090c77"><td class="memTemplItemLeft" align="right" valign="top">mlir::FailureOr&lt; <a class="el" href="classllzk_1_1_symbol_lookup_result.html">SymbolLookupResult</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a76f6ee502fe0bb6ab1986e1ad9090c77">resolveCallable</a> (mlir::SymbolTableCollection &amp;symbolTable, mlir::CallOpInterface call)</td></tr>
<tr class="memdesc:a76f6ee502fe0bb6ab1986e1ad9090c77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Based on mlir::CallOpInterface::resolveCallable, but using LLZK lookup helpers.  <br /></td></tr>
<tr class="separator:a76f6ee502fe0bb6ab1986e1ad9090c77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a043fe7093faebb4db2da50ae89f82b71" id="r_a043fe7093faebb4db2da50ae89f82b71"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a043fe7093faebb4db2da50ae89f82b71"><td class="memTemplItemLeft" align="right" valign="top">mlir::FailureOr&lt; <a class="el" href="classllzk_1_1_symbol_lookup_result.html">SymbolLookupResult</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a043fe7093faebb4db2da50ae89f82b71">resolveCallable</a> (mlir::CallOpInterface call)</td></tr>
<tr class="separator:a043fe7093faebb4db2da50ae89f82b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ccd56fcf180637d0cdf015d5a1d3350" id="r_a7ccd56fcf180637d0cdf015d5a1d3350"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ccd56fcf180637d0cdf015d5a1d3350">hasUsesWithin</a> (mlir::Operation *symbol, mlir::Operation *<a class="el" href="_l_i_c_e_n_s_e_8txt.html#aaf8226a059307a1b18aac1295b5cf3a2">from</a>)</td></tr>
<tr class="memdesc:a7ccd56fcf180637d0cdf015d5a1d3350"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>SymbolTable::getSymbolUses(...).has_value()</code> but without fully computing uses.  <br /></td></tr>
<tr class="separator:a7ccd56fcf180637d0cdf015d5a1d3350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc811579523974df9a00a8e969ea1ffc" id="r_acc811579523974df9a00a8e969ea1ffc"><td class="memItemLeft" align="right" valign="top">mlir::LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc811579523974df9a00a8e969ea1ffc">verifyParamOfType</a> (mlir::SymbolTableCollection &amp;tables, mlir::SymbolRefAttr param, mlir::Type structOrArrayType, mlir::Operation *origin)</td></tr>
<tr class="memdesc:acc811579523974df9a00a8e969ea1ffc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensure that the given symbol (that is used as a parameter of the given type) can be resolved.  <br /></td></tr>
<tr class="separator:acc811579523974df9a00a8e969ea1ffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad11e39677b93aea53264f2ffcd504f3c" id="r_ad11e39677b93aea53264f2ffcd504f3c"><td class="memItemLeft" align="right" valign="top">mlir::LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad11e39677b93aea53264f2ffcd504f3c">verifyParamsOfType</a> (mlir::SymbolTableCollection &amp;tables, mlir::ArrayRef&lt; mlir::Attribute &gt; tyParams, mlir::Type structOrArrayType, mlir::Operation *origin)</td></tr>
<tr class="memdesc:ad11e39677b93aea53264f2ffcd504f3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensure that any symbols that appear within the given attributes (that are parameters of the given type) can be resolved.  <br /></td></tr>
<tr class="separator:ad11e39677b93aea53264f2ffcd504f3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a440b2851118a528c4cf09f990ae4a5" id="r_a6a440b2851118a528c4cf09f990ae4a5"><td class="memItemLeft" align="right" valign="top">mlir::FailureOr&lt; <a class="el" href="classllzk_1_1component_1_1_struct_def_op.html">component::StructDefOp</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a440b2851118a528c4cf09f990ae4a5">verifyStructTypeResolution</a> (mlir::SymbolTableCollection &amp;tables, <a class="el" href="classllzk_1_1component_1_1_struct_type.html">component::StructType</a> ty, mlir::Operation *origin)</td></tr>
<tr class="memdesc:a6a440b2851118a528c4cf09f990ae4a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensure that all symbols used within the type can be resolved.  <br /></td></tr>
<tr class="separator:a6a440b2851118a528c4cf09f990ae4a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcc40d684f6ca8079665a69cf2866838" id="r_abcc40d684f6ca8079665a69cf2866838"><td class="memItemLeft" align="right" valign="top">mlir::LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abcc40d684f6ca8079665a69cf2866838">verifyTypeResolution</a> (mlir::SymbolTableCollection &amp;tables, mlir::Operation *origin, mlir::Type type)</td></tr>
<tr class="memdesc:abcc40d684f6ca8079665a69cf2866838"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensure that all symbols used within the given Type instance can be resolved.  <br /></td></tr>
<tr class="separator:abcc40d684f6ca8079665a69cf2866838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2361346b0d5cd8b5817a8c8b65ef23e" id="r_aa2361346b0d5cd8b5817a8c8b65ef23e"><td class="memTemplParams" colspan="2">template&lt;std::ranges::input_range Range&gt; </td></tr>
<tr class="memitem:aa2361346b0d5cd8b5817a8c8b65ef23e"><td class="memTemplItemLeft" align="right" valign="top">mlir::LogicalResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa2361346b0d5cd8b5817a8c8b65ef23e">verifyTypeResolution</a> (mlir::SymbolTableCollection &amp;tables, mlir::Operation *origin, const Range &amp;types)</td></tr>
<tr class="memdesc:aa2361346b0d5cd8b5817a8c8b65ef23e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensure that all symbols used within all Type instances can be resolved.  <br /></td></tr>
<tr class="separator:aa2361346b0d5cd8b5817a8c8b65ef23e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa28c2948d69e2d33367e147f19cb29ce" id="r_aa28c2948d69e2d33367e147f19cb29ce"><td class="memItemLeft" align="right" valign="top">mlir::FailureOr&lt; <a class="el" href="classllzk_1_1_symbol_lookup_result_untyped.html">SymbolLookupResultUntyped</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa28c2948d69e2d33367e147f19cb29ce">lookupSymbolIn</a> (mlir::SymbolTableCollection &amp;tables, mlir::SymbolRefAttr symbol, <a class="el" href="classllzk_1_1_within.html">Within</a> &amp;&amp;lookupWithin, mlir::Operation *origin, bool reportMissing=true)</td></tr>
<tr class="separator:aa28c2948d69e2d33367e147f19cb29ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3073035b30825ce363ac236f14fe289a" id="r_a3073035b30825ce363ac236f14fe289a"><td class="memItemLeft" align="right" valign="top">mlir::FailureOr&lt; <a class="el" href="classllzk_1_1_symbol_lookup_result_untyped.html">SymbolLookupResultUntyped</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3073035b30825ce363ac236f14fe289a">lookupTopLevelSymbol</a> (mlir::SymbolTableCollection &amp;tables, mlir::SymbolRefAttr symbol, mlir::Operation *origin, bool reportMissing=true)</td></tr>
<tr class="separator:a3073035b30825ce363ac236f14fe289a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59089c68acbe0a26928537e06040045b" id="r_a59089c68acbe0a26928537e06040045b"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a59089c68acbe0a26928537e06040045b"><td class="memTemplItemLeft" align="right" valign="top">mlir::FailureOr&lt; <a class="el" href="classllzk_1_1_symbol_lookup_result.html">SymbolLookupResult</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a59089c68acbe0a26928537e06040045b">lookupSymbolIn</a> (mlir::SymbolTableCollection &amp;tables, mlir::SymbolRefAttr symbol, <a class="el" href="classllzk_1_1_within.html">Within</a> &amp;&amp;lookupWithin, mlir::Operation *origin)</td></tr>
<tr class="separator:a59089c68acbe0a26928537e06040045b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1815280653e16b67ab239ce1419f8c1c" id="r_a1815280653e16b67ab239ce1419f8c1c"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a1815280653e16b67ab239ce1419f8c1c"><td class="memTemplItemLeft" align="right" valign="top">mlir::FailureOr&lt; <a class="el" href="classllzk_1_1_symbol_lookup_result.html">SymbolLookupResult</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1815280653e16b67ab239ce1419f8c1c">lookupTopLevelSymbol</a> (mlir::SymbolTableCollection &amp;tables, mlir::SymbolRefAttr symbol, mlir::Operation *origin)</td></tr>
<tr class="separator:a1815280653e16b67ab239ce1419f8c1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3840dc2d50d9f0cda122fb59ebaf32ed" id="r_a3840dc2d50d9f0cda122fb59ebaf32ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3840dc2d50d9f0cda122fb59ebaf32ed">assertValidAttrForParamOfType</a> (mlir::Attribute attr)</td></tr>
<tr class="separator:a3840dc2d50d9f0cda122fb59ebaf32ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7d4007c34cbea77abeab21c65e2bd5d" id="r_aa7d4007c34cbea77abeab21c65e2bd5d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa7d4007c34cbea77abeab21c65e2bd5d">isValidType</a> (mlir::Type type)</td></tr>
<tr class="memdesc:aa7d4007c34cbea77abeab21c65e2bd5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">valid types: {I1, Index, String, <a class="el" href="classllzk_1_1felt_1_1_felt_type.html">FeltType</a>, <a class="el" href="classllzk_1_1component_1_1_struct_type.html">StructType</a>, <a class="el" href="classllzk_1_1array_1_1_array_type.html">ArrayType</a>, <a class="el" href="classllzk_1_1polymorphic_1_1_type_var_type.html">TypeVarType</a>}  <br /></td></tr>
<tr class="separator:aa7d4007c34cbea77abeab21c65e2bd5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af816e3b3d950e479f4eccc8ef62237df" id="r_af816e3b3d950e479f4eccc8ef62237df"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af816e3b3d950e479f4eccc8ef62237df">isValidColumnType</a> (mlir::Type type, mlir::SymbolTableCollection &amp;symbolTable, mlir::Operation *op)</td></tr>
<tr class="memdesc:af816e3b3d950e479f4eccc8ef62237df"><td class="mdescLeft">&#160;</td><td class="mdescRight">valid types: {<a class="el" href="classllzk_1_1felt_1_1_felt_type.html">FeltType</a>, <a class="el" href="classllzk_1_1component_1_1_struct_type.html">StructType</a> (with columns), <a class="el" href="classllzk_1_1array_1_1_array_type.html">ArrayType</a> (that contains a valid column type)}  <br /></td></tr>
<tr class="separator:af816e3b3d950e479f4eccc8ef62237df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a952faa929c7417a608f0b0ac17138c5a" id="r_a952faa929c7417a608f0b0ac17138c5a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a952faa929c7417a608f0b0ac17138c5a">isValidGlobalType</a> (mlir::Type type)</td></tr>
<tr class="memdesc:a952faa929c7417a608f0b0ac17138c5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">valid types: <a class="el" href="#a8bdf8232394377a0c78dbd67d63d6764">isValidType()</a> - {<a class="el" href="classllzk_1_1polymorphic_1_1_type_var_type.html">TypeVarType</a>} - {types with variable parameters}  <br /></td></tr>
<tr class="separator:a952faa929c7417a608f0b0ac17138c5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84f2a1ccd00fcc70c93837e85228fe4b" id="r_a84f2a1ccd00fcc70c93837e85228fe4b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a84f2a1ccd00fcc70c93837e85228fe4b">isValidEmitEqType</a> (mlir::Type type)</td></tr>
<tr class="memdesc:a84f2a1ccd00fcc70c93837e85228fe4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">valid types: <a class="el" href="#a8bdf8232394377a0c78dbd67d63d6764">isValidType()</a> - {String, <a class="el" href="classllzk_1_1component_1_1_struct_type.html">StructType</a>} (excluded via any type parameter nesting)  <br /></td></tr>
<tr class="separator:a84f2a1ccd00fcc70c93837e85228fe4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1650252fbe1f1337fdb933a3cfacc3cf" id="r_a1650252fbe1f1337fdb933a3cfacc3cf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1650252fbe1f1337fdb933a3cfacc3cf">isValidConstReadType</a> (mlir::Type type)</td></tr>
<tr class="memdesc:a1650252fbe1f1337fdb933a3cfacc3cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">valid types: {I1, Index, <a class="el" href="classllzk_1_1felt_1_1_felt_type.html">FeltType</a>, <a class="el" href="classllzk_1_1polymorphic_1_1_type_var_type.html">TypeVarType</a>}  <br /></td></tr>
<tr class="separator:a1650252fbe1f1337fdb933a3cfacc3cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab02ae76b4775530127301c9dcbd1b22f" id="r_ab02ae76b4775530127301c9dcbd1b22f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab02ae76b4775530127301c9dcbd1b22f">isValidArrayElemType</a> (mlir::Type type)</td></tr>
<tr class="memdesc:ab02ae76b4775530127301c9dcbd1b22f"><td class="mdescLeft">&#160;</td><td class="mdescRight">valid types: <a class="el" href="#a8bdf8232394377a0c78dbd67d63d6764">isValidType()</a> - {<a class="el" href="classllzk_1_1array_1_1_array_type.html">ArrayType</a>}  <br /></td></tr>
<tr class="separator:ab02ae76b4775530127301c9dcbd1b22f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa4a1de20992b561a5506d6b4e629234" id="r_aaa4a1de20992b561a5506d6b4e629234"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa4a1de20992b561a5506d6b4e629234">isValidArrayType</a> (mlir::Type type)</td></tr>
<tr class="memdesc:aaa4a1de20992b561a5506d6b4e629234"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the type is a LLZK Array and it also contains a valid LLZK type.  <br /></td></tr>
<tr class="separator:aaa4a1de20992b561a5506d6b4e629234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9798d3afd220d09f46b40473781a6e86" id="r_a9798d3afd220d09f46b40473781a6e86"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9798d3afd220d09f46b40473781a6e86">isConcreteType</a> (mlir::Type type, bool allowStructParams=true)</td></tr>
<tr class="memdesc:a9798d3afd220d09f46b40473781a6e86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>false</code> iff the type contains any <code><a class="el" href="classllzk_1_1polymorphic_1_1_type_var_type.html">TypeVarType</a></code>  <br /></td></tr>
<tr class="separator:a9798d3afd220d09f46b40473781a6e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae30042843555f938699fed6daf364eac" id="r_ae30042843555f938699fed6daf364eac"><td class="memItemLeft" align="right" valign="top">mlir::LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae30042843555f938699fed6daf364eac">checkValidType</a> (<a class="el" href="#a36a2156534c7f7ae6aadbf0d8d8fa869">EmitErrorFn</a> emitError, mlir::Type type)</td></tr>
<tr class="separator:ae30042843555f938699fed6daf364eac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a810250b92231c248c7d345621436bed6" id="r_a810250b92231c248c7d345621436bed6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a810250b92231c248c7d345621436bed6">isSignalType</a> (mlir::Type type)</td></tr>
<tr class="memdesc:a810250b92231c248c7d345621436bed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> iff the given type is a <a class="el" href="classllzk_1_1component_1_1_struct_type.html">StructType</a> referencing the <code>COMPONENT_NAME_SIGNAL</code> struct.  <br /></td></tr>
<tr class="separator:a810250b92231c248c7d345621436bed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21a0759043e8fb39b7ccae07f0d788da" id="r_a21a0759043e8fb39b7ccae07f0d788da"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a21a0759043e8fb39b7ccae07f0d788da">hasAffineMapAttr</a> (mlir::Type type)</td></tr>
<tr class="memdesc:a21a0759043e8fb39b7ccae07f0d788da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> iff the given type contains an AffineMapAttr.  <br /></td></tr>
<tr class="separator:a21a0759043e8fb39b7ccae07f0d788da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0112dda4887f249d668efa60a5646bdd" id="r_a0112dda4887f249d668efa60a5646bdd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0112dda4887f249d668efa60a5646bdd">isDynamic</a> (mlir::IntegerAttr intAttr)</td></tr>
<tr class="separator:a0112dda4887f249d668efa60a5646bdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef957f901953e0f4c184c26c8993a6cb" id="r_aef957f901953e0f4c184c26c8993a6cb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef957f901953e0f4c184c26c8993a6cb">typeParamsUnify</a> (const mlir::ArrayRef&lt; mlir::Attribute &gt; &amp;lhsParams, const mlir::ArrayRef&lt; mlir::Attribute &gt; &amp;rhsParams, <a class="el" href="#a513acdd19d4296f6623ca75ed5eeb904">UnificationMap</a> *unifications=nullptr)</td></tr>
<tr class="memdesc:aef957f901953e0f4c184c26c8993a6cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> iff the two ArrayRef instances containing <a class="el" href="classllzk_1_1component_1_1_struct_type.html">StructType</a> or <a class="el" href="classllzk_1_1array_1_1_array_type.html">ArrayType</a> parameters are equivalent or could be equivalent after full instantiation of struct parameters.  <br /></td></tr>
<tr class="separator:aef957f901953e0f4c184c26c8993a6cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a655150473b4f06abf31999e50667dcf1" id="r_a655150473b4f06abf31999e50667dcf1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a655150473b4f06abf31999e50667dcf1">typeParamsUnify</a> (const mlir::ArrayAttr &amp;lhsParams, const mlir::ArrayAttr &amp;rhsParams, <a class="el" href="#a513acdd19d4296f6623ca75ed5eeb904">UnificationMap</a> *unifications=nullptr)</td></tr>
<tr class="memdesc:a655150473b4f06abf31999e50667dcf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> iff the two ArrayAttr instances containing <a class="el" href="classllzk_1_1component_1_1_struct_type.html">StructType</a> or <a class="el" href="classllzk_1_1array_1_1_array_type.html">ArrayType</a> parameters are equivalent or could be equivalent after full instantiation of struct parameters.  <br /></td></tr>
<tr class="separator:a655150473b4f06abf31999e50667dcf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5920231c88c6c04af215312177a62a68" id="r_a5920231c88c6c04af215312177a62a68"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5920231c88c6c04af215312177a62a68">arrayTypesUnify</a> (<a class="el" href="classllzk_1_1array_1_1_array_type.html">array::ArrayType</a> lhs, <a class="el" href="classllzk_1_1array_1_1_array_type.html">array::ArrayType</a> rhs, mlir::ArrayRef&lt; llvm::StringRef &gt; rhsReversePrefix={}, <a class="el" href="#a513acdd19d4296f6623ca75ed5eeb904">UnificationMap</a> *unifications=nullptr)</td></tr>
<tr class="memdesc:a5920231c88c6c04af215312177a62a68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> iff the two <a class="el" href="classllzk_1_1array_1_1_array_type.html">ArrayType</a> instances are equivalent or could be equivalent after full instantiation of struct parameters.  <br /></td></tr>
<tr class="separator:a5920231c88c6c04af215312177a62a68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69963a95b5969b71622293ca51f74103" id="r_a69963a95b5969b71622293ca51f74103"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69963a95b5969b71622293ca51f74103">structTypesUnify</a> (<a class="el" href="classllzk_1_1component_1_1_struct_type.html">component::StructType</a> lhs, <a class="el" href="classllzk_1_1component_1_1_struct_type.html">component::StructType</a> rhs, mlir::ArrayRef&lt; llvm::StringRef &gt; rhsReversePrefix={}, <a class="el" href="#a513acdd19d4296f6623ca75ed5eeb904">UnificationMap</a> *unifications=nullptr)</td></tr>
<tr class="memdesc:a69963a95b5969b71622293ca51f74103"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> iff the two <a class="el" href="classllzk_1_1component_1_1_struct_type.html">StructType</a> instances are equivalent or could be equivalent after full instantiation of struct parameters.  <br /></td></tr>
<tr class="separator:a69963a95b5969b71622293ca51f74103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a7476f05c4dce2ef7554e0ba1c3d567" id="r_a8a7476f05c4dce2ef7554e0ba1c3d567"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8a7476f05c4dce2ef7554e0ba1c3d567">typesUnify</a> (mlir::Type lhs, mlir::Type rhs, mlir::ArrayRef&lt; llvm::StringRef &gt; rhsReversePrefix={}, <a class="el" href="#a513acdd19d4296f6623ca75ed5eeb904">UnificationMap</a> *unifications=nullptr)</td></tr>
<tr class="memdesc:a8a7476f05c4dce2ef7554e0ba1c3d567"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> iff the two Type instances are equivalent or could be equivalent after full instantiation of struct parameters (if applicable within the given types).  <br /></td></tr>
<tr class="separator:a8a7476f05c4dce2ef7554e0ba1c3d567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a290cbd8f2848b2ab447a3b296adf6830" id="r_a290cbd8f2848b2ab447a3b296adf6830"><td class="memTemplParams" colspan="2">template&lt;typename Iter1, typename Iter2&gt; </td></tr>
<tr class="memitem:a290cbd8f2848b2ab447a3b296adf6830"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a290cbd8f2848b2ab447a3b296adf6830">typeListsUnify</a> (Iter1 lhs, Iter2 rhs, mlir::ArrayRef&lt; llvm::StringRef &gt; rhsReversePrefix={}, <a class="el" href="#a513acdd19d4296f6623ca75ed5eeb904">UnificationMap</a> *unifications=nullptr)</td></tr>
<tr class="memdesc:a290cbd8f2848b2ab447a3b296adf6830"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> iff the two lists of Type instances are equivalent or could be equivalent after full instantiation of struct parameters (if applicable within the given types).  <br /></td></tr>
<tr class="separator:a290cbd8f2848b2ab447a3b296adf6830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a440d077c5fc53dbf3a2ca32b9b82d4bf" id="r_a440d077c5fc53dbf3a2ca32b9b82d4bf"><td class="memTemplParams" colspan="2">template&lt;typename Iter1, typename Iter2&gt; </td></tr>
<tr class="memitem:a440d077c5fc53dbf3a2ca32b9b82d4bf"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a440d077c5fc53dbf3a2ca32b9b82d4bf">singletonTypeListsUnify</a> (Iter1 lhs, Iter2 rhs, mlir::ArrayRef&lt; llvm::StringRef &gt; rhsReversePrefix={}, <a class="el" href="#a513acdd19d4296f6623ca75ed5eeb904">UnificationMap</a> *unifications=nullptr)</td></tr>
<tr class="separator:a440d077c5fc53dbf3a2ca32b9b82d4bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1799d8cc9b704df606b1a99172014065" id="r_a1799d8cc9b704df606b1a99172014065"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1799d8cc9b704df606b1a99172014065">isMoreConcreteUnification</a> (mlir::Type oldTy, mlir::Type newTy, llvm::function_ref&lt; bool(mlir::Type oldTy, mlir::Type newTy)&gt; knownOldToNew=nullptr)</td></tr>
<tr class="memdesc:a1799d8cc9b704df606b1a99172014065"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> iff the types unify and <code>newTy</code> is "more concrete" than <code>oldTy</code>.  <br /></td></tr>
<tr class="separator:a1799d8cc9b704df606b1a99172014065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a374eec2da9f2f274eabc9dd54d33f27c" id="r_a374eec2da9f2f274eabc9dd54d33f27c"><td class="memTemplParams" colspan="2">template&lt;typename TypeClass&gt; </td></tr>
<tr class="memitem:a374eec2da9f2f274eabc9dd54d33f27c"><td class="memTemplItemLeft" align="right" valign="top">TypeClass&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a374eec2da9f2f274eabc9dd54d33f27c">getIfSingleton</a> (mlir::TypeRange types)</td></tr>
<tr class="separator:a374eec2da9f2f274eabc9dd54d33f27c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b72620c55defe1f3d66eda8fac6e0e7" id="r_a8b72620c55defe1f3d66eda8fac6e0e7"><td class="memTemplParams" colspan="2">template&lt;typename TypeClass&gt; </td></tr>
<tr class="memitem:a8b72620c55defe1f3d66eda8fac6e0e7"><td class="memTemplItemLeft" align="right" valign="top">TypeClass&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8b72620c55defe1f3d66eda8fac6e0e7">getAtIndex</a> (mlir::TypeRange types, size_t index)</td></tr>
<tr class="separator:a8b72620c55defe1f3d66eda8fac6e0e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a80f06bcaf7eec2f949aac5fa734f5b" id="r_a0a80f06bcaf7eec2f949aac5fa734f5b"><td class="memItemLeft" align="right" valign="top">mlir::IntegerAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a80f06bcaf7eec2f949aac5fa734f5b">forceIntType</a> (mlir::IntegerAttr attr)</td></tr>
<tr class="memdesc:a0a80f06bcaf7eec2f949aac5fa734f5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an IntegerAttr with a type other than IndexType to use IndexType.  <br /></td></tr>
<tr class="separator:a0a80f06bcaf7eec2f949aac5fa734f5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c6052a9b69960f0d3ee8c6070f26cc2" id="r_a2c6052a9b69960f0d3ee8c6070f26cc2"><td class="memItemLeft" align="right" valign="top">mlir::Attribute&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c6052a9b69960f0d3ee8c6070f26cc2">forceIntAttrType</a> (mlir::Attribute attr)</td></tr>
<tr class="memdesc:a2c6052a9b69960f0d3ee8c6070f26cc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert any IntegerAttr with a type other than IndexType to use IndexType.  <br /></td></tr>
<tr class="separator:a2c6052a9b69960f0d3ee8c6070f26cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d13ac1b35c29b7e5549650e6c52180" id="r_a60d13ac1b35c29b7e5549650e6c52180"><td class="memItemLeft" align="right" valign="top">llvm::SmallVector&lt; mlir::Attribute &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a60d13ac1b35c29b7e5549650e6c52180">forceIntAttrTypes</a> (llvm::ArrayRef&lt; mlir::Attribute &gt; attrList)</td></tr>
<tr class="memdesc:a60d13ac1b35c29b7e5549650e6c52180"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert any IntegerAttr with a type other than IndexType to use IndexType.  <br /></td></tr>
<tr class="separator:a60d13ac1b35c29b7e5549650e6c52180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4df6c0fdb96ccfcf9714e70332cbc6ea" id="r_a4df6c0fdb96ccfcf9714e70332cbc6ea"><td class="memItemLeft" align="right" valign="top">mlir::LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4df6c0fdb96ccfcf9714e70332cbc6ea">verifyIntAttrType</a> (<a class="el" href="#a36a2156534c7f7ae6aadbf0d8d8fa869">EmitErrorFn</a> emitError, mlir::Attribute in)</td></tr>
<tr class="memdesc:a4df6c0fdb96ccfcf9714e70332cbc6ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify that all IntegerAttr have type IndexType.  <br /></td></tr>
<tr class="separator:a4df6c0fdb96ccfcf9714e70332cbc6ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4d946242ab564714c666f9d89fc8037" id="r_ad4d946242ab564714c666f9d89fc8037"><td class="memItemLeft" align="right" valign="top">mlir::LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad4d946242ab564714c666f9d89fc8037">verifyAffineMapAttrType</a> (<a class="el" href="#a36a2156534c7f7ae6aadbf0d8d8fa869">EmitErrorFn</a> emitError, mlir::Attribute in)</td></tr>
<tr class="memdesc:ad4d946242ab564714c666f9d89fc8037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify that all AffineMapAttr only have a single result.  <br /></td></tr>
<tr class="separator:ad4d946242ab564714c666f9d89fc8037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed39cddd257ee780016ebcc6acce954a" id="r_aed39cddd257ee780016ebcc6acce954a"><td class="memItemLeft" align="right" valign="top">mlir::LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed39cddd257ee780016ebcc6acce954a">verifyStructTypeParams</a> (<a class="el" href="#a36a2156534c7f7ae6aadbf0d8d8fa869">EmitErrorFn</a> emitError, mlir::ArrayAttr params)</td></tr>
<tr class="memdesc:aed39cddd257ee780016ebcc6acce954a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify that the <a class="el" href="classllzk_1_1component_1_1_struct_type.html">StructType</a> parameters are valid.  <br /></td></tr>
<tr class="separator:aed39cddd257ee780016ebcc6acce954a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27d82a7165519ee38626eca2062dc9ec" id="r_a27d82a7165519ee38626eca2062dc9ec"><td class="memItemLeft" align="right" valign="top">mlir::LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a27d82a7165519ee38626eca2062dc9ec">verifyArrayDimSizes</a> (<a class="el" href="#a36a2156534c7f7ae6aadbf0d8d8fa869">EmitErrorFn</a> emitError, mlir::ArrayRef&lt; mlir::Attribute &gt; dimensionSizes)</td></tr>
<tr class="memdesc:a27d82a7165519ee38626eca2062dc9ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify that the array dimenstions are valid.  <br /></td></tr>
<tr class="separator:a27d82a7165519ee38626eca2062dc9ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28b6fbe238c9f2d2f1874f246ecb4b06" id="r_a28b6fbe238c9f2d2f1874f246ecb4b06"><td class="memItemLeft" align="right" valign="top">mlir::LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a28b6fbe238c9f2d2f1874f246ecb4b06">verifyArrayType</a> (<a class="el" href="#a36a2156534c7f7ae6aadbf0d8d8fa869">EmitErrorFn</a> emitError, mlir::Type elementType, mlir::ArrayRef&lt; mlir::Attribute &gt; dimensionSizes)</td></tr>
<tr class="memdesc:a28b6fbe238c9f2d2f1874f246ecb4b06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify that the <a class="el" href="classllzk_1_1array_1_1_array_type.html">ArrayType</a> is valid.  <br /></td></tr>
<tr class="separator:a28b6fbe238c9f2d2f1874f246ecb4b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f07e4e94a94854901995d211dac9f8a" id="r_a2f07e4e94a94854901995d211dac9f8a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; mlir::Pass &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f07e4e94a94854901995d211dac9f8a">createFieldWriteValidatorPass</a> ()</td></tr>
<tr class="separator:a2f07e4e94a94854901995d211dac9f8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8079434ecfbc1457fb901788ce16f69e" id="r_a8079434ecfbc1457fb901788ce16f69e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8079434ecfbc1457fb901788ce16f69e">registerFieldWriteValidatorPass</a> ()</td></tr>
<tr class="separator:a8079434ecfbc1457fb901788ce16f69e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f0d7d42936af872189a17c6c42a1469" id="r_a2f0d7d42936af872189a17c6c42a1469"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f0d7d42936af872189a17c6c42a1469">registerFieldWriteValidatorPassPass</a> ()</td></tr>
<tr class="separator:a2f0d7d42936af872189a17c6c42a1469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ae96b1bcc90611da3d6bfd5cd5689fd" id="r_a6ae96b1bcc90611da3d6bfd5cd5689fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ae96b1bcc90611da3d6bfd5cd5689fd">registerValidationPasses</a> ()</td></tr>
<tr class="separator:a6ae96b1bcc90611da3d6bfd5cd5689fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ab849305197e4aa934967d210a512f107" id="r_ab849305197e4aa934967d210a512f107"><td class="memItemLeft" align="right" valign="top">constexpr char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab849305197e4aa934967d210a512f107">COMPONENT_NAME_SIGNAL</a> [] = &quot;Signal&quot;</td></tr>
<tr class="memdesc:ab849305197e4aa934967d210a512f107"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbol name for the struct/component representing a signal.  <br /></td></tr>
<tr class="separator:ab849305197e4aa934967d210a512f107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fc6fe57002b3ad8de6b04de904ad83a" id="r_a2fc6fe57002b3ad8de6b04de904ad83a"><td class="memItemLeft" align="right" valign="top">constexpr char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2fc6fe57002b3ad8de6b04de904ad83a">COMPONENT_NAME_MAIN</a> [] = &quot;Main&quot;</td></tr>
<tr class="memdesc:a2fc6fe57002b3ad8de6b04de904ad83a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbol name for the main entry point struct/component (if any).  <br /></td></tr>
<tr class="separator:a2fc6fe57002b3ad8de6b04de904ad83a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a078ca0039bbcd069858d9c9141c015d0" id="r_a078ca0039bbcd069858d9c9141c015d0"><td class="memItemLeft" align="right" valign="top">constexpr char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a078ca0039bbcd069858d9c9141c015d0">FUNC_NAME_COMPUTE</a> [] = &quot;compute&quot;</td></tr>
<tr class="memdesc:a078ca0039bbcd069858d9c9141c015d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbol name for the witness generation (and resp.  <br /></td></tr>
<tr class="separator:a078ca0039bbcd069858d9c9141c015d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a353b99dc283d18cdecb549edcb8d096f" id="r_a353b99dc283d18cdecb549edcb8d096f"><td class="memItemLeft" align="right" valign="top">constexpr char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a353b99dc283d18cdecb549edcb8d096f">FUNC_NAME_CONSTRAIN</a> [] = &quot;constrain&quot;</td></tr>
<tr class="separator:a353b99dc283d18cdecb549edcb8d096f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b66c1ee1b386cb29f255332f586e96d" id="r_a1b66c1ee1b386cb29f255332f586e96d"><td class="memItemLeft" align="right" valign="top">constexpr char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b66c1ee1b386cb29f255332f586e96d">LANG_ATTR_NAME</a> [] = &quot;veridise.lang&quot;</td></tr>
<tr class="memdesc:a1b66c1ee1b386cb29f255332f586e96d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of the attribute on the top-level ModuleOp that specifies the IR language name.  <br /></td></tr>
<tr class="separator:a1b66c1ee1b386cb29f255332f586e96d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a6ec981cf9fcf4cfee0a3ae42183bfa95" name="a6ec981cf9fcf4cfee0a3ae42183bfa95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ec981cf9fcf4cfee0a3ae42183bfa95">&#9670;&#160;</a></span>ConstrainRefRemappings</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a6ec981cf9fcf4cfee0a3ae42183bfa95">llzk::ConstrainRefRemappings</a> = std::vector&lt;std::pair&lt;<a class="el" href="classllzk_1_1_constrain_ref.html">ConstrainRef</a>, <a class="el" href="classllzk_1_1_constrain_ref_lattice_value.html">ConstrainRefLatticeValue</a>&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_constraint_dependency_graph_8h_source.html#l00028">28</a> of file <a class="el" href="_constraint_dependency_graph_8h_source.html">ConstraintDependencyGraph.h</a>.</p>

</div>
</div>
<a id="a36a2156534c7f7ae6aadbf0d8d8fa869" name="a36a2156534c7f7ae6aadbf0d8d8fa869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36a2156534c7f7ae6aadbf0d8d8fa869">&#9670;&#160;</a></span>EmitErrorFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a36a2156534c7f7ae6aadbf0d8d8fa869">llzk::EmitErrorFn</a> = llvm::function_ref&lt;mlir::InFlightDiagnostic()&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_error_helper_8h_source.html#l00018">18</a> of file <a class="el" href="_error_helper_8h_source.html">ErrorHelper.h</a>.</p>

</div>
</div>
<a id="a79668426b2b2e76d9dde555e6ddb3852" name="a79668426b2b2e76d9dde555e6ddb3852"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79668426b2b2e76d9dde555e6ddb3852">&#9670;&#160;</a></span>ManagedResources</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a79668426b2b2e76d9dde555e6ddb3852">llzk::ManagedResources</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    std::shared_ptr&lt;std::pair&lt;mlir::OwningOpRef&lt;mlir::ModuleOp&gt;, mlir::SymbolTableCollection&gt;&gt;</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="_symbol_lookup_8h_source.html#l00029">29</a> of file <a class="el" href="_symbol_lookup_8h_source.html">SymbolLookup.h</a>.</p>

</div>
</div>
<a id="a7357b1ebd2b125f62a0a2fd3bf559af1" name="a7357b1ebd2b125f62a0a2fd3bf559af1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7357b1ebd2b125f62a0a2fd3bf559af1">&#9670;&#160;</a></span>OwningEmitErrorFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a7357b1ebd2b125f62a0a2fd3bf559af1">llzk::OwningEmitErrorFn</a> = std::function&lt;mlir::InFlightDiagnostic()&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_error_helper_8h_source.html#l00022">22</a> of file <a class="el" href="_error_helper_8h_source.html">ErrorHelper.h</a>.</p>

</div>
</div>
<a id="af0c320a86bace53ee6eb99056458f7d8" name="af0c320a86bace53ee6eb99056458f7d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0c320a86bace53ee6eb99056458f7d8">&#9670;&#160;</a></span>TranslationMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#af0c320a86bace53ee6eb99056458f7d8">llzk::TranslationMap</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    std::unordered_map&lt;ConstrainRef, ConstrainRefLatticeValue, ConstrainRef::Hash&gt;</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="_constrain_ref_lattice_8h_source.html#l00020">20</a> of file <a class="el" href="_constrain_ref_lattice_8h_source.html">ConstrainRefLattice.h</a>.</p>

</div>
</div>
<a id="a513acdd19d4296f6623ca75ed5eeb904" name="a513acdd19d4296f6623ca75ed5eeb904"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a513acdd19d4296f6623ca75ed5eeb904">&#9670;&#160;</a></span>UnificationMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a513acdd19d4296f6623ca75ed5eeb904">llzk::UnificationMap</a> = mlir::DenseMap&lt;std::pair&lt;mlir::SymbolRefAttr, <a class="el" href="#a2a5039e04435e7c0f3883c08db97e95a">Side</a>&gt;, mlir::Attribute&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Optional result from type unifications. </p>
<p>Maps <code>SymbolRefAttr</code> appearing in one type to the associated <code>Attribute</code> from the other type at the same nested position. The <code><a class="el" href="#a2a5039e04435e7c0f3883c08db97e95a">Side</a></code> enum in the key indicates which input expression the <code>SymbolRefAttr</code> is from. Additionally, if a conflict is found (i.e. multiple occurances of a specific <code>SymbolRefAttr</code> on the same side map to different Attributes from the other side). The mapped value will be <code>nullptr</code>.</p>
<p>This map is used by the <code>llzk-flatten</code> pass to replace struct parameter <code>SymbolRefAttr</code> with static concrete values to produce the flattened versions of structs. </p>

<p class="definition">Definition at line <a class="el" href="_type_helper_8h_source.html#l00159">159</a> of file <a class="el" href="_type_helper_8h_source.html">TypeHelper.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a2a5039e04435e7c0f3883c08db97e95a" name="a2a5039e04435e7c0f3883c08db97e95a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a5039e04435e7c0f3883c08db97e95a">&#9670;&#160;</a></span>Side</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a2a5039e04435e7c0f3883c08db97e95a">llzk::Side</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2a5039e04435e7c0f3883c08db97e95aaba2b45bdc11e2a4a6e86aab2ac693cbb" name="a2a5039e04435e7c0f3883c08db97e95aaba2b45bdc11e2a4a6e86aab2ac693cbb"></a>EMPTY&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2a5039e04435e7c0f3883c08db97e95aa8cbc0fb889c6cc21e0be26227a2b468b" name="a2a5039e04435e7c0f3883c08db97e95aa8cbc0fb889c6cc21e0be26227a2b468b"></a>LHS&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2a5039e04435e7c0f3883c08db97e95aae80302656805aeec44dc5d789d653c6b" name="a2a5039e04435e7c0f3883c08db97e95aae80302656805aeec44dc5d789d653c6b"></a>RHS&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2a5039e04435e7c0f3883c08db97e95aad347574c48f5bbb0a804da9bb77d67a3" name="a2a5039e04435e7c0f3883c08db97e95aad347574c48f5bbb0a804da9bb77d67a3"></a>TOMB&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_type_helper_8h_source.html#l00114">114</a> of file <a class="el" href="_type_helper_8h_source.html">TypeHelper.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a4133cf302b40a27435b317f0c953c18e" name="a4133cf302b40a27435b317f0c953c18e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4133cf302b40a27435b317f0c953c18e">&#9670;&#160;</a></span>add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllzk_1_1_expression_value.html">ExpressionValue</a> llzk::add </td>
          <td>(</td>
          <td class="paramtype">llvm::SMTSolverRef</td>          <td class="paramname"><span class="paramname"><em>solver</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classllzk_1_1_expression_value.html">ExpressionValue</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classllzk_1_1_expression_value.html">ExpressionValue</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_interval_analysis_8cpp_source.html#l00485">485</a> of file <a class="el" href="_interval_analysis_8cpp_source.html">IntervalAnalysis.cpp</a>.</p>

</div>
</div>
<a id="ad1625d8ebd06095492c891b4fe65d5ef" name="ad1625d8ebd06095492c891b4fe65d5ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1625d8ebd06095492c891b4fe65d5ef">&#9670;&#160;</a></span>addLangAttrForLLZKDialect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void llzk::addLangAttrForLLZKDialect </td>
          <td>(</td>
          <td class="paramtype">mlir::ModuleOp</td>          <td class="paramname"><span class="paramname"><em>mod</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_builders_8cpp_source.html#l00028">28</a> of file <a class="el" href="_builders_8cpp_source.html">Builders.cpp</a>.</p>

</div>
</div>
<a id="a425f3885d7b5a6ec7fe6f06c5233edae" name="a425f3885d7b5a6ec7fe6f06c5233edae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a425f3885d7b5a6ec7fe6f06c5233edae">&#9670;&#160;</a></span>appendLeaf() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::SymbolRefAttr llzk::appendLeaf </td>
          <td>(</td>
          <td class="paramtype">mlir::SymbolRefAttr</td>          <td class="paramname"><span class="paramname"><em>orig</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mlir::Twine &amp;</td>          <td class="paramname"><span class="paramname"><em>newLeaf</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_symbol_helper_8h_source.html#l00079">79</a> of file <a class="el" href="_symbol_helper_8h_source.html">SymbolHelper.h</a>.</p>

</div>
</div>
<a id="af6782a6db3405d4048a5ffb345f28192" name="af6782a6db3405d4048a5ffb345f28192"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6782a6db3405d4048a5ffb345f28192">&#9670;&#160;</a></span>appendLeaf() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mlir::SymbolRefAttr llzk::appendLeaf </td>
          <td>(</td>
          <td class="paramtype">mlir::SymbolRefAttr</td>          <td class="paramname"><span class="paramname"><em>orig</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mlir::FlatSymbolRefAttr</td>          <td class="paramname"><span class="paramname"><em>newLeaf</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return SymbolRefAttr like the one given but with a new leaf (final) element added. </p>

</div>
</div>
<a id="af5d40b8f21a8a58c469d549bb2553c46" name="af5d40b8f21a8a58c469d549bb2553c46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5d40b8f21a8a58c469d549bb2553c46">&#9670;&#160;</a></span>appendLeaf() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::SymbolRefAttr llzk::appendLeaf </td>
          <td>(</td>
          <td class="paramtype">mlir::SymbolRefAttr</td>          <td class="paramname"><span class="paramname"><em>orig</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mlir::StringAttr</td>          <td class="paramname"><span class="paramname"><em>newLeaf</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_symbol_helper_8h_source.html#l00076">76</a> of file <a class="el" href="_symbol_helper_8h_source.html">SymbolHelper.h</a>.</p>

</div>
</div>
<a id="a5a8f8e48ae6b42bbfbccc3b9a58e642d" name="a5a8f8e48ae6b42bbfbccc3b9a58e642d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a8f8e48ae6b42bbfbccc3b9a58e642d">&#9670;&#160;</a></span>appendLeaf() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SymbolRefAttr llzk::appendLeaf </td>
          <td>(</td>
          <td class="paramtype">SymbolRefAttr</td>          <td class="paramname"><span class="paramname"><em>orig</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FlatSymbolRefAttr</td>          <td class="paramname"><span class="paramname"><em>newLeaf</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_symbol_helper_8cpp_source.html#l00180">180</a> of file <a class="el" href="_symbol_helper_8cpp_source.html">SymbolHelper.cpp</a>.</p>

</div>
</div>
<a id="acaffefb5eebcbf303a9217ff07df7fb0" name="acaffefb5eebcbf303a9217ff07df7fb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaffefb5eebcbf303a9217ff07df7fb0">&#9670;&#160;</a></span>appendLeafName() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mlir::SymbolRefAttr llzk::appendLeafName </td>
          <td>(</td>
          <td class="paramtype">mlir::SymbolRefAttr</td>          <td class="paramname"><span class="paramname"><em>orig</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mlir::Twine &amp;</td>          <td class="paramname"><span class="paramname"><em>newLeafSuffix</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return SymbolRefAttr like the one given but with the leaf (final) element appended with the given suffix. </p>

</div>
</div>
<a id="a1834ce0bbea39a5089abc81e496ea685" name="a1834ce0bbea39a5089abc81e496ea685"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1834ce0bbea39a5089abc81e496ea685">&#9670;&#160;</a></span>appendLeafName() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SymbolRefAttr llzk::appendLeafName </td>
          <td>(</td>
          <td class="paramtype">SymbolRefAttr</td>          <td class="paramname"><span class="paramname"><em>orig</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Twine &amp;</td>          <td class="paramname"><span class="paramname"><em>newLeafSuffix</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_symbol_helper_8cpp_source.html#l00184">184</a> of file <a class="el" href="_symbol_helper_8cpp_source.html">SymbolHelper.cpp</a>.</p>

</div>
</div>
<a id="ad54f2cf52138ae6282775a72362a7445" name="ad54f2cf52138ae6282775a72362a7445"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad54f2cf52138ae6282775a72362a7445">&#9670;&#160;</a></span>appendWithoutType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void llzk::appendWithoutType </td>
          <td>(</td>
          <td class="paramtype">mlir::raw_ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mlir::Attribute</td>          <td class="paramname"><span class="paramname"><em>a</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_attribute_helper_8h_source.html#l00038">38</a> of file <a class="el" href="_attribute_helper_8h_source.html">AttributeHelper.h</a>.</p>

</div>
</div>
<a id="a5920231c88c6c04af215312177a62a68" name="a5920231c88c6c04af215312177a62a68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5920231c88c6c04af215312177a62a68">&#9670;&#160;</a></span>arrayTypesUnify() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool llzk::arrayTypesUnify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllzk_1_1array_1_1_array_type.html">array::ArrayType</a></td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllzk_1_1array_1_1_array_type.html">array::ArrayType</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mlir::ArrayRef&lt; llvm::StringRef &gt;</td>          <td class="paramname"><span class="paramname"><em>rhsReversePrefix</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a513acdd19d4296f6623ca75ed5eeb904">UnificationMap</a> *</td>          <td class="paramname"><span class="paramname"><em>unifications</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return <code>true</code> iff the two <a class="el" href="classllzk_1_1array_1_1_array_type.html">ArrayType</a> instances are equivalent or could be equivalent after full instantiation of struct parameters. </p>

</div>
</div>
<a id="a9bdd2635c665c9a009596b32ceeeafec" name="a9bdd2635c665c9a009596b32ceeeafec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bdd2635c665c9a009596b32ceeeafec">&#9670;&#160;</a></span>arrayTypesUnify() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool llzk::arrayTypesUnify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllzk_1_1array_1_1_array_type.html">ArrayType</a></td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllzk_1_1array_1_1_array_type.html">ArrayType</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayRef&lt; StringRef &gt;</td>          <td class="paramname"><span class="paramname"><em>rhsReversePrefix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a513acdd19d4296f6623ca75ed5eeb904">UnificationMap</a> *</td>          <td class="paramname"><span class="paramname"><em>unifications</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_type_helper_8cpp_source.html#l00674">674</a> of file <a class="el" href="_type_helper_8cpp_source.html">TypeHelper.cpp</a>.</p>

</div>
</div>
<a id="a06f8a74431f12f0298cc7033691f84ec" name="a06f8a74431f12f0298cc7033691f84ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06f8a74431f12f0298cc7033691f84ec">&#9670;&#160;</a></span>assertValidAttrForParamOfType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void llzk::assertValidAttrForParamOfType </td>
          <td>(</td>
          <td class="paramtype">Attribute</td>          <td class="paramname"><span class="paramname"><em>attr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_type_helper_8cpp_source.html#l00779">779</a> of file <a class="el" href="_type_helper_8cpp_source.html">TypeHelper.cpp</a>.</p>

</div>
</div>
<a id="a3840dc2d50d9f0cda122fb59ebaf32ed" name="a3840dc2d50d9f0cda122fb59ebaf32ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3840dc2d50d9f0cda122fb59ebaf32ed">&#9670;&#160;</a></span>assertValidAttrForParamOfType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void llzk::assertValidAttrForParamOfType </td>
          <td>(</td>
          <td class="paramtype">mlir::Attribute</td>          <td class="paramname"><span class="paramname"><em>attr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1e9f41024dc1c528963ac365b72906b7" name="a1e9f41024dc1c528963ac365b72906b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e9f41024dc1c528963ac365b72906b7">&#9670;&#160;</a></span>asSymbolRefAttr() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::SymbolRefAttr llzk::asSymbolRefAttr </td>
          <td>(</td>
          <td class="paramtype">llvm::ArrayRef&lt; mlir::FlatSymbolRefAttr &gt;</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build a SymbolRefAttr from the list of pieces. </p>

<p class="definition">Definition at line <a class="el" href="_symbol_helper_8h_source.html#l00044">44</a> of file <a class="el" href="_symbol_helper_8h_source.html">SymbolHelper.h</a>.</p>

</div>
</div>
<a id="ab1ef6741a40f7e02fc0b94c979c8b3be" name="ab1ef6741a40f7e02fc0b94c979c8b3be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1ef6741a40f7e02fc0b94c979c8b3be">&#9670;&#160;</a></span>asSymbolRefAttr() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::SymbolRefAttr llzk::asSymbolRefAttr </td>
          <td>(</td>
          <td class="paramtype">mlir::StringAttr</td>          <td class="paramname"><span class="paramname"><em>root</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mlir::SymbolRefAttr</td>          <td class="paramname"><span class="paramname"><em>tail</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build a SymbolRefAttr that prepends <code>tail</code> with <code>root</code>, i.e. <code>root::tail</code>. </p>

<p class="definition">Definition at line <a class="el" href="_symbol_helper_8h_source.html#l00039">39</a> of file <a class="el" href="_symbol_helper_8h_source.html">SymbolHelper.h</a>.</p>

</div>
</div>
<a id="a16ec473bc15954ac7583672b67388d03" name="a16ec473bc15954ac7583672b67388d03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16ec473bc15954ac7583672b67388d03">&#9670;&#160;</a></span>asSymbolRefAttr() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::SymbolRefAttr llzk::asSymbolRefAttr </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; mlir::FlatSymbolRefAttr &gt;</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build a SymbolRefAttr from the list of pieces. </p>

<p class="definition">Definition at line <a class="el" href="_symbol_helper_8h_source.html#l00049">49</a> of file <a class="el" href="_symbol_helper_8h_source.html">SymbolHelper.h</a>.</p>

</div>
</div>
<a id="ae30042843555f938699fed6daf364eac" name="ae30042843555f938699fed6daf364eac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae30042843555f938699fed6daf364eac">&#9670;&#160;</a></span>checkValidType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::LogicalResult llzk::checkValidType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a36a2156534c7f7ae6aadbf0d8d8fa869">EmitErrorFn</a></td>          <td class="paramname"><span class="paramname"><em>emitError</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mlir::Type</td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_type_helper_8h_source.html#l00097">97</a> of file <a class="el" href="_type_helper_8h_source.html">TypeHelper.h</a>.</p>

</div>
</div>
<a id="aa450de4115eb980c84b45aa6f2ad1ff5" name="aa450de4115eb980c84b45aa6f2ad1ff5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa450de4115eb980c84b45aa6f2ad1ff5">&#9670;&#160;</a></span>cmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllzk_1_1_expression_value.html">ExpressionValue</a> llzk::cmp </td>
          <td>(</td>
          <td class="paramtype">llvm::SMTSolverRef</td>          <td class="paramname"><span class="paramname"><em>solver</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllzk_1_1boolean_1_1_cmp_op.html">boolean::CmpOp</a></td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classllzk_1_1_expression_value.html">ExpressionValue</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classllzk_1_1_expression_value.html">ExpressionValue</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_interval_analysis_8cpp_source.html#l00535">535</a> of file <a class="el" href="_interval_analysis_8cpp_source.html">IntervalAnalysis.cpp</a>.</p>

</div>
</div>
<a id="aab494edb15dac73bb877f74a9378eab8" name="aab494edb15dac73bb877f74a9378eab8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab494edb15dac73bb877f74a9378eab8">&#9670;&#160;</a></span>createArrayToScalarPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; mlir::Pass &gt; llzk::createArrayToScalarPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a81bdf67dd777af0f515ba3c876468bcd" name="a81bdf67dd777af0f515ba3c876468bcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81bdf67dd777af0f515ba3c876468bcd">&#9670;&#160;</a></span>createCallGraphPrinterPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; mlir::Pass &gt; llzk::createCallGraphPrinterPass </td>
          <td>(</td>
          <td class="paramtype">llvm::raw_ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span><span class="paramdefsep"> = </span><span class="paramdefval">llvm::errs()</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_call_graph_passes_8cpp_source.html#l00050">50</a> of file <a class="el" href="_call_graph_passes_8cpp_source.html">CallGraphPasses.cpp</a>.</p>

</div>
</div>
<a id="a80271c2440367129b787c6a3d49528ff" name="a80271c2440367129b787c6a3d49528ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80271c2440367129b787c6a3d49528ff">&#9670;&#160;</a></span>createCallGraphSCCsPrinterPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; mlir::Pass &gt; llzk::createCallGraphSCCsPrinterPass </td>
          <td>(</td>
          <td class="paramtype">llvm::raw_ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span><span class="paramdefsep"> = </span><span class="paramdefval">llvm::errs()</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_call_graph_passes_8cpp_source.html#l00095">95</a> of file <a class="el" href="_call_graph_passes_8cpp_source.html">CallGraphPasses.cpp</a>.</p>

</div>
</div>
<a id="a580c97b052e21d14057b861edfb047b9" name="a580c97b052e21d14057b861edfb047b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a580c97b052e21d14057b861edfb047b9">&#9670;&#160;</a></span>createConstraintDependencyGraphPrinterPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; mlir::Pass &gt; llzk::createConstraintDependencyGraphPrinterPass </td>
          <td>(</td>
          <td class="paramtype">llvm::raw_ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span><span class="paramdefsep"> = </span><span class="paramdefval">llvm::errs()</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_constraint_dependency_graph_pass_8cpp_source.html#l00065">65</a> of file <a class="el" href="_constraint_dependency_graph_pass_8cpp_source.html">ConstraintDependencyGraphPass.cpp</a>.</p>

</div>
</div>
<a id="a2f07e4e94a94854901995d211dac9f8a" name="a2f07e4e94a94854901995d211dac9f8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f07e4e94a94854901995d211dac9f8a">&#9670;&#160;</a></span>createFieldWriteValidatorPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; mlir::Pass &gt; llzk::createFieldWriteValidatorPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_l_l_z_k_validation_passes_8cpp_source.html#l00082">82</a> of file <a class="el" href="_l_l_z_k_validation_passes_8cpp_source.html">LLZKValidationPasses.cpp</a>.</p>

</div>
</div>
<a id="a4b23872eceb03786a0fc287ba896044b" name="a4b23872eceb03786a0fc287ba896044b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b23872eceb03786a0fc287ba896044b">&#9670;&#160;</a></span>createFlatteningPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; mlir::Pass &gt; llzk::createFlatteningPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a59d66a0caa073316e9e8ccf5f96be707" name="a59d66a0caa073316e9e8ccf5f96be707"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59d66a0caa073316e9e8ccf5f96be707">&#9670;&#160;</a></span>createIntervalAnalysisPrinterPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; mlir::Pass &gt; llzk::createIntervalAnalysisPrinterPass </td>
          <td>(</td>
          <td class="paramtype">llvm::raw_ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span><span class="paramdefsep"> = </span><span class="paramdefval">llvm::errs()</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_interval_analysis_pass_8cpp_source.html#l00073">73</a> of file <a class="el" href="_interval_analysis_pass_8cpp_source.html">IntervalAnalysisPass.cpp</a>.</p>

</div>
</div>
<a id="a24a8f8d60a445812f3792f04b6420f5c" name="a24a8f8d60a445812f3792f04b6420f5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24a8f8d60a445812f3792f04b6420f5c">&#9670;&#160;</a></span>createLLZKModule() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::OwningOpRef&lt; mlir::ModuleOp &gt; llzk::createLLZKModule </td>
          <td>(</td>
          <td class="paramtype">mlir::MLIRContext *</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_builders_8h_source.html#l00031">31</a> of file <a class="el" href="_builders_8h_source.html">Builders.h</a>.</p>

</div>
</div>
<a id="a5fca8161d33010dac2a613d7ff184db2" name="a5fca8161d33010dac2a613d7ff184db2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fca8161d33010dac2a613d7ff184db2">&#9670;&#160;</a></span>createLLZKModule() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mlir::OwningOpRef&lt; mlir::ModuleOp &gt; llzk::createLLZKModule </td>
          <td>(</td>
          <td class="paramtype">mlir::MLIRContext *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mlir::Location</td>          <td class="paramname"><span class="paramname"><em>loc</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeb8b8c23db146a0a520f07c965318ba4" name="aeb8b8c23db146a0a520f07c965318ba4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb8b8c23db146a0a520f07c965318ba4">&#9670;&#160;</a></span>createLLZKModule() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OwningOpRef&lt; ModuleOp &gt; llzk::createLLZKModule </td>
          <td>(</td>
          <td class="paramtype">MLIRContext *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Location</td>          <td class="paramname"><span class="paramname"><em>loc</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_builders_8cpp_source.html#l00022">22</a> of file <a class="el" href="_builders_8cpp_source.html">Builders.cpp</a>.</p>

</div>
</div>
<a id="a02ed7b620ceb2def986e01d65617d3d4" name="a02ed7b620ceb2def986e01d65617d3d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02ed7b620ceb2def986e01d65617d3d4">&#9670;&#160;</a></span>createRedundantOperationEliminationPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; mlir::Pass &gt; llzk::createRedundantOperationEliminationPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_l_l_z_k_redundant_operation_elimination_pass_8cpp_source.html#l00285">285</a> of file <a class="el" href="_l_l_z_k_redundant_operation_elimination_pass_8cpp_source.html">LLZKRedundantOperationEliminationPass.cpp</a>.</p>

</div>
</div>
<a id="a764713f7354a0b4b2cf1b861a443136e" name="a764713f7354a0b4b2cf1b861a443136e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a764713f7354a0b4b2cf1b861a443136e">&#9670;&#160;</a></span>createRedundantReadAndWriteEliminationPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; mlir::Pass &gt; llzk::createRedundantReadAndWriteEliminationPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_l_l_z_k_redundant_read_and_write_elimination_pass_8cpp_source.html#l00682">682</a> of file <a class="el" href="_l_l_z_k_redundant_read_and_write_elimination_pass_8cpp_source.html">LLZKRedundantReadAndWriteEliminationPass.cpp</a>.</p>

</div>
</div>
<a id="aa81a4cdbc9130d5a1f71367fdc225ef2" name="aa81a4cdbc9130d5a1f71367fdc225ef2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa81a4cdbc9130d5a1f71367fdc225ef2">&#9670;&#160;</a></span>createUnusedDeclarationEliminationPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; mlir::Pass &gt; llzk::createUnusedDeclarationEliminationPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_l_l_z_k_unused_declaration_elimination_pass_8cpp_source.html#l00237">237</a> of file <a class="el" href="_l_l_z_k_unused_declaration_elimination_pass_8cpp_source.html">LLZKUnusedDeclarationEliminationPass.cpp</a>.</p>

</div>
</div>
<a id="a1340324912450274219eaa15bac66362" name="a1340324912450274219eaa15bac66362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1340324912450274219eaa15bac66362">&#9670;&#160;</a></span>delegate_to_build()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OpType, typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OpType llzk::delegate_to_build </td>
          <td>(</td>
          <td class="paramtype">mlir::Location</td>          <td class="paramname"><span class="paramname"><em>location</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_builder_helper_8h_source.html#l00018">18</a> of file <a class="el" href="_builder_helper_8h_source.html">BuilderHelper.h</a>.</p>

</div>
</div>
<a id="a0949b4dc945939f8fed321b9e93c9684" name="a0949b4dc945939f8fed321b9e93c9684"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0949b4dc945939f8fed321b9e93c9684">&#9670;&#160;</a></span>div()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllzk_1_1_expression_value.html">ExpressionValue</a> llzk::div </td>
          <td>(</td>
          <td class="paramtype">llvm::SMTSolverRef</td>          <td class="paramname"><span class="paramname"><em>solver</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllzk_1_1felt_1_1_div_felt_op.html">felt::DivFeltOp</a></td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classllzk_1_1_expression_value.html">ExpressionValue</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classllzk_1_1_expression_value.html">ExpressionValue</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_interval_analysis_8cpp_source.html#l00509">509</a> of file <a class="el" href="_interval_analysis_8cpp_source.html">IntervalAnalysis.cpp</a>.</p>

</div>
</div>
<a id="a7075ec348ed9ce9776df5b52acb8a1b2" name="a7075ec348ed9ce9776df5b52acb8a1b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7075ec348ed9ce9776df5b52acb8a1b2">&#9670;&#160;</a></span>ensure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void llzk::ensure </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>condition</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Twine</td>          <td class="paramname"><span class="paramname"><em>errMsg</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_error_helper_8h_source.html#l00032">32</a> of file <a class="el" href="_error_helper_8h_source.html">ErrorHelper.h</a>.</p>

</div>
</div>
<a id="a44afaec28adf69a4547eab55e5c65cbe" name="a44afaec28adf69a4547eab55e5c65cbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44afaec28adf69a4547eab55e5c65cbe">&#9670;&#160;</a></span>expandingAdd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::APSInt llzk::expandingAdd </td>
          <td>(</td>
          <td class="paramtype">const llvm::APSInt &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::APSInt &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Safely add lhs and rhs, expanding the width of the result as necessary. </p>
<p>Numbers are never truncated here, as this assumes that truncation will occur with the reduction to the prime field. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>an N bit number with an allocated width of X </td></tr>
    <tr><td class="paramname">rhs</td><td>an M bit number with an allocated width of Y </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A number that is max(N, M) + 1 bits wide with an allocated with of max(max(N, M) + 1, X, Y) bits. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_a_p_int_helper_8cpp_source.html#l00014">14</a> of file <a class="el" href="_a_p_int_helper_8cpp_source.html">APIntHelper.cpp</a>.</p>

</div>
</div>
<a id="a79f6018c1853e974f7cadc0e3ba4b363" name="a79f6018c1853e974f7cadc0e3ba4b363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79f6018c1853e974f7cadc0e3ba4b363">&#9670;&#160;</a></span>expandingMul()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::APSInt llzk::expandingMul </td>
          <td>(</td>
          <td class="paramtype">const llvm::APSInt &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::APSInt &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Safely multiple lhs and rhs, expanding the width of the result as necessary. </p>
<p>Numbers are never truncated here, as this assumes that truncation will occur with the reduction to the prime field. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>an N bit number with an allocated width of X </td></tr>
    <tr><td class="paramname">rhs</td><td>an M bit number with an allocated width of Y </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A number that is N + M bits wide with an allocated with of max(N + M, X, Y) bits. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_a_p_int_helper_8cpp_source.html#l00026">26</a> of file <a class="el" href="_a_p_int_helper_8cpp_source.html">APIntHelper.cpp</a>.</p>

</div>
</div>
<a id="a13e9b9e2292a93b9f0e116c399f42cfd" name="a13e9b9e2292a93b9f0e116c399f42cfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13e9b9e2292a93b9f0e116c399f42cfd">&#9670;&#160;</a></span>expandingSub()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::APSInt llzk::expandingSub </td>
          <td>(</td>
          <td class="paramtype">const llvm::APSInt &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::APSInt &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Safely subtract lhs and rhs, expanding the width of the result as necessary. </p>
<p>Numbers are never truncated here, as this assumes that truncation will occur with the reduction to the prime field. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>an N bit number with an allocated width of X </td></tr>
    <tr><td class="paramname">rhs</td><td>an M bit number with an allocated width of Y </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A number that is max(N, M) + 1 bits wide with an allocated with of max(max(N, M) + 1, X, Y) bits. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_a_p_int_helper_8cpp_source.html#l00020">20</a> of file <a class="el" href="_a_p_int_helper_8cpp_source.html">APIntHelper.cpp</a>.</p>

</div>
</div>
<a id="ac4ac563acc740dbd4b5989188cb54203" name="ac4ac563acc740dbd4b5989188cb54203"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4ac563acc740dbd4b5989188cb54203">&#9670;&#160;</a></span>fallbackBinaryOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllzk_1_1_expression_value.html">ExpressionValue</a> llzk::fallbackBinaryOp </td>
          <td>(</td>
          <td class="paramtype">llvm::SMTSolverRef</td>          <td class="paramname"><span class="paramname"><em>solver</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Operation *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classllzk_1_1_expression_value.html">ExpressionValue</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classllzk_1_1_expression_value.html">ExpressionValue</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_interval_analysis_8cpp_source.html#l00562">562</a> of file <a class="el" href="_interval_analysis_8cpp_source.html">IntervalAnalysis.cpp</a>.</p>

</div>
</div>
<a id="af3bdbdf664bef76f70ff55c971b36618" name="af3bdbdf664bef76f70ff55c971b36618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3bdbdf664bef76f70ff55c971b36618">&#9670;&#160;</a></span>fallbackUnaryOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllzk_1_1_expression_value.html">ExpressionValue</a> llzk::fallbackUnaryOp </td>
          <td>(</td>
          <td class="paramtype">llvm::SMTSolverRef</td>          <td class="paramname"><span class="paramname"><em>solver</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Operation *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classllzk_1_1_expression_value.html">ExpressionValue</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_interval_analysis_8cpp_source.html#l00607">607</a> of file <a class="el" href="_interval_analysis_8cpp_source.html">IntervalAnalysis.cpp</a>.</p>

</div>
</div>
<a id="ad905c6fd289dd14f402fd8869e19eaa5" name="ad905c6fd289dd14f402fd8869e19eaa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad905c6fd289dd14f402fd8869e19eaa5">&#9670;&#160;</a></span>forceIntAttrType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Attribute llzk::forceIntAttrType </td>
          <td>(</td>
          <td class="paramtype">Attribute</td>          <td class="paramname"><span class="paramname"><em>attr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_type_helper_8cpp_source.html#l00722">722</a> of file <a class="el" href="_type_helper_8cpp_source.html">TypeHelper.cpp</a>.</p>

</div>
</div>
<a id="a2c6052a9b69960f0d3ee8c6070f26cc2" name="a2c6052a9b69960f0d3ee8c6070f26cc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c6052a9b69960f0d3ee8c6070f26cc2">&#9670;&#160;</a></span>forceIntAttrType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mlir::Attribute llzk::forceIntAttrType </td>
          <td>(</td>
          <td class="paramtype">mlir::Attribute</td>          <td class="paramname"><span class="paramname"><em>attr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert any IntegerAttr with a type other than IndexType to use IndexType. </p>

</div>
</div>
<a id="a45a9b85ac8a1f42ff830be63be64e36a" name="a45a9b85ac8a1f42ff830be63be64e36a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45a9b85ac8a1f42ff830be63be64e36a">&#9670;&#160;</a></span>forceIntAttrTypes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SmallVector&lt; Attribute &gt; llzk::forceIntAttrTypes </td>
          <td>(</td>
          <td class="paramtype">ArrayRef&lt; Attribute &gt;</td>          <td class="paramname"><span class="paramname"><em>attrList</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_type_helper_8cpp_source.html#l00729">729</a> of file <a class="el" href="_type_helper_8cpp_source.html">TypeHelper.cpp</a>.</p>

</div>
</div>
<a id="a60d13ac1b35c29b7e5549650e6c52180" name="a60d13ac1b35c29b7e5549650e6c52180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60d13ac1b35c29b7e5549650e6c52180">&#9670;&#160;</a></span>forceIntAttrTypes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::SmallVector&lt; mlir::Attribute &gt; llzk::forceIntAttrTypes </td>
          <td>(</td>
          <td class="paramtype">llvm::ArrayRef&lt; mlir::Attribute &gt;</td>          <td class="paramname"><span class="paramname"><em>attrList</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert any IntegerAttr with a type other than IndexType to use IndexType. </p>

</div>
</div>
<a id="ae04cf4a8e665a844e816c29283f31633" name="ae04cf4a8e665a844e816c29283f31633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae04cf4a8e665a844e816c29283f31633">&#9670;&#160;</a></span>forceIntType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IntegerAttr llzk::forceIntType </td>
          <td>(</td>
          <td class="paramtype">IntegerAttr</td>          <td class="paramname"><span class="paramname"><em>attr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_type_helper_8cpp_source.html#l00715">715</a> of file <a class="el" href="_type_helper_8cpp_source.html">TypeHelper.cpp</a>.</p>

</div>
</div>
<a id="a0a80f06bcaf7eec2f949aac5fa734f5b" name="a0a80f06bcaf7eec2f949aac5fa734f5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a80f06bcaf7eec2f949aac5fa734f5b">&#9670;&#160;</a></span>forceIntType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mlir::IntegerAttr llzk::forceIntType </td>
          <td>(</td>
          <td class="paramtype">mlir::IntegerAttr</td>          <td class="paramname"><span class="paramname"><em>attr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an IntegerAttr with a type other than IndexType to use IndexType. </p>

</div>
</div>
<a id="ae2cda245bd6615365454ebd762a24d29" name="ae2cda245bd6615365454ebd762a24d29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2cda245bd6615365454ebd762a24d29">&#9670;&#160;</a></span>fromAPInt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t llzk::fromAPInt </td>
          <td>(</td>
          <td class="paramtype">llvm::APInt</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_attribute_helper_8h_source.html#l00032">32</a> of file <a class="el" href="_attribute_helper_8h_source.html">AttributeHelper.h</a>.</p>

</div>
</div>
<a id="a8b72620c55defe1f3d66eda8fac6e0e7" name="a8b72620c55defe1f3d66eda8fac6e0e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b72620c55defe1f3d66eda8fac6e0e7">&#9670;&#160;</a></span>getAtIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TypeClass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TypeClass llzk::getAtIndex </td>
          <td>(</td>
          <td class="paramtype">mlir::TypeRange</td>          <td class="paramname"><span class="paramname"><em>types</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_type_helper_8h_source.html#l00233">233</a> of file <a class="el" href="_type_helper_8h_source.html">TypeHelper.h</a>.</p>

</div>
</div>
<a id="a9b8e8dff43891ffe5045760d87d2899b" name="a9b8e8dff43891ffe5045760d87d2899b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b8e8dff43891ffe5045760d87d2899b">&#9670;&#160;</a></span>getEmitOpErrFn() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a7357b1ebd2b125f62a0a2fd3bf559af1">OwningEmitErrorFn</a> llzk::getEmitOpErrFn </td>
          <td>(</td>
          <td class="paramtype">mlir::Operation *</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_error_helper_8h_source.html#l00024">24</a> of file <a class="el" href="_error_helper_8h_source.html">ErrorHelper.h</a>.</p>

</div>
</div>
<a id="a2caf8eb59f64db262f24d563f6a16a0e" name="a2caf8eb59f64db262f24d563f6a16a0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2caf8eb59f64db262f24d563f6a16a0e">&#9670;&#160;</a></span>getEmitOpErrFn() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TypeClass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a7357b1ebd2b125f62a0a2fd3bf559af1">OwningEmitErrorFn</a> llzk::getEmitOpErrFn </td>
          <td>(</td>
          <td class="paramtype">TypeClass *</td>          <td class="paramname"><span class="paramname"><em>opImpl</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_error_helper_8h_source.html#l00028">28</a> of file <a class="el" href="_error_helper_8h_source.html">ErrorHelper.h</a>.</p>

</div>
</div>
<a id="a301a571a8339726388d6173ba81b5283" name="a301a571a8339726388d6173ba81b5283"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a301a571a8339726388d6173ba81b5283">&#9670;&#160;</a></span>getFlatSymbolRefAttr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::FlatSymbolRefAttr llzk::getFlatSymbolRefAttr </td>
          <td>(</td>
          <td class="paramtype">mlir::MLIRContext *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mlir::Twine &amp;</td>          <td class="paramname"><span class="paramname"><em>twine</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a FlatSymbolRefAttr with the given content. </p>

<p class="definition">Definition at line <a class="el" href="_symbol_helper_8h_source.html#l00034">34</a> of file <a class="el" href="_symbol_helper_8h_source.html">SymbolHelper.h</a>.</p>

</div>
</div>
<a id="a374eec2da9f2f274eabc9dd54d33f27c" name="a374eec2da9f2f274eabc9dd54d33f27c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a374eec2da9f2f274eabc9dd54d33f27c">&#9670;&#160;</a></span>getIfSingleton()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TypeClass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TypeClass llzk::getIfSingleton </td>
          <td>(</td>
          <td class="paramtype">mlir::TypeRange</td>          <td class="paramname"><span class="paramname"><em>types</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_type_helper_8h_source.html#l00229">229</a> of file <a class="el" href="_type_helper_8h_source.html">TypeHelper.h</a>.</p>

</div>
</div>
<a id="a8a4057e4e77ea614edbcee1fba37b30a" name="a8a4057e4e77ea614edbcee1fba37b30a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a4057e4e77ea614edbcee1fba37b30a">&#9670;&#160;</a></span>getNames() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::SmallVector&lt; mlir::StringRef &gt; llzk::getNames </td>
          <td>(</td>
          <td class="paramtype">mlir::SymbolRefAttr</td>          <td class="paramname"><span class="paramname"><em>ref</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3395beb30b5d17bc8a968b14eb3638d6" name="a3395beb30b5d17bc8a968b14eb3638d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3395beb30b5d17bc8a968b14eb3638d6">&#9670;&#160;</a></span>getNames() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::SmallVector&lt; StringRef &gt; llzk::getNames </td>
          <td>(</td>
          <td class="paramtype">SymbolRefAttr</td>          <td class="paramname"><span class="paramname"><em>ref</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_symbol_helper_8cpp_source.html#l00138">138</a> of file <a class="el" href="_symbol_helper_8cpp_source.html">SymbolHelper.cpp</a>.</p>

</div>
</div>
<a id="ace40014709812c1c57cb0aa39b87558b" name="ace40014709812c1c57cb0aa39b87558b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace40014709812c1c57cb0aa39b87558b">&#9670;&#160;</a></span>getOperationName()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OpType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::StringLiteral llzk::getOperationName </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the operation name, like "constrain.eq" for the given OpType. </p>
<p>This function can be used when the compiler would complain about incomplete types if <code>OpType::getOperationName()</code> were called directly. </p>

<p class="definition">Definition at line <a class="el" href="_op_helpers_8h_source.html#l00027">27</a> of file <a class="el" href="_op_helpers_8h_source.html">OpHelpers.h</a>.</p>

</div>
</div>
<a id="ae01374002b3f4f48046cccee2a7087e4" name="ae01374002b3f4f48046cccee2a7087e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae01374002b3f4f48046cccee2a7087e4">&#9670;&#160;</a></span>getParentOfType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OpType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::FailureOr&lt; OpType &gt; llzk::getParentOfType </td>
          <td>(</td>
          <td class="paramtype">mlir::Operation *</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the closest surrounding parent operation that is of type 'OpType'. </p>

<p class="definition">Definition at line <a class="el" href="_op_helpers_8h_source.html#l00032">32</a> of file <a class="el" href="_op_helpers_8h_source.html">OpHelpers.h</a>.</p>

</div>
</div>
<a id="ab257f68cb79cff1e1f3f992a3cd86168" name="ab257f68cb79cff1e1f3f992a3cd86168"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab257f68cb79cff1e1f3f992a3cd86168">&#9670;&#160;</a></span>getPathFromRoot() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mlir::FailureOr&lt; mlir::SymbolRefAttr &gt; llzk::getPathFromRoot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllzk_1_1function_1_1_func_def_op.html">FuncDefOp</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>to</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_symbol_helper_8cpp_source.html#l00208">208</a> of file <a class="el" href="_symbol_helper_8cpp_source.html">SymbolHelper.cpp</a>.</p>

</div>
</div>
<a id="a17e5f2ed35eb7b924e98864bc950b296" name="a17e5f2ed35eb7b924e98864bc950b296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17e5f2ed35eb7b924e98864bc950b296">&#9670;&#160;</a></span>getPathFromRoot() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mlir::FailureOr&lt; mlir::SymbolRefAttr &gt; llzk::getPathFromRoot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllzk_1_1component_1_1_struct_def_op.html">StructDefOp</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>to</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_symbol_helper_8cpp_source.html#l00204">204</a> of file <a class="el" href="_symbol_helper_8cpp_source.html">SymbolHelper.cpp</a>.</p>

</div>
</div>
<a id="a9ad8587acfbc58f9dd98165996cce8c7" name="a9ad8587acfbc58f9dd98165996cce8c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ad8587acfbc58f9dd98165996cce8c7">&#9670;&#160;</a></span>getPathFromTopRoot() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mlir::FailureOr&lt; mlir::SymbolRefAttr &gt; llzk::getPathFromTopRoot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllzk_1_1function_1_1_func_def_op.html">FuncDefOp</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>to</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_symbol_helper_8cpp_source.html#l00221">221</a> of file <a class="el" href="_symbol_helper_8cpp_source.html">SymbolHelper.cpp</a>.</p>

</div>
</div>
<a id="a75fdc2fe83e3eca6b6c048deac2b22ab" name="a75fdc2fe83e3eca6b6c048deac2b22ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75fdc2fe83e3eca6b6c048deac2b22ab">&#9670;&#160;</a></span>getPathFromTopRoot() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mlir::FailureOr&lt; mlir::SymbolRefAttr &gt; llzk::getPathFromTopRoot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllzk_1_1component_1_1_struct_def_op.html">StructDefOp</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>to</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_symbol_helper_8cpp_source.html#l00217">217</a> of file <a class="el" href="_symbol_helper_8cpp_source.html">SymbolHelper.cpp</a>.</p>

</div>
</div>
<a id="a2e5122183c36be89ee3a9b8df87b5223" name="a2e5122183c36be89ee3a9b8df87b5223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e5122183c36be89ee3a9b8df87b5223">&#9670;&#160;</a></span>getPieces() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::SmallVector&lt; mlir::FlatSymbolRefAttr &gt; llzk::getPieces </td>
          <td>(</td>
          <td class="paramtype">mlir::SymbolRefAttr</td>          <td class="paramname"><span class="paramname"><em>ref</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aefd24a67a7806996a53b63a5014c82a2" name="aefd24a67a7806996a53b63a5014c82a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefd24a67a7806996a53b63a5014c82a2">&#9670;&#160;</a></span>getPieces() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::SmallVector&lt; FlatSymbolRefAttr &gt; llzk::getPieces </td>
          <td>(</td>
          <td class="paramtype">SymbolRefAttr</td>          <td class="paramname"><span class="paramname"><em>ref</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_symbol_helper_8cpp_source.html#l00147">147</a> of file <a class="el" href="_symbol_helper_8cpp_source.html">SymbolHelper.cpp</a>.</p>

</div>
</div>
<a id="a0cc045d4128ed47c170ca4c017bf02f0" name="a0cc045d4128ed47c170ca4c017bf02f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cc045d4128ed47c170ca4c017bf02f0">&#9670;&#160;</a></span>getPrefixAsSymbolRefAttr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::SymbolRefAttr llzk::getPrefixAsSymbolRefAttr </td>
          <td>(</td>
          <td class="paramtype">mlir::SymbolRefAttr</td>          <td class="paramname"><span class="paramname"><em>symbol</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return SymbolRefAttr like the one given but with the leaf/final element removed. </p>

<p class="definition">Definition at line <a class="el" href="_symbol_helper_8h_source.html#l00059">59</a> of file <a class="el" href="_symbol_helper_8h_source.html">SymbolHelper.h</a>.</p>

</div>
</div>
<a id="a6c6b23d251765a4ab382acebfd6138fd" name="a6c6b23d251765a4ab382acebfd6138fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c6b23d251765a4ab382acebfd6138fd">&#9670;&#160;</a></span>getRootModule() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mlir::FailureOr&lt; mlir::ModuleOp &gt; llzk::getRootModule </td>
          <td>(</td>
          <td class="paramtype">mlir::Operation *</td>          <td class="paramname"><span class="paramname"><em>from</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a44fd8ecd88f8e6b80079bf6c1328412a" name="a44fd8ecd88f8e6b80079bf6c1328412a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44fd8ecd88f8e6b80079bf6c1328412a">&#9670;&#160;</a></span>getRootModule() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; ModuleOp &gt; llzk::getRootModule </td>
          <td>(</td>
          <td class="paramtype">Operation *</td>          <td class="paramname"><span class="paramname"><em>from</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_symbol_helper_8cpp_source.html#l00199">199</a> of file <a class="el" href="_symbol_helper_8cpp_source.html">SymbolHelper.cpp</a>.</p>

</div>
</div>
<a id="ad6a0f6fb78eb7be834847f3b789940d9" name="ad6a0f6fb78eb7be834847f3b789940d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6a0f6fb78eb7be834847f3b789940d9">&#9670;&#160;</a></span>getStructDef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllzk_1_1_symbol_lookup_result.html">SymbolLookupResult</a>&lt; <a class="el" href="classllzk_1_1component_1_1_struct_def_op.html">StructDefOp</a> &gt; llzk::getStructDef </td>
          <td>(</td>
          <td class="paramtype">mlir::SymbolTableCollection &amp;</td>          <td class="paramname"><span class="paramname"><em>tables</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mlir::ModuleOp</td>          <td class="paramname"><span class="paramname"><em>mod</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllzk_1_1component_1_1_struct_type.html">StructType</a></td>          <td class="paramname"><span class="paramname"><em>ty</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lookup a <code><a class="el" href="classllzk_1_1component_1_1_struct_def_op.html">StructDefOp</a></code> from a given <code><a class="el" href="classllzk_1_1component_1_1_struct_type.html">StructType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tables</td><td></td></tr>
    <tr><td class="paramname">mod</td><td></td></tr>
    <tr><td class="paramname">ty</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="classllzk_1_1_symbol_lookup_result.html">SymbolLookupResult</a></code> for the <code><a class="el" href="classllzk_1_1component_1_1_struct_def_op.html">StructDefOp</a></code> found. Note that returning the lookup result is important, as it may manage a ModuleOp if the struct is found via an include. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_constrain_ref_8cpp_source.html#l00076">76</a> of file <a class="el" href="_constrain_ref_8cpp_source.html">ConstrainRef.cpp</a>.</p>

</div>
</div>
<a id="ab8be495092bcd4acc4f4064a0e8ee703" name="ab8be495092bcd4acc4f4064a0e8ee703"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8be495092bcd4acc4f4064a0e8ee703">&#9670;&#160;</a></span>getTailAsSymbolRefAttr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::SymbolRefAttr llzk::getTailAsSymbolRefAttr </td>
          <td>(</td>
          <td class="paramtype">mlir::SymbolRefAttr</td>          <td class="paramname"><span class="paramname"><em>symbol</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return SymbolRefAttr like the one given but with the root/head element removed. </p>

<p class="definition">Definition at line <a class="el" href="_symbol_helper_8h_source.html#l00054">54</a> of file <a class="el" href="_symbol_helper_8h_source.html">SymbolHelper.h</a>.</p>

</div>
</div>
<a id="a6982559aa99cea04c0cf47ee38166ce2" name="a6982559aa99cea04c0cf47ee38166ce2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6982559aa99cea04c0cf47ee38166ce2">&#9670;&#160;</a></span>getTopRootModule() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mlir::FailureOr&lt; mlir::ModuleOp &gt; llzk::getTopRootModule </td>
          <td>(</td>
          <td class="paramtype">mlir::Operation *</td>          <td class="paramname"><span class="paramname"><em>from</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>With include statements, there may be root modules nested within other root modules. </p>
<p>This function resolves the topmost root module. </p>

</div>
</div>
<a id="a858ad75166540367bf85ae38bc875707" name="a858ad75166540367bf85ae38bc875707"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a858ad75166540367bf85ae38bc875707">&#9670;&#160;</a></span>getTopRootModule() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; ModuleOp &gt; llzk::getTopRootModule </td>
          <td>(</td>
          <td class="paramtype">Operation *</td>          <td class="paramname"><span class="paramname"><em>from</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_symbol_helper_8cpp_source.html#l00212">212</a> of file <a class="el" href="_symbol_helper_8cpp_source.html">SymbolHelper.cpp</a>.</p>

</div>
</div>
<a id="af218387a3d9b9824ec5b1d060d4989ea" name="af218387a3d9b9824ec5b1d060d4989ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af218387a3d9b9824ec5b1d060d4989ea">&#9670;&#160;</a></span>getUnknownLoc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::Location llzk::getUnknownLoc </td>
          <td>(</td>
          <td class="paramtype">mlir::MLIRContext *</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_builders_8h_source.html#l00025">25</a> of file <a class="el" href="_builders_8h_source.html">Builders.h</a>.</p>

</div>
</div>
<a id="a21a0759043e8fb39b7ccae07f0d788da" name="a21a0759043e8fb39b7ccae07f0d788da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21a0759043e8fb39b7ccae07f0d788da">&#9670;&#160;</a></span>hasAffineMapAttr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool llzk::hasAffineMapAttr </td>
          <td>(</td>
          <td class="paramtype">mlir::Type</td>          <td class="paramname"><span class="paramname"><em>type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return <code>true</code> iff the given type contains an AffineMapAttr. </p>

</div>
</div>
<a id="ae16625d8c85094fae24fb003012b2380" name="ae16625d8c85094fae24fb003012b2380"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae16625d8c85094fae24fb003012b2380">&#9670;&#160;</a></span>hasAffineMapAttr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool llzk::hasAffineMapAttr </td>
          <td>(</td>
          <td class="paramtype">Type</td>          <td class="paramname"><span class="paramname"><em>type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_type_helper_8cpp_source.html#l00449">449</a> of file <a class="el" href="_type_helper_8cpp_source.html">TypeHelper.cpp</a>.</p>

</div>
</div>
<a id="a7ccd56fcf180637d0cdf015d5a1d3350" name="a7ccd56fcf180637d0cdf015d5a1d3350"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ccd56fcf180637d0cdf015d5a1d3350">&#9670;&#160;</a></span>hasUsesWithin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool llzk::hasUsesWithin </td>
          <td>(</td>
          <td class="paramtype">mlir::Operation *</td>          <td class="paramname"><span class="paramname"><em>symbol</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mlir::Operation *</td>          <td class="paramname"><span class="paramname"><em>from</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to <code>SymbolTable::getSymbolUses(...).has_value()</code> but without fully computing uses. </p>

</div>
</div>
<a id="a2cb8dbb7c515a29aa35b18fb74516a42" name="a2cb8dbb7c515a29aa35b18fb74516a42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cb8dbb7c515a29aa35b18fb74516a42">&#9670;&#160;</a></span>hasUsesWithin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool llzk::hasUsesWithin </td>
          <td>(</td>
          <td class="paramtype">Operation *</td>          <td class="paramname"><span class="paramname"><em>symbol</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Operation *</td>          <td class="paramname"><span class="paramname"><em>from</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_symbol_helper_8cpp_source.html#l00225">225</a> of file <a class="el" href="_symbol_helper_8cpp_source.html">SymbolHelper.cpp</a>.</p>

</div>
</div>
<a id="acec2696fdf94e6c65ea2acd5863039b2" name="acec2696fdf94e6c65ea2acd5863039b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acec2696fdf94e6c65ea2acd5863039b2">&#9670;&#160;</a></span>intersection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllzk_1_1_expression_value.html">ExpressionValue</a> llzk::intersection </td>
          <td>(</td>
          <td class="paramtype">llvm::SMTSolverRef</td>          <td class="paramname"><span class="paramname"><em>solver</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classllzk_1_1_expression_value.html">ExpressionValue</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classllzk_1_1_expression_value.html">ExpressionValue</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">solver</td><td></td></tr>
    <tr><td class="paramname">lhs</td><td></td></tr>
    <tr><td class="paramname">rhs</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="definition">Definition at line <a class="el" href="_interval_analysis_8cpp_source.html#l00478">478</a> of file <a class="el" href="_interval_analysis_8cpp_source.html">IntervalAnalysis.cpp</a>.</p>

</div>
</div>
<a id="a9798d3afd220d09f46b40473781a6e86" name="a9798d3afd220d09f46b40473781a6e86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9798d3afd220d09f46b40473781a6e86">&#9670;&#160;</a></span>isConcreteType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool llzk::isConcreteType </td>
          <td>(</td>
          <td class="paramtype">mlir::Type</td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>allowStructParams</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return <code>false</code> iff the type contains any <code><a class="el" href="classllzk_1_1polymorphic_1_1_type_var_type.html">TypeVarType</a></code> </p>

</div>
</div>
<a id="a2bbb039982f4d0a01e53f8901fdaa34d" name="a2bbb039982f4d0a01e53f8901fdaa34d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bbb039982f4d0a01e53f8901fdaa34d">&#9670;&#160;</a></span>isConcreteType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool llzk::isConcreteType </td>
          <td>(</td>
          <td class="paramtype">Type</td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>allowStructParams</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_type_helper_8cpp_source.html#l00431">431</a> of file <a class="el" href="_type_helper_8cpp_source.html">TypeHelper.cpp</a>.</p>

</div>
</div>
<a id="aac04ef36bb784819019624d62b493ce6" name="aac04ef36bb784819019624d62b493ce6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac04ef36bb784819019624d62b493ce6">&#9670;&#160;</a></span>isDynamic() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool llzk::isDynamic </td>
          <td>(</td>
          <td class="paramtype">IntegerAttr</td>          <td class="paramname"><span class="paramname"><em>intAttr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_type_helper_8cpp_source.html#l00458">458</a> of file <a class="el" href="_type_helper_8cpp_source.html">TypeHelper.cpp</a>.</p>

</div>
</div>
<a id="a0112dda4887f249d668efa60a5646bdd" name="a0112dda4887f249d668efa60a5646bdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0112dda4887f249d668efa60a5646bdd">&#9670;&#160;</a></span>isDynamic() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool llzk::isDynamic </td>
          <td>(</td>
          <td class="paramtype">mlir::IntegerAttr</td>          <td class="paramname"><span class="paramname"><em>intAttr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afb284386fff71ad94c74a27f050076b8" name="afb284386fff71ad94c74a27f050076b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb284386fff71ad94c74a27f050076b8">&#9670;&#160;</a></span>isLocationLess()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;OpComparable Op&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">mlir::FailureOr&lt; bool &gt; llzk::isLocationLess </td>
          <td>(</td>
          <td class="paramtype">const Op &amp;</td>          <td class="paramname"><span class="paramname"><em>l</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Op &amp;</td>          <td class="paramname"><span class="paramname"><em>r</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_compare_8h_source.html#l00029">29</a> of file <a class="el" href="_compare_8h_source.html">Compare.h</a>.</p>

</div>
</div>
<a id="a1799d8cc9b704df606b1a99172014065" name="a1799d8cc9b704df606b1a99172014065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1799d8cc9b704df606b1a99172014065">&#9670;&#160;</a></span>isMoreConcreteUnification() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool llzk::isMoreConcreteUnification </td>
          <td>(</td>
          <td class="paramtype">mlir::Type</td>          <td class="paramname"><span class="paramname"><em>oldTy</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mlir::Type</td>          <td class="paramname"><span class="paramname"><em>newTy</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::function_ref&lt; bool(mlir::Type oldTy, mlir::Type newTy)&gt;</td>          <td class="paramname"><span class="paramname"><em>knownOldToNew</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return <code>true</code> iff the types unify and <code>newTy</code> is "more concrete" than <code>oldTy</code>. </p>
<p>The types <code>i1</code>, <code>index</code>, <code>felt.type</code>, and <code>string.type</code> are concrete whereas <code>poly.tvar</code> is not (because it may be substituted with any type during struct instantiation). When considering the attributes with <code>array.type</code> and <code>struct.type</code> types, we define IntegerAttr and TypeAttr as concrete, AffineMapAttr as less concrete than those, and SymbolRefAttr as least concrete. </p>

</div>
</div>
<a id="ac69242a61e4e25958e9c6e8fa0f8549e" name="ac69242a61e4e25958e9c6e8fa0f8549e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac69242a61e4e25958e9c6e8fa0f8549e">&#9670;&#160;</a></span>isMoreConcreteUnification() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool llzk::isMoreConcreteUnification </td>
          <td>(</td>
          <td class="paramtype">Type</td>          <td class="paramname"><span class="paramname"><em>oldTy</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type</td>          <td class="paramname"><span class="paramname"><em>newTy</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::function_ref&lt; bool(Type oldTy, Type newTy)&gt;</td>          <td class="paramname"><span class="paramname"><em>knownOldToNew</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_type_helper_8cpp_source.html#l00693">693</a> of file <a class="el" href="_type_helper_8cpp_source.html">TypeHelper.cpp</a>.</p>

</div>
</div>
<a id="a5a58995f554b579f9f32b1454376fa38" name="a5a58995f554b579f9f32b1454376fa38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a58995f554b579f9f32b1454376fa38">&#9670;&#160;</a></span>isNullOrEmpty() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool llzk::isNullOrEmpty </td>
          <td>(</td>
          <td class="paramtype">mlir::ArrayAttr</td>          <td class="paramname"><span class="paramname"><em>a</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_attribute_helper_8h_source.html#l00034">34</a> of file <a class="el" href="_attribute_helper_8h_source.html">AttributeHelper.h</a>.</p>

</div>
</div>
<a id="a89cd221cd3a7abc89c253af02c81538e" name="a89cd221cd3a7abc89c253af02c81538e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89cd221cd3a7abc89c253af02c81538e">&#9670;&#160;</a></span>isNullOrEmpty() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool llzk::isNullOrEmpty </td>
          <td>(</td>
          <td class="paramtype">mlir::DenseArrayAttr</td>          <td class="paramname"><span class="paramname"><em>a</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_attribute_helper_8h_source.html#l00035">35</a> of file <a class="el" href="_attribute_helper_8h_source.html">AttributeHelper.h</a>.</p>

</div>
</div>
<a id="a080b2e46f6958963ba7d1ff00b26fbc4" name="a080b2e46f6958963ba7d1ff00b26fbc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a080b2e46f6958963ba7d1ff00b26fbc4">&#9670;&#160;</a></span>isNullOrEmpty() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool llzk::isNullOrEmpty </td>
          <td>(</td>
          <td class="paramtype">mlir::DictionaryAttr</td>          <td class="paramname"><span class="paramname"><em>a</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_attribute_helper_8h_source.html#l00036">36</a> of file <a class="el" href="_attribute_helper_8h_source.html">AttributeHelper.h</a>.</p>

</div>
</div>
<a id="ae51f2b772ad6edd299f653e76d7deb33" name="ae51f2b772ad6edd299f653e76d7deb33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae51f2b772ad6edd299f653e76d7deb33">&#9670;&#160;</a></span>isSignalType() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool llzk::isSignalType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllzk_1_1component_1_1_struct_type.html">StructType</a></td>          <td class="paramname"><span class="paramname"><em>sType</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return <code>true</code> iff the given <a class="el" href="classllzk_1_1component_1_1_struct_type.html">StructType</a> is referencing the <code>COMPONENT_NAME_SIGNAL</code> struct. </p>

<p class="definition">Definition at line <a class="el" href="_type_helper_8cpp_source.html#l00442">442</a> of file <a class="el" href="_type_helper_8cpp_source.html">TypeHelper.cpp</a>.</p>

</div>
</div>
<a id="a810250b92231c248c7d345621436bed6" name="a810250b92231c248c7d345621436bed6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a810250b92231c248c7d345621436bed6">&#9670;&#160;</a></span>isSignalType() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool llzk::isSignalType </td>
          <td>(</td>
          <td class="paramtype">mlir::Type</td>          <td class="paramname"><span class="paramname"><em>type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return <code>true</code> iff the given type is a <a class="el" href="classllzk_1_1component_1_1_struct_type.html">StructType</a> referencing the <code>COMPONENT_NAME_SIGNAL</code> struct. </p>

</div>
</div>
<a id="aaf9dbea063159b9e1d23597d7854f224" name="aaf9dbea063159b9e1d23597d7854f224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf9dbea063159b9e1d23597d7854f224">&#9670;&#160;</a></span>isSignalType() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool llzk::isSignalType </td>
          <td>(</td>
          <td class="paramtype">Type</td>          <td class="paramname"><span class="paramname"><em>type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_type_helper_8cpp_source.html#l00435">435</a> of file <a class="el" href="_type_helper_8cpp_source.html">TypeHelper.cpp</a>.</p>

</div>
</div>
<a id="ab02ae76b4775530127301c9dcbd1b22f" name="ab02ae76b4775530127301c9dcbd1b22f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab02ae76b4775530127301c9dcbd1b22f">&#9670;&#160;</a></span>isValidArrayElemType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool llzk::isValidArrayElemType </td>
          <td>(</td>
          <td class="paramtype">mlir::Type</td>          <td class="paramname"><span class="paramname"><em>type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>valid types: <a class="el" href="#a8bdf8232394377a0c78dbd67d63d6764">isValidType()</a> - {<a class="el" href="classllzk_1_1array_1_1_array_type.html">ArrayType</a>} </p>

</div>
</div>
<a id="a2de2a95f4fd67e14caa528a032aa00a3" name="a2de2a95f4fd67e14caa528a032aa00a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2de2a95f4fd67e14caa528a032aa00a3">&#9670;&#160;</a></span>isValidArrayElemType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool llzk::isValidArrayElemType </td>
          <td>(</td>
          <td class="paramtype">Type</td>          <td class="paramname"><span class="paramname"><em>type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_type_helper_8cpp_source.html#l00427">427</a> of file <a class="el" href="_type_helper_8cpp_source.html">TypeHelper.cpp</a>.</p>

</div>
</div>
<a id="aaa4a1de20992b561a5506d6b4e629234" name="aaa4a1de20992b561a5506d6b4e629234"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa4a1de20992b561a5506d6b4e629234">&#9670;&#160;</a></span>isValidArrayType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool llzk::isValidArrayType </td>
          <td>(</td>
          <td class="paramtype">mlir::Type</td>          <td class="paramname"><span class="paramname"><em>type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the type is a LLZK Array and it also contains a valid LLZK type. </p>

</div>
</div>
<a id="a23b1909ae78d62ab7d8906197c2f486b" name="a23b1909ae78d62ab7d8906197c2f486b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23b1909ae78d62ab7d8906197c2f486b">&#9670;&#160;</a></span>isValidArrayType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool llzk::isValidArrayType </td>
          <td>(</td>
          <td class="paramtype">Type</td>          <td class="paramname"><span class="paramname"><em>type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_type_helper_8cpp_source.html#l00429">429</a> of file <a class="el" href="_type_helper_8cpp_source.html">TypeHelper.cpp</a>.</p>

</div>
</div>
<a id="af816e3b3d950e479f4eccc8ef62237df" name="af816e3b3d950e479f4eccc8ef62237df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af816e3b3d950e479f4eccc8ef62237df">&#9670;&#160;</a></span>isValidColumnType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool llzk::isValidColumnType </td>
          <td>(</td>
          <td class="paramtype">mlir::Type</td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mlir::SymbolTableCollection &amp;</td>          <td class="paramname"><span class="paramname"><em>symbolTable</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mlir::Operation *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>valid types: {<a class="el" href="classllzk_1_1felt_1_1_felt_type.html">FeltType</a>, <a class="el" href="classllzk_1_1component_1_1_struct_type.html">StructType</a> (with columns), <a class="el" href="classllzk_1_1array_1_1_array_type.html">ArrayType</a> (that contains a valid column type)} </p>

</div>
</div>
<a id="a4f47b3b9d1f45f35599782a8abaae2c4" name="a4f47b3b9d1f45f35599782a8abaae2c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f47b3b9d1f45f35599782a8abaae2c4">&#9670;&#160;</a></span>isValidColumnType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool llzk::isValidColumnType </td>
          <td>(</td>
          <td class="paramtype">Type</td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SymbolTableCollection &amp;</td>          <td class="paramname"><span class="paramname"><em>symbolTable</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Operation *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_type_helper_8cpp_source.html#l00412">412</a> of file <a class="el" href="_type_helper_8cpp_source.html">TypeHelper.cpp</a>.</p>

</div>
</div>
<a id="a1650252fbe1f1337fdb933a3cfacc3cf" name="a1650252fbe1f1337fdb933a3cfacc3cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1650252fbe1f1337fdb933a3cfacc3cf">&#9670;&#160;</a></span>isValidConstReadType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool llzk::isValidConstReadType </td>
          <td>(</td>
          <td class="paramtype">mlir::Type</td>          <td class="paramname"><span class="paramname"><em>type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>valid types: {I1, Index, <a class="el" href="classllzk_1_1felt_1_1_felt_type.html">FeltType</a>, <a class="el" href="classllzk_1_1polymorphic_1_1_type_var_type.html">TypeVarType</a>} </p>

</div>
</div>
<a id="afdc6a963256e586da485479d34e385dc" name="afdc6a963256e586da485479d34e385dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdc6a963256e586da485479d34e385dc">&#9670;&#160;</a></span>isValidConstReadType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool llzk::isValidConstReadType </td>
          <td>(</td>
          <td class="paramtype">Type</td>          <td class="paramname"><span class="paramname"><em>type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_type_helper_8cpp_source.html#l00423">423</a> of file <a class="el" href="_type_helper_8cpp_source.html">TypeHelper.cpp</a>.</p>

</div>
</div>
<a id="a84f2a1ccd00fcc70c93837e85228fe4b" name="a84f2a1ccd00fcc70c93837e85228fe4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84f2a1ccd00fcc70c93837e85228fe4b">&#9670;&#160;</a></span>isValidEmitEqType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool llzk::isValidEmitEqType </td>
          <td>(</td>
          <td class="paramtype">mlir::Type</td>          <td class="paramname"><span class="paramname"><em>type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>valid types: <a class="el" href="#a8bdf8232394377a0c78dbd67d63d6764">isValidType()</a> - {String, <a class="el" href="classllzk_1_1component_1_1_struct_type.html">StructType</a>} (excluded via any type parameter nesting) </p>

</div>
</div>
<a id="a7c0cb033d657913808724b49659466d8" name="a7c0cb033d657913808724b49659466d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c0cb033d657913808724b49659466d8">&#9670;&#160;</a></span>isValidEmitEqType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool llzk::isValidEmitEqType </td>
          <td>(</td>
          <td class="paramtype">Type</td>          <td class="paramname"><span class="paramname"><em>type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_type_helper_8cpp_source.html#l00418">418</a> of file <a class="el" href="_type_helper_8cpp_source.html">TypeHelper.cpp</a>.</p>

</div>
</div>
<a id="a952faa929c7417a608f0b0ac17138c5a" name="a952faa929c7417a608f0b0ac17138c5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a952faa929c7417a608f0b0ac17138c5a">&#9670;&#160;</a></span>isValidGlobalType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool llzk::isValidGlobalType </td>
          <td>(</td>
          <td class="paramtype">mlir::Type</td>          <td class="paramname"><span class="paramname"><em>type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>valid types: <a class="el" href="#a8bdf8232394377a0c78dbd67d63d6764">isValidType()</a> - {<a class="el" href="classllzk_1_1polymorphic_1_1_type_var_type.html">TypeVarType</a>} - {types with variable parameters} </p>

</div>
</div>
<a id="a3d9318e202b0ec0c363d3183734e5b6a" name="a3d9318e202b0ec0c363d3183734e5b6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d9318e202b0ec0c363d3183734e5b6a">&#9670;&#160;</a></span>isValidGlobalType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool llzk::isValidGlobalType </td>
          <td>(</td>
          <td class="paramtype">Type</td>          <td class="paramname"><span class="paramname"><em>type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_type_helper_8cpp_source.html#l00416">416</a> of file <a class="el" href="_type_helper_8cpp_source.html">TypeHelper.cpp</a>.</p>

</div>
</div>
<a id="aa7d4007c34cbea77abeab21c65e2bd5d" name="aa7d4007c34cbea77abeab21c65e2bd5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7d4007c34cbea77abeab21c65e2bd5d">&#9670;&#160;</a></span>isValidType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool llzk::isValidType </td>
          <td>(</td>
          <td class="paramtype">mlir::Type</td>          <td class="paramname"><span class="paramname"><em>type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>valid types: {I1, Index, String, <a class="el" href="classllzk_1_1felt_1_1_felt_type.html">FeltType</a>, <a class="el" href="classllzk_1_1component_1_1_struct_type.html">StructType</a>, <a class="el" href="classllzk_1_1array_1_1_array_type.html">ArrayType</a>, <a class="el" href="classllzk_1_1polymorphic_1_1_type_var_type.html">TypeVarType</a>} </p>

</div>
</div>
<a id="a8bdf8232394377a0c78dbd67d63d6764" name="a8bdf8232394377a0c78dbd67d63d6764"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bdf8232394377a0c78dbd67d63d6764">&#9670;&#160;</a></span>isValidType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool llzk::isValidType </td>
          <td>(</td>
          <td class="paramtype">Type</td>          <td class="paramname"><span class="paramname"><em>type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_type_helper_8cpp_source.html#l00410">410</a> of file <a class="el" href="_type_helper_8cpp_source.html">TypeHelper.cpp</a>.</p>

</div>
</div>
<a id="a59089c68acbe0a26928537e06040045b" name="a59089c68acbe0a26928537e06040045b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59089c68acbe0a26928537e06040045b">&#9670;&#160;</a></span>lookupSymbolIn() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::FailureOr&lt; <a class="el" href="classllzk_1_1_symbol_lookup_result.html">SymbolLookupResult</a>&lt; T &gt; &gt; llzk::lookupSymbolIn </td>
          <td>(</td>
          <td class="paramtype">mlir::SymbolTableCollection &amp;</td>          <td class="paramname"><span class="paramname"><em>tables</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mlir::SymbolRefAttr</td>          <td class="paramname"><span class="paramname"><em>symbol</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllzk_1_1_within.html">Within</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>lookupWithin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mlir::Operation *</td>          <td class="paramname"><span class="paramname"><em>origin</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_symbol_lookup_8h_source.html#l00142">142</a> of file <a class="el" href="_symbol_lookup_8h_source.html">SymbolLookup.h</a>.</p>

</div>
</div>
<a id="aa28c2948d69e2d33367e147f19cb29ce" name="aa28c2948d69e2d33367e147f19cb29ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa28c2948d69e2d33367e147f19cb29ce">&#9670;&#160;</a></span>lookupSymbolIn() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::FailureOr&lt; <a class="el" href="classllzk_1_1_symbol_lookup_result_untyped.html">SymbolLookupResultUntyped</a> &gt; llzk::lookupSymbolIn </td>
          <td>(</td>
          <td class="paramtype">mlir::SymbolTableCollection &amp;</td>          <td class="paramname"><span class="paramname"><em>tables</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mlir::SymbolRefAttr</td>          <td class="paramname"><span class="paramname"><em>symbol</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllzk_1_1_within.html">Within</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>lookupWithin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mlir::Operation *</td>          <td class="paramname"><span class="paramname"><em>origin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>reportMissing</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_symbol_lookup_8h_source.html#l00127">127</a> of file <a class="el" href="_symbol_lookup_8h_source.html">SymbolLookup.h</a>.</p>

</div>
</div>
<a id="a1815280653e16b67ab239ce1419f8c1c" name="a1815280653e16b67ab239ce1419f8c1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1815280653e16b67ab239ce1419f8c1c">&#9670;&#160;</a></span>lookupTopLevelSymbol() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::FailureOr&lt; <a class="el" href="classllzk_1_1_symbol_lookup_result.html">SymbolLookupResult</a>&lt; T &gt; &gt; llzk::lookupTopLevelSymbol </td>
          <td>(</td>
          <td class="paramtype">mlir::SymbolTableCollection &amp;</td>          <td class="paramname"><span class="paramname"><em>tables</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mlir::SymbolRefAttr</td>          <td class="paramname"><span class="paramname"><em>symbol</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mlir::Operation *</td>          <td class="paramname"><span class="paramname"><em>origin</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_symbol_lookup_8h_source.html#l00162">162</a> of file <a class="el" href="_symbol_lookup_8h_source.html">SymbolLookup.h</a>.</p>

</div>
</div>
<a id="a3073035b30825ce363ac236f14fe289a" name="a3073035b30825ce363ac236f14fe289a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3073035b30825ce363ac236f14fe289a">&#9670;&#160;</a></span>lookupTopLevelSymbol() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::FailureOr&lt; <a class="el" href="classllzk_1_1_symbol_lookup_result_untyped.html">SymbolLookupResultUntyped</a> &gt; llzk::lookupTopLevelSymbol </td>
          <td>(</td>
          <td class="paramtype">mlir::SymbolTableCollection &amp;</td>          <td class="paramname"><span class="paramname"><em>tables</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mlir::SymbolRefAttr</td>          <td class="paramname"><span class="paramname"><em>symbol</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mlir::Operation *</td>          <td class="paramname"><span class="paramname"><em>origin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>reportMissing</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_symbol_lookup_8h_source.html#l00134">134</a> of file <a class="el" href="_symbol_lookup_8h_source.html">SymbolLookup.h</a>.</p>

</div>
</div>
<a id="ad46fd35b4b51297b4c6f9ed6fe923b4e" name="ad46fd35b4b51297b4c6f9ed6fe923b4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad46fd35b4b51297b4c6f9ed6fe923b4e">&#9670;&#160;</a></span>mod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllzk_1_1_expression_value.html">ExpressionValue</a> llzk::mod </td>
          <td>(</td>
          <td class="paramtype">llvm::SMTSolverRef</td>          <td class="paramname"><span class="paramname"><em>solver</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classllzk_1_1_expression_value.html">ExpressionValue</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classllzk_1_1_expression_value.html">ExpressionValue</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_interval_analysis_8cpp_source.html#l00527">527</a> of file <a class="el" href="_interval_analysis_8cpp_source.html">IntervalAnalysis.cpp</a>.</p>

</div>
</div>
<a id="a61c3eb680cebfce54212fc0643edc731" name="a61c3eb680cebfce54212fc0643edc731"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61c3eb680cebfce54212fc0643edc731">&#9670;&#160;</a></span>mul()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllzk_1_1_expression_value.html">ExpressionValue</a> llzk::mul </td>
          <td>(</td>
          <td class="paramtype">llvm::SMTSolverRef</td>          <td class="paramname"><span class="paramname"><em>solver</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classllzk_1_1_expression_value.html">ExpressionValue</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classllzk_1_1_expression_value.html">ExpressionValue</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_interval_analysis_8cpp_source.html#l00501">501</a> of file <a class="el" href="_interval_analysis_8cpp_source.html">IntervalAnalysis.cpp</a>.</p>

</div>
</div>
<a id="acc7ec18ae2ac3dba2aa3e969d291e687" name="acc7ec18ae2ac3dba2aa3e969d291e687"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc7ec18ae2ac3dba2aa3e969d291e687">&#9670;&#160;</a></span>neg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllzk_1_1_expression_value.html">ExpressionValue</a> llzk::neg </td>
          <td>(</td>
          <td class="paramtype">llvm::SMTSolverRef</td>          <td class="paramname"><span class="paramname"><em>solver</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classllzk_1_1_expression_value.html">ExpressionValue</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_interval_analysis_8cpp_source.html#l00584">584</a> of file <a class="el" href="_interval_analysis_8cpp_source.html">IntervalAnalysis.cpp</a>.</p>

</div>
</div>
<a id="ae690ef2a4497229e66730a3c8ae84e0c" name="ae690ef2a4497229e66730a3c8ae84e0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae690ef2a4497229e66730a3c8ae84e0c">&#9670;&#160;</a></span>notOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllzk_1_1_expression_value.html">ExpressionValue</a> llzk::notOp </td>
          <td>(</td>
          <td class="paramtype">llvm::SMTSolverRef</td>          <td class="paramname"><span class="paramname"><em>solver</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classllzk_1_1_expression_value.html">ExpressionValue</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_interval_analysis_8cpp_source.html#l00591">591</a> of file <a class="el" href="_interval_analysis_8cpp_source.html">IntervalAnalysis.cpp</a>.</p>

</div>
</div>
<a id="a55d0cf465a99fe73abdc138f5ba0815f" name="a55d0cf465a99fe73abdc138f5ba0815f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55d0cf465a99fe73abdc138f5ba0815f">&#9670;&#160;</a></span>operator%()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllzk_1_1_interval.html">Interval</a> llzk::operator% </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classllzk_1_1_interval.html">Interval</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classllzk_1_1_interval.html">Interval</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_interval_analysis_8cpp_source.html#l00448">448</a> of file <a class="el" href="_interval_analysis_8cpp_source.html">IntervalAnalysis.cpp</a>.</p>

</div>
</div>
<a id="a06bf01ff7ac76db96afcaadea1fd29c1" name="a06bf01ff7ac76db96afcaadea1fd29c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06bf01ff7ac76db96afcaadea1fd29c1">&#9670;&#160;</a></span>operator*() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllzk_1_1_interval.html">Interval</a> llzk::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classllzk_1_1_interval.html">Interval</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classllzk_1_1_interval.html">Interval</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_interval_analysis_8cpp_source.html#l00416">416</a> of file <a class="el" href="_interval_analysis_8cpp_source.html">IntervalAnalysis.cpp</a>.</p>

</div>
</div>
<a id="abade7b1a147e413c2cddee3e147d6e18" name="abade7b1a147e413c2cddee3e147d6e18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abade7b1a147e413c2cddee3e147d6e18">&#9670;&#160;</a></span>operator*() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllzk_1_1_unreduced_interval.html">UnreducedInterval</a> llzk::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classllzk_1_1_unreduced_interval.html">UnreducedInterval</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classllzk_1_1_unreduced_interval.html">UnreducedInterval</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_interval_analysis_8cpp_source.html#l00159">159</a> of file <a class="el" href="_interval_analysis_8cpp_source.html">IntervalAnalysis.cpp</a>.</p>

</div>
</div>
<a id="a40449a39011029007b6c1b32e0537d51" name="a40449a39011029007b6c1b32e0537d51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40449a39011029007b6c1b32e0537d51">&#9670;&#160;</a></span>operator+() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllzk_1_1_interval.html">Interval</a> llzk::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classllzk_1_1_interval.html">Interval</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classllzk_1_1_interval.html">Interval</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_interval_analysis_8cpp_source.html#l00409">409</a> of file <a class="el" href="_interval_analysis_8cpp_source.html">IntervalAnalysis.cpp</a>.</p>

</div>
</div>
<a id="ad13198c26cc750d881f4b0e53a5955a8" name="ad13198c26cc750d881f4b0e53a5955a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad13198c26cc750d881f4b0e53a5955a8">&#9670;&#160;</a></span>operator+() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllzk_1_1_unreduced_interval.html">UnreducedInterval</a> llzk::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classllzk_1_1_unreduced_interval.html">UnreducedInterval</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classllzk_1_1_unreduced_interval.html">UnreducedInterval</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_interval_analysis_8cpp_source.html#l00150">150</a> of file <a class="el" href="_interval_analysis_8cpp_source.html">IntervalAnalysis.cpp</a>.</p>

</div>
</div>
<a id="acdac41547ae59c95df683ecca710db95" name="acdac41547ae59c95df683ecca710db95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdac41547ae59c95df683ecca710db95">&#9670;&#160;</a></span>operator-() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllzk_1_1_interval.html">Interval</a> llzk::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classllzk_1_1_interval.html">Interval</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classllzk_1_1_interval.html">Interval</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_interval_analysis_8cpp_source.html#l00414">414</a> of file <a class="el" href="_interval_analysis_8cpp_source.html">IntervalAnalysis.cpp</a>.</p>

</div>
</div>
<a id="a92d9e6ddc8de341fe1c6799854ba6585" name="a92d9e6ddc8de341fe1c6799854ba6585"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92d9e6ddc8de341fe1c6799854ba6585">&#9670;&#160;</a></span>operator-() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllzk_1_1_unreduced_interval.html">UnreducedInterval</a> llzk::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classllzk_1_1_unreduced_interval.html">UnreducedInterval</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classllzk_1_1_unreduced_interval.html">UnreducedInterval</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_interval_analysis_8cpp_source.html#l00155">155</a> of file <a class="el" href="_interval_analysis_8cpp_source.html">IntervalAnalysis.cpp</a>.</p>

</div>
</div>
<a id="a54bf00755ecf536427677ca6f0ecffcf" name="a54bf00755ecf536427677ca6f0ecffcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54bf00755ecf536427677ca6f0ecffcf">&#9670;&#160;</a></span>operator/()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classllzk_1_1_interval.html">Interval</a> &gt; llzk::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classllzk_1_1_interval.html">Interval</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classllzk_1_1_interval.html">Interval</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_interval_analysis_8cpp_source.html#l00436">436</a> of file <a class="el" href="_interval_analysis_8cpp_source.html">IntervalAnalysis.cpp</a>.</p>

</div>
</div>
<a id="a0c811a1921fe5348e526e41525f1baf5" name="a0c811a1921fe5348e526e41525f1baf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c811a1921fe5348e526e41525f1baf5">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::raw_ostream &amp; llzk::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">llvm::raw_ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classllzk_1_1_constrain_ref_lattice.html">ConstrainRefLattice</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lattice</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_constrain_ref_lattice_8cpp_source.html#l00236">236</a> of file <a class="el" href="_constrain_ref_lattice_8cpp_source.html">ConstrainRefLattice.cpp</a>.</p>

</div>
</div>
<a id="a1532c216a389f0b2852d1673bd153f8a" name="a1532c216a389f0b2852d1673bd153f8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1532c216a389f0b2852d1673bd153f8a">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mlir::raw_ostream &amp; llzk::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">mlir::raw_ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classllzk_1_1_constrain_ref.html">ConstrainRef</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_constrain_ref_8cpp_source.html#l00371">371</a> of file <a class="el" href="_constrain_ref_8cpp_source.html">ConstrainRef.cpp</a>.</p>

</div>
</div>
<a id="adbf201c6da5261a21b1d31970bc71da0" name="adbf201c6da5261a21b1d31970bc71da0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbf201c6da5261a21b1d31970bc71da0">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mlir::raw_ostream &amp; llzk::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">mlir::raw_ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classllzk_1_1_constrain_ref_lattice_value.html">ConstrainRefLatticeValue</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_constrain_ref_lattice_8cpp_source.html#l00167">167</a> of file <a class="el" href="_constrain_ref_lattice_8cpp_source.html">ConstrainRefLattice.cpp</a>.</p>

</div>
</div>
<a id="a382c1e1748ae2213b67f93dfc08becac" name="a382c1e1748ae2213b67f93dfc08becac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a382c1e1748ae2213b67f93dfc08becac">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mlir::raw_ostream &amp; llzk::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">mlir::raw_ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classllzk_1_1_constrain_ref_set.html">ConstrainRefSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_constrain_ref_8cpp_source.html#l00383">383</a> of file <a class="el" href="_constrain_ref_8cpp_source.html">ConstrainRef.cpp</a>.</p>

</div>
</div>
<a id="a8e9a147744897bef293d3a64a10dedc0" name="a8e9a147744897bef293d3a64a10dedc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e9a147744897bef293d3a64a10dedc0">&#9670;&#160;</a></span>operator&lt;=&gt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::strong_ordering llzk::operator&lt;=&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classllzk_1_1_unreduced_interval.html">UnreducedInterval</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classllzk_1_1_unreduced_interval.html">UnreducedInterval</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_interval_analysis_8cpp_source.html#l00175">175</a> of file <a class="el" href="_interval_analysis_8cpp_source.html">IntervalAnalysis.cpp</a>.</p>

</div>
</div>
<a id="a6f3fe746926910eac20e7c7eeee63e3a" name="a6f3fe746926910eac20e7c7eeee63e3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f3fe746926910eac20e7c7eeee63e3a">&#9670;&#160;</a></span>parseAttrDictWithWarnings()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::ParseResult llzk::parseAttrDictWithWarnings </td>
          <td>(</td>
          <td class="paramtype">mlir::OpAsmParser &amp;</td>          <td class="paramname"><span class="paramname"><em>parser</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mlir::NamedAttrList &amp;</td>          <td class="paramname"><span class="paramname"><em>extraAttrs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mlir::OperationState &amp;</td>          <td class="paramname"><span class="paramname"><em>state</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_op_helpers_8h_source.html#l00109">109</a> of file <a class="el" href="_op_helpers_8h_source.html">OpHelpers.h</a>.</p>

</div>
</div>
<a id="ad5a2121be9e3d0627cae5e297852772b" name="ad5a2121be9e3d0627cae5e297852772b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5a2121be9e3d0627cae5e297852772b">&#9670;&#160;</a></span>parseDimAndSymbolList()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::ParseResult llzk::parseDimAndSymbolList </td>
          <td>(</td>
          <td class="paramtype">mlir::OpAsmParser &amp;</td>          <td class="paramname"><span class="paramname"><em>parser</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mlir::SmallVector&lt; mlir::OpAsmParser::UnresolvedOperand, N &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>mapOperands</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mlir::IntegerAttr &amp;</td>          <td class="paramname"><span class="paramname"><em>numDims</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_op_helpers_8h_source.html#l00079">79</a> of file <a class="el" href="_op_helpers_8h_source.html">OpHelpers.h</a>.</p>

</div>
</div>
<a id="acb80626795a01a586c626bb1cb366a6d" name="acb80626795a01a586c626bb1cb366a6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb80626795a01a586c626bb1cb366a6d">&#9670;&#160;</a></span>parseMultiDimAndSymbolList()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::ParseResult llzk::parseMultiDimAndSymbolList </td>
          <td>(</td>
          <td class="paramtype">mlir::OpAsmParser &amp;</td>          <td class="paramname"><span class="paramname"><em>parser</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mlir::SmallVector&lt; mlir::SmallVector&lt; mlir::OpAsmParser::UnresolvedOperand &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>multiMapOperands</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mlir::DenseI32ArrayAttr &amp;</td>          <td class="paramname"><span class="paramname"><em>numDimsPerMap</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_op_helpers_8h_source.html#l00094">94</a> of file <a class="el" href="_op_helpers_8h_source.html">OpHelpers.h</a>.</p>

</div>
</div>
<a id="aafb94145f42dd37435e37c9ce4b805a2" name="aafb94145f42dd37435e37c9ce4b805a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafb94145f42dd37435e37c9ce4b805a2">&#9670;&#160;</a></span>printAttrDictWithWarnings()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConcreteOp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void llzk::printAttrDictWithWarnings </td>
          <td>(</td>
          <td class="paramtype">mlir::OpAsmPrinter &amp;</td>          <td class="paramname"><span class="paramname"><em>printer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConcreteOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mlir::DictionaryAttr</td>          <td class="paramname"><span class="paramname"><em>extraAttrs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename mlir::PropertiesSelector&lt; ConcreteOp &gt;::type</td>          <td class="paramname"><span class="paramname"><em>state</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_op_helpers_8h_source.html#l00116">116</a> of file <a class="el" href="_op_helpers_8h_source.html">OpHelpers.h</a>.</p>

</div>
</div>
<a id="a47e44fbda81e2f164ab37d3696457eff" name="a47e44fbda81e2f164ab37d3696457eff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47e44fbda81e2f164ab37d3696457eff">&#9670;&#160;</a></span>printAttrs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void llzk::printAttrs </td>
          <td>(</td>
          <td class="paramtype">AsmPrinter &amp;</td>          <td class="paramname"><span class="paramname"><em>printer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayRef&lt; Attribute &gt;</td>          <td class="paramname"><span class="paramname"><em>attrs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringRef &amp;</td>          <td class="paramname"><span class="paramname"><em>separator</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_attribute_helper_8cpp_source.html#l00018">18</a> of file <a class="el" href="_attribute_helper_8cpp_source.html">AttributeHelper.cpp</a>.</p>

</div>
</div>
<a id="ab3aea79f1ec3c694d5d0bcf1f949c5fe" name="ab3aea79f1ec3c694d5d0bcf1f949c5fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3aea79f1ec3c694d5d0bcf1f949c5fe">&#9670;&#160;</a></span>printAttrs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void llzk::printAttrs </td>
          <td>(</td>
          <td class="paramtype">mlir::AsmPrinter &amp;</td>          <td class="paramname"><span class="paramname"><em>printer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mlir::ArrayRef&lt; mlir::Attribute &gt;</td>          <td class="paramname"><span class="paramname"><em>attrs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mlir::StringRef &amp;</td>          <td class="paramname"><span class="paramname"><em>separator</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a467753751f4011cd7f8e3e628748b92c" name="a467753751f4011cd7f8e3e628748b92c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a467753751f4011cd7f8e3e628748b92c">&#9670;&#160;</a></span>printDimAndSymbolList()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void llzk::printDimAndSymbolList </td>
          <td>(</td>
          <td class="paramtype">mlir::OpAsmPrinter &amp;</td>          <td class="paramname"><span class="paramname"><em>printer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mlir::Operation *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mlir::OperandRange</td>          <td class="paramname"><span class="paramname"><em>mapOperands</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mlir::IntegerAttr</td>          <td class="paramname"><span class="paramname"><em>numDims</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_op_helpers_8h_source.html#l00087">87</a> of file <a class="el" href="_op_helpers_8h_source.html">OpHelpers.h</a>.</p>

</div>
</div>
<a id="aa9eb2d93ae702c8d8e1d2164e77f52e8" name="aa9eb2d93ae702c8d8e1d2164e77f52e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9eb2d93ae702c8d8e1d2164e77f52e8">&#9670;&#160;</a></span>printMultiDimAndSymbolList()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void llzk::printMultiDimAndSymbolList </td>
          <td>(</td>
          <td class="paramtype">mlir::OpAsmPrinter &amp;</td>          <td class="paramname"><span class="paramname"><em>printer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mlir::Operation *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mlir::OperandRangeRange</td>          <td class="paramname"><span class="paramname"><em>multiMapOperands</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mlir::DenseI32ArrayAttr</td>          <td class="paramname"><span class="paramname"><em>numDimsPerMap</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_op_helpers_8h_source.html#l00102">102</a> of file <a class="el" href="_op_helpers_8h_source.html">OpHelpers.h</a>.</p>

</div>
</div>
<a id="a9338ef0435a6cb734c7aebea355d4a36" name="a9338ef0435a6cb734c7aebea355d4a36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9338ef0435a6cb734c7aebea355d4a36">&#9670;&#160;</a></span>registerAllDialects()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void llzk::registerAllDialects </td>
          <td>(</td>
          <td class="paramtype">mlir::DialectRegistry &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_init_dialects_8cpp_source.html#l00030">30</a> of file <a class="el" href="_init_dialects_8cpp_source.html">InitDialects.cpp</a>.</p>

</div>
</div>
<a id="af5b5ce918cd1f943f8e9c470d968b25c" name="af5b5ce918cd1f943f8e9c470d968b25c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5b5ce918cd1f943f8e9c470d968b25c">&#9670;&#160;</a></span>registerAnalysisPasses()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void llzk::registerAnalysisPasses </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_analysis_passes_8h_source.html#l00380">380</a> of file <a class="el" href="_analysis_passes_8h_source.html">AnalysisPasses.h</a>.</p>

</div>
</div>
<a id="a70f1f25bfaea0554bef926a549b1ccfd" name="a70f1f25bfaea0554bef926a549b1ccfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70f1f25bfaea0554bef926a549b1ccfd">&#9670;&#160;</a></span>registerCallGraphPrinterPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void llzk::registerCallGraphPrinterPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_analysis_passes_8h_source.html#l00312">312</a> of file <a class="el" href="_analysis_passes_8h_source.html">AnalysisPasses.h</a>.</p>

</div>
</div>
<a id="a9accc3ce245c0f1d83ec1756bdfddc7f" name="a9accc3ce245c0f1d83ec1756bdfddc7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9accc3ce245c0f1d83ec1756bdfddc7f">&#9670;&#160;</a></span>registerCallGraphPrinterPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void llzk::registerCallGraphPrinterPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_analysis_passes_8h_source.html#l00319">319</a> of file <a class="el" href="_analysis_passes_8h_source.html">AnalysisPasses.h</a>.</p>

</div>
</div>
<a id="aca3ef4b6dafde7897328fef510a09e88" name="aca3ef4b6dafde7897328fef510a09e88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca3ef4b6dafde7897328fef510a09e88">&#9670;&#160;</a></span>registerCallGraphSCCsPrinterPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void llzk::registerCallGraphSCCsPrinterPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_analysis_passes_8h_source.html#l00329">329</a> of file <a class="el" href="_analysis_passes_8h_source.html">AnalysisPasses.h</a>.</p>

</div>
</div>
<a id="aef3801b45287da2cbf5224856fe9e58e" name="aef3801b45287da2cbf5224856fe9e58e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef3801b45287da2cbf5224856fe9e58e">&#9670;&#160;</a></span>registerCallGraphSCCsPrinterPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void llzk::registerCallGraphSCCsPrinterPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_analysis_passes_8h_source.html#l00336">336</a> of file <a class="el" href="_analysis_passes_8h_source.html">AnalysisPasses.h</a>.</p>

</div>
</div>
<a id="a735e5a39ff84a93ee3553979ad00635a" name="a735e5a39ff84a93ee3553979ad00635a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a735e5a39ff84a93ee3553979ad00635a">&#9670;&#160;</a></span>registerConstraintDependencyGraphPrinterPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void llzk::registerConstraintDependencyGraphPrinterPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_analysis_passes_8h_source.html#l00346">346</a> of file <a class="el" href="_analysis_passes_8h_source.html">AnalysisPasses.h</a>.</p>

</div>
</div>
<a id="ae1c6668dc1a3a4c1a2b856902a3895b0" name="ae1c6668dc1a3a4c1a2b856902a3895b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1c6668dc1a3a4c1a2b856902a3895b0">&#9670;&#160;</a></span>registerConstraintDependencyGraphPrinterPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void llzk::registerConstraintDependencyGraphPrinterPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_analysis_passes_8h_source.html#l00353">353</a> of file <a class="el" href="_analysis_passes_8h_source.html">AnalysisPasses.h</a>.</p>

</div>
</div>
<a id="a8079434ecfbc1457fb901788ce16f69e" name="a8079434ecfbc1457fb901788ce16f69e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8079434ecfbc1457fb901788ce16f69e">&#9670;&#160;</a></span>registerFieldWriteValidatorPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void llzk::registerFieldWriteValidatorPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_l_l_z_k_validation_passes_8h_source.html#l00086">86</a> of file <a class="el" href="_l_l_z_k_validation_passes_8h_source.html">LLZKValidationPasses.h</a>.</p>

</div>
</div>
<a id="a2f0d7d42936af872189a17c6c42a1469" name="a2f0d7d42936af872189a17c6c42a1469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f0d7d42936af872189a17c6c42a1469">&#9670;&#160;</a></span>registerFieldWriteValidatorPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void llzk::registerFieldWriteValidatorPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_l_l_z_k_validation_passes_8h_source.html#l00093">93</a> of file <a class="el" href="_l_l_z_k_validation_passes_8h_source.html">LLZKValidationPasses.h</a>.</p>

</div>
</div>
<a id="a4b30dc7eea52369c92554639f9d6d73a" name="a4b30dc7eea52369c92554639f9d6d73a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b30dc7eea52369c92554639f9d6d73a">&#9670;&#160;</a></span>registerIntervalAnalysisPrinterPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void llzk::registerIntervalAnalysisPrinterPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_analysis_passes_8h_source.html#l00363">363</a> of file <a class="el" href="_analysis_passes_8h_source.html">AnalysisPasses.h</a>.</p>

</div>
</div>
<a id="a24c05e5e1e07f0776bcf51b8f08de546" name="a24c05e5e1e07f0776bcf51b8f08de546"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24c05e5e1e07f0776bcf51b8f08de546">&#9670;&#160;</a></span>registerIntervalAnalysisPrinterPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void llzk::registerIntervalAnalysisPrinterPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_analysis_passes_8h_source.html#l00370">370</a> of file <a class="el" href="_analysis_passes_8h_source.html">AnalysisPasses.h</a>.</p>

</div>
</div>
<a id="a52b420046418c6c1e1d5df513bf68e75" name="a52b420046418c6c1e1d5df513bf68e75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52b420046418c6c1e1d5df513bf68e75">&#9670;&#160;</a></span>registerRedundantOperationEliminationPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void llzk::registerRedundantOperationEliminationPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_l_l_z_k_transformation_passes_8h_source.html#l00237">237</a> of file <a class="el" href="_l_l_z_k_transformation_passes_8h_source.html">LLZKTransformationPasses.h</a>.</p>

</div>
</div>
<a id="a742cb6ba67d34d1866a3befa40e7262d" name="a742cb6ba67d34d1866a3befa40e7262d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a742cb6ba67d34d1866a3befa40e7262d">&#9670;&#160;</a></span>registerRedundantOperationEliminationPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void llzk::registerRedundantOperationEliminationPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_l_l_z_k_transformation_passes_8h_source.html#l00244">244</a> of file <a class="el" href="_l_l_z_k_transformation_passes_8h_source.html">LLZKTransformationPasses.h</a>.</p>

</div>
</div>
<a id="ab402712606c35b8b57e3eb077a45e3d0" name="ab402712606c35b8b57e3eb077a45e3d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab402712606c35b8b57e3eb077a45e3d0">&#9670;&#160;</a></span>registerRedundantReadAndWriteEliminationPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void llzk::registerRedundantReadAndWriteEliminationPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_l_l_z_k_transformation_passes_8h_source.html#l00254">254</a> of file <a class="el" href="_l_l_z_k_transformation_passes_8h_source.html">LLZKTransformationPasses.h</a>.</p>

</div>
</div>
<a id="ac8d4d99847c9d1dfc61349e39b132673" name="ac8d4d99847c9d1dfc61349e39b132673"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8d4d99847c9d1dfc61349e39b132673">&#9670;&#160;</a></span>registerRedundantReadAndWriteEliminationPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void llzk::registerRedundantReadAndWriteEliminationPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_l_l_z_k_transformation_passes_8h_source.html#l00261">261</a> of file <a class="el" href="_l_l_z_k_transformation_passes_8h_source.html">LLZKTransformationPasses.h</a>.</p>

</div>
</div>
<a id="a79f7a98b4670512b82df5098ca84e99e" name="a79f7a98b4670512b82df5098ca84e99e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79f7a98b4670512b82df5098ca84e99e">&#9670;&#160;</a></span>registerTransformationPasses()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void llzk::registerTransformationPasses </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_l_l_z_k_transformation_passes_8h_source.html#l00288">288</a> of file <a class="el" href="_l_l_z_k_transformation_passes_8h_source.html">LLZKTransformationPasses.h</a>.</p>

</div>
</div>
<a id="a27132e28370fc61e82609260869dedfd" name="a27132e28370fc61e82609260869dedfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27132e28370fc61e82609260869dedfd">&#9670;&#160;</a></span>registerTransformationPassPipelines()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void llzk::registerTransformationPassPipelines </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_transformation_pass_pipelines_8cpp_source.html#l00025">25</a> of file <a class="el" href="_transformation_pass_pipelines_8cpp_source.html">TransformationPassPipelines.cpp</a>.</p>

</div>
</div>
<a id="a5bfb781c85fcdfda09d0472c2ede1e29" name="a5bfb781c85fcdfda09d0472c2ede1e29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bfb781c85fcdfda09d0472c2ede1e29">&#9670;&#160;</a></span>registerUnusedDeclarationEliminationPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void llzk::registerUnusedDeclarationEliminationPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_l_l_z_k_transformation_passes_8h_source.html#l00271">271</a> of file <a class="el" href="_l_l_z_k_transformation_passes_8h_source.html">LLZKTransformationPasses.h</a>.</p>

</div>
</div>
<a id="a00a1db9f2cbc20b8b1ef3010ea7c97a5" name="a00a1db9f2cbc20b8b1ef3010ea7c97a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00a1db9f2cbc20b8b1ef3010ea7c97a5">&#9670;&#160;</a></span>registerUnusedDeclarationEliminationPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void llzk::registerUnusedDeclarationEliminationPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_l_l_z_k_transformation_passes_8h_source.html#l00278">278</a> of file <a class="el" href="_l_l_z_k_transformation_passes_8h_source.html">LLZKTransformationPasses.h</a>.</p>

</div>
</div>
<a id="a6ae96b1bcc90611da3d6bfd5cd5689fd" name="a6ae96b1bcc90611da3d6bfd5cd5689fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ae96b1bcc90611da3d6bfd5cd5689fd">&#9670;&#160;</a></span>registerValidationPasses()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void llzk::registerValidationPasses </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_l_l_z_k_validation_passes_8h_source.html#l00103">103</a> of file <a class="el" href="_l_l_z_k_validation_passes_8h_source.html">LLZKValidationPasses.h</a>.</p>

</div>
</div>
<a id="a1971dcef957ffd67e7ee350f8841c34c" name="a1971dcef957ffd67e7ee350f8841c34c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1971dcef957ffd67e7ee350f8841c34c">&#9670;&#160;</a></span>replaceLeaf() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::SymbolRefAttr llzk::replaceLeaf </td>
          <td>(</td>
          <td class="paramtype">mlir::SymbolRefAttr</td>          <td class="paramname"><span class="paramname"><em>orig</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mlir::Twine &amp;</td>          <td class="paramname"><span class="paramname"><em>newLeaf</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_symbol_helper_8h_source.html#l00070">70</a> of file <a class="el" href="_symbol_helper_8h_source.html">SymbolHelper.h</a>.</p>

</div>
</div>
<a id="af8e8b6ec5e855b620cb45245fd9ab92e" name="af8e8b6ec5e855b620cb45245fd9ab92e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8e8b6ec5e855b620cb45245fd9ab92e">&#9670;&#160;</a></span>replaceLeaf() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mlir::SymbolRefAttr llzk::replaceLeaf </td>
          <td>(</td>
          <td class="paramtype">mlir::SymbolRefAttr</td>          <td class="paramname"><span class="paramname"><em>orig</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mlir::FlatSymbolRefAttr</td>          <td class="paramname"><span class="paramname"><em>newLeaf</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return SymbolRefAttr like the one given but with the leaf (final) element replaced. </p>

</div>
</div>
<a id="a4a4d8a892b01f7f72b16fe911432e32f" name="a4a4d8a892b01f7f72b16fe911432e32f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a4d8a892b01f7f72b16fe911432e32f">&#9670;&#160;</a></span>replaceLeaf() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::SymbolRefAttr llzk::replaceLeaf </td>
          <td>(</td>
          <td class="paramtype">mlir::SymbolRefAttr</td>          <td class="paramname"><span class="paramname"><em>orig</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mlir::StringAttr</td>          <td class="paramname"><span class="paramname"><em>newLeaf</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_symbol_helper_8h_source.html#l00067">67</a> of file <a class="el" href="_symbol_helper_8h_source.html">SymbolHelper.h</a>.</p>

</div>
</div>
<a id="a6233c90d2afb42113aa36eddeebd8f76" name="a6233c90d2afb42113aa36eddeebd8f76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6233c90d2afb42113aa36eddeebd8f76">&#9670;&#160;</a></span>replaceLeaf() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SymbolRefAttr llzk::replaceLeaf </td>
          <td>(</td>
          <td class="paramtype">SymbolRefAttr</td>          <td class="paramname"><span class="paramname"><em>orig</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FlatSymbolRefAttr</td>          <td class="paramname"><span class="paramname"><em>newLeaf</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_symbol_helper_8cpp_source.html#l00170">170</a> of file <a class="el" href="_symbol_helper_8cpp_source.html">SymbolHelper.cpp</a>.</p>

</div>
</div>
<a id="a043fe7093faebb4db2da50ae89f82b71" name="a043fe7093faebb4db2da50ae89f82b71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a043fe7093faebb4db2da50ae89f82b71">&#9670;&#160;</a></span>resolveCallable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::FailureOr&lt; <a class="el" href="classllzk_1_1_symbol_lookup_result.html">SymbolLookupResult</a>&lt; T &gt; &gt; llzk::resolveCallable </td>
          <td>(</td>
          <td class="paramtype">mlir::CallOpInterface</td>          <td class="paramname"><span class="paramname"><em>call</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_symbol_helper_8h_source.html#l00125">125</a> of file <a class="el" href="_symbol_helper_8h_source.html">SymbolHelper.h</a>.</p>

</div>
</div>
<a id="a76f6ee502fe0bb6ab1986e1ad9090c77" name="a76f6ee502fe0bb6ab1986e1ad9090c77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76f6ee502fe0bb6ab1986e1ad9090c77">&#9670;&#160;</a></span>resolveCallable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::FailureOr&lt; <a class="el" href="classllzk_1_1_symbol_lookup_result.html">SymbolLookupResult</a>&lt; T &gt; &gt; llzk::resolveCallable </td>
          <td>(</td>
          <td class="paramtype">mlir::SymbolTableCollection &amp;</td>          <td class="paramname"><span class="paramname"><em>symbolTable</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mlir::CallOpInterface</td>          <td class="paramname"><span class="paramname"><em>call</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Based on mlir::CallOpInterface::resolveCallable, but using LLZK lookup helpers. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of symbol being resolved (e.g., <a class="el" href="classllzk_1_1function_1_1_func_def_op.html">function::FuncDefOp</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">symbolTable</td><td></td></tr>
    <tr><td class="paramname">call</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the symbol or failure </dd></dl>

<p class="definition">Definition at line <a class="el" href="_symbol_helper_8h_source.html#l00104">104</a> of file <a class="el" href="_symbol_helper_8h_source.html">SymbolHelper.h</a>.</p>

</div>
</div>
<a id="a21ddb33b632574b5123ac797e7cf1354" name="a21ddb33b632574b5123ac797e7cf1354"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21ddb33b632574b5123ac797e7cf1354">&#9670;&#160;</a></span>safeCmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::strong_ordering llzk::safeCmp </td>
          <td>(</td>
          <td class="paramtype">const llvm::APSInt &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::APSInt &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares lhs and rhs, regardless of the bitwidth of lhs and rhs. </p>
<dl class="section return"><dt>Returns</dt><dd>lhs is less, equal, or greater than rhs </dd></dl>

<p class="definition">Definition at line <a class="el" href="_a_p_int_helper_8cpp_source.html#l00032">32</a> of file <a class="el" href="_a_p_int_helper_8cpp_source.html">APIntHelper.cpp</a>.</p>

</div>
</div>
<a id="a94a1e3bcf698c899bfc06acbf41889ab" name="a94a1e3bcf698c899bfc06acbf41889ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94a1e3bcf698c899bfc06acbf41889ab">&#9670;&#160;</a></span>safeEq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool llzk::safeEq </td>
          <td>(</td>
          <td class="paramtype">const llvm::APSInt &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::APSInt &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_a_p_int_helper_8h_source.html#l00066">66</a> of file <a class="el" href="_a_p_int_helper_8h_source.html">APIntHelper.h</a>.</p>

</div>
</div>
<a id="acd6d805f7abef8f9d78cc69913697014" name="acd6d805f7abef8f9d78cc69913697014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd6d805f7abef8f9d78cc69913697014">&#9670;&#160;</a></span>safeGe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool llzk::safeGe </td>
          <td>(</td>
          <td class="paramtype">const llvm::APSInt &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::APSInt &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_a_p_int_helper_8h_source.html#l00078">78</a> of file <a class="el" href="_a_p_int_helper_8h_source.html">APIntHelper.h</a>.</p>

</div>
</div>
<a id="a932b4bf35161df2293fdc0d96a01f948" name="a932b4bf35161df2293fdc0d96a01f948"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a932b4bf35161df2293fdc0d96a01f948">&#9670;&#160;</a></span>safeGt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool llzk::safeGt </td>
          <td>(</td>
          <td class="paramtype">const llvm::APSInt &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::APSInt &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_a_p_int_helper_8h_source.html#l00074">74</a> of file <a class="el" href="_a_p_int_helper_8h_source.html">APIntHelper.h</a>.</p>

</div>
</div>
<a id="ab0bddd3e2491900b24bdd5691fd50879" name="ab0bddd3e2491900b24bdd5691fd50879"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0bddd3e2491900b24bdd5691fd50879">&#9670;&#160;</a></span>safeLe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool llzk::safeLe </td>
          <td>(</td>
          <td class="paramtype">const llvm::APSInt &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::APSInt &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_a_p_int_helper_8h_source.html#l00062">62</a> of file <a class="el" href="_a_p_int_helper_8h_source.html">APIntHelper.h</a>.</p>

</div>
</div>
<a id="aa089f0e4ab428c808e92c51fdc4e34c7" name="aa089f0e4ab428c808e92c51fdc4e34c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa089f0e4ab428c808e92c51fdc4e34c7">&#9670;&#160;</a></span>safeLt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool llzk::safeLt </td>
          <td>(</td>
          <td class="paramtype">const llvm::APSInt &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::APSInt &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_a_p_int_helper_8h_source.html#l00058">58</a> of file <a class="el" href="_a_p_int_helper_8h_source.html">APIntHelper.h</a>.</p>

</div>
</div>
<a id="a4f8ce5c145a392aa5c382d2c9930cc22" name="a4f8ce5c145a392aa5c382d2c9930cc22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f8ce5c145a392aa5c382d2c9930cc22">&#9670;&#160;</a></span>safeMax() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::APSInt llzk::safeMax </td>
          <td>(</td>
          <td class="paramtype">const llvm::APSInt &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::APSInt &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_a_p_int_helper_8h_source.html#l00090">90</a> of file <a class="el" href="_a_p_int_helper_8h_source.html">APIntHelper.h</a>.</p>

</div>
</div>
<a id="ae144a51e20e007a607c11a19a19ba736" name="ae144a51e20e007a607c11a19a19ba736"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae144a51e20e007a607c11a19a19ba736">&#9670;&#160;</a></span>safeMax() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::APSInt llzk::safeMax </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; llvm::APSInt &gt;</td>          <td class="paramname"><span class="paramname"><em>ilist</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_a_p_int_helper_8h_source.html#l00094">94</a> of file <a class="el" href="_a_p_int_helper_8h_source.html">APIntHelper.h</a>.</p>

</div>
</div>
<a id="ae9c220e19757e93c8a5a42c87224763c" name="ae9c220e19757e93c8a5a42c87224763c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9c220e19757e93c8a5a42c87224763c">&#9670;&#160;</a></span>safeMin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::APSInt llzk::safeMin </td>
          <td>(</td>
          <td class="paramtype">const llvm::APSInt &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::APSInt &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_a_p_int_helper_8h_source.html#l00082">82</a> of file <a class="el" href="_a_p_int_helper_8h_source.html">APIntHelper.h</a>.</p>

</div>
</div>
<a id="a50400df1f01c51207bdb8ec48544cd8f" name="a50400df1f01c51207bdb8ec48544cd8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50400df1f01c51207bdb8ec48544cd8f">&#9670;&#160;</a></span>safeMin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::APSInt llzk::safeMin </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; llvm::APSInt &gt;</td>          <td class="paramname"><span class="paramname"><em>ilist</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_a_p_int_helper_8h_source.html#l00086">86</a> of file <a class="el" href="_a_p_int_helper_8h_source.html">APIntHelper.h</a>.</p>

</div>
</div>
<a id="ac29ce8caf9a069ea6b93d13876c98ed9" name="ac29ce8caf9a069ea6b93d13876c98ed9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac29ce8caf9a069ea6b93d13876c98ed9">&#9670;&#160;</a></span>safeNe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool llzk::safeNe </td>
          <td>(</td>
          <td class="paramtype">const llvm::APSInt &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::APSInt &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_a_p_int_helper_8h_source.html#l00070">70</a> of file <a class="el" href="_a_p_int_helper_8h_source.html">APIntHelper.h</a>.</p>

</div>
</div>
<a id="a440d077c5fc53dbf3a2ca32b9b82d4bf" name="a440d077c5fc53dbf3a2ca32b9b82d4bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a440d077c5fc53dbf3a2ca32b9b82d4bf">&#9670;&#160;</a></span>singletonTypeListsUnify()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iter1, typename Iter2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool llzk::singletonTypeListsUnify </td>
          <td>(</td>
          <td class="paramtype">Iter1</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter2</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mlir::ArrayRef&lt; llvm::StringRef &gt;</td>          <td class="paramname"><span class="paramname"><em>rhsReversePrefix</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a513acdd19d4296f6623ca75ed5eeb904">UnificationMap</a> *</td>          <td class="paramname"><span class="paramname"><em>unifications</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_type_helper_8h_source.html#l00210">210</a> of file <a class="el" href="_type_helper_8h_source.html">TypeHelper.h</a>.</p>

</div>
</div>
<a id="a53fd11575f45740ca49d163fff8c925e" name="a53fd11575f45740ca49d163fff8c925e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53fd11575f45740ca49d163fff8c925e">&#9670;&#160;</a></span>stringWithoutType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string llzk::stringWithoutType </td>
          <td>(</td>
          <td class="paramtype">mlir::Attribute</td>          <td class="paramname"><span class="paramname"><em>a</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_attribute_helper_8h_source.html#l00039">39</a> of file <a class="el" href="_attribute_helper_8h_source.html">AttributeHelper.h</a>.</p>

</div>
</div>
<a id="a69963a95b5969b71622293ca51f74103" name="a69963a95b5969b71622293ca51f74103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69963a95b5969b71622293ca51f74103">&#9670;&#160;</a></span>structTypesUnify() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool llzk::structTypesUnify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllzk_1_1component_1_1_struct_type.html">component::StructType</a></td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllzk_1_1component_1_1_struct_type.html">component::StructType</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mlir::ArrayRef&lt; llvm::StringRef &gt;</td>          <td class="paramname"><span class="paramname"><em>rhsReversePrefix</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a513acdd19d4296f6623ca75ed5eeb904">UnificationMap</a> *</td>          <td class="paramname"><span class="paramname"><em>unifications</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return <code>true</code> iff the two <a class="el" href="classllzk_1_1component_1_1_struct_type.html">StructType</a> instances are equivalent or could be equivalent after full instantiation of struct parameters. </p>

</div>
</div>
<a id="a449db750fee6d61e2ec3aa36a969d483" name="a449db750fee6d61e2ec3aa36a969d483"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a449db750fee6d61e2ec3aa36a969d483">&#9670;&#160;</a></span>structTypesUnify() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool llzk::structTypesUnify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllzk_1_1component_1_1_struct_type.html">StructType</a></td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllzk_1_1component_1_1_struct_type.html">StructType</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayRef&lt; StringRef &gt;</td>          <td class="paramname"><span class="paramname"><em>rhsReversePrefix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a513acdd19d4296f6623ca75ed5eeb904">UnificationMap</a> *</td>          <td class="paramname"><span class="paramname"><em>unifications</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_type_helper_8cpp_source.html#l00680">680</a> of file <a class="el" href="_type_helper_8cpp_source.html">TypeHelper.cpp</a>.</p>

</div>
</div>
<a id="a11351aaca0b8ece3f9e0c586d2b8b909" name="a11351aaca0b8ece3f9e0c586d2b8b909"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11351aaca0b8ece3f9e0c586d2b8b909">&#9670;&#160;</a></span>sub()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllzk_1_1_expression_value.html">ExpressionValue</a> llzk::sub </td>
          <td>(</td>
          <td class="paramtype">llvm::SMTSolverRef</td>          <td class="paramname"><span class="paramname"><em>solver</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classllzk_1_1_expression_value.html">ExpressionValue</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classllzk_1_1_expression_value.html">ExpressionValue</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_interval_analysis_8cpp_source.html#l00493">493</a> of file <a class="el" href="_interval_analysis_8cpp_source.html">IntervalAnalysis.cpp</a>.</p>

</div>
</div>
<a id="a39859e51fc665588ce50b49754e871cd" name="a39859e51fc665588ce50b49754e871cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39859e51fc665588ce50b49754e871cd">&#9670;&#160;</a></span>toAPInt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::APInt llzk::toAPInt </td>
          <td>(</td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_attribute_helper_8h_source.html#l00031">31</a> of file <a class="el" href="_attribute_helper_8h_source.html">AttributeHelper.h</a>.</p>

</div>
</div>
<a id="a290cbd8f2848b2ab447a3b296adf6830" name="a290cbd8f2848b2ab447a3b296adf6830"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a290cbd8f2848b2ab447a3b296adf6830">&#9670;&#160;</a></span>typeListsUnify()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iter1, typename Iter2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool llzk::typeListsUnify </td>
          <td>(</td>
          <td class="paramtype">Iter1</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter2</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mlir::ArrayRef&lt; llvm::StringRef &gt;</td>          <td class="paramname"><span class="paramname"><em>rhsReversePrefix</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a513acdd19d4296f6623ca75ed5eeb904">UnificationMap</a> *</td>          <td class="paramname"><span class="paramname"><em>unifications</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> iff the two lists of Type instances are equivalent or could be equivalent after full instantiation of struct parameters (if applicable within the given types). </p>

<p class="definition">Definition at line <a class="el" href="_type_helper_8h_source.html#l00199">199</a> of file <a class="el" href="_type_helper_8h_source.html">TypeHelper.h</a>.</p>

</div>
</div>
<a id="a65be8a8027f956741851720ef5047350" name="a65be8a8027f956741851720ef5047350"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65be8a8027f956741851720ef5047350">&#9670;&#160;</a></span>typeParamsUnify() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool llzk::typeParamsUnify </td>
          <td>(</td>
          <td class="paramtype">const ArrayAttr &amp;</td>          <td class="paramname"><span class="paramname"><em>lhsParams</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayAttr &amp;</td>          <td class="paramname"><span class="paramname"><em>rhsParams</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a513acdd19d4296f6623ca75ed5eeb904">UnificationMap</a> *</td>          <td class="paramname"><span class="paramname"><em>unifications</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return <code>true</code> iff the two ArrayAttr instances containing <a class="el" href="classllzk_1_1component_1_1_struct_type.html">StructType</a> or <a class="el" href="classllzk_1_1array_1_1_array_type.html">ArrayType</a> parameters are equivalent or could be equivalent after full instantiation of struct parameters. </p>

<p class="definition">Definition at line <a class="el" href="_type_helper_8cpp_source.html#l00668">668</a> of file <a class="el" href="_type_helper_8cpp_source.html">TypeHelper.cpp</a>.</p>

</div>
</div>
<a id="ac0200f46aeb61d24a1630b2eebf0abe7" name="ac0200f46aeb61d24a1630b2eebf0abe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0200f46aeb61d24a1630b2eebf0abe7">&#9670;&#160;</a></span>typeParamsUnify() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool llzk::typeParamsUnify </td>
          <td>(</td>
          <td class="paramtype">const ArrayRef&lt; Attribute &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhsParams</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayRef&lt; Attribute &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhsParams</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a513acdd19d4296f6623ca75ed5eeb904">UnificationMap</a> *</td>          <td class="paramname"><span class="paramname"><em>unifications</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_type_helper_8cpp_source.html#l00659">659</a> of file <a class="el" href="_type_helper_8cpp_source.html">TypeHelper.cpp</a>.</p>

</div>
</div>
<a id="a655150473b4f06abf31999e50667dcf1" name="a655150473b4f06abf31999e50667dcf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a655150473b4f06abf31999e50667dcf1">&#9670;&#160;</a></span>typeParamsUnify() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool llzk::typeParamsUnify </td>
          <td>(</td>
          <td class="paramtype">const mlir::ArrayAttr &amp;</td>          <td class="paramname"><span class="paramname"><em>lhsParams</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mlir::ArrayAttr &amp;</td>          <td class="paramname"><span class="paramname"><em>rhsParams</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a513acdd19d4296f6623ca75ed5eeb904">UnificationMap</a> *</td>          <td class="paramname"><span class="paramname"><em>unifications</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return <code>true</code> iff the two ArrayAttr instances containing <a class="el" href="classllzk_1_1component_1_1_struct_type.html">StructType</a> or <a class="el" href="classllzk_1_1array_1_1_array_type.html">ArrayType</a> parameters are equivalent or could be equivalent after full instantiation of struct parameters. </p>

</div>
</div>
<a id="aef957f901953e0f4c184c26c8993a6cb" name="aef957f901953e0f4c184c26c8993a6cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef957f901953e0f4c184c26c8993a6cb">&#9670;&#160;</a></span>typeParamsUnify() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool llzk::typeParamsUnify </td>
          <td>(</td>
          <td class="paramtype">const mlir::ArrayRef&lt; mlir::Attribute &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhsParams</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mlir::ArrayRef&lt; mlir::Attribute &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhsParams</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a513acdd19d4296f6623ca75ed5eeb904">UnificationMap</a> *</td>          <td class="paramname"><span class="paramname"><em>unifications</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return <code>true</code> iff the two ArrayRef instances containing <a class="el" href="classllzk_1_1component_1_1_struct_type.html">StructType</a> or <a class="el" href="classllzk_1_1array_1_1_array_type.html">ArrayType</a> parameters are equivalent or could be equivalent after full instantiation of struct parameters. </p>

</div>
</div>
<a id="a8a7476f05c4dce2ef7554e0ba1c3d567" name="a8a7476f05c4dce2ef7554e0ba1c3d567"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a7476f05c4dce2ef7554e0ba1c3d567">&#9670;&#160;</a></span>typesUnify() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool llzk::typesUnify </td>
          <td>(</td>
          <td class="paramtype">mlir::Type</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mlir::Type</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mlir::ArrayRef&lt; llvm::StringRef &gt;</td>          <td class="paramname"><span class="paramname"><em>rhsReversePrefix</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a513acdd19d4296f6623ca75ed5eeb904">UnificationMap</a> *</td>          <td class="paramname"><span class="paramname"><em>unifications</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return <code>true</code> iff the two Type instances are equivalent or could be equivalent after full instantiation of struct parameters (if applicable within the given types). </p>

</div>
</div>
<a id="abc5c6fc1f85b22d1d6e46755e5da1626" name="abc5c6fc1f85b22d1d6e46755e5da1626"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc5c6fc1f85b22d1d6e46755e5da1626">&#9670;&#160;</a></span>typesUnify() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool llzk::typesUnify </td>
          <td>(</td>
          <td class="paramtype">Type</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayRef&lt; StringRef &gt;</td>          <td class="paramname"><span class="paramname"><em>rhsReversePrefix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a513acdd19d4296f6623ca75ed5eeb904">UnificationMap</a> *</td>          <td class="paramname"><span class="paramname"><em>unifications</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_type_helper_8cpp_source.html#l00687">687</a> of file <a class="el" href="_type_helper_8cpp_source.html">TypeHelper.cpp</a>.</p>

</div>
</div>
<a id="a016f3b59595b34b00f2b01667467aa06" name="a016f3b59595b34b00f2b01667467aa06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a016f3b59595b34b00f2b01667467aa06">&#9670;&#160;</a></span>verifyAffineMapAttrType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult llzk::verifyAffineMapAttrType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a36a2156534c7f7ae6aadbf0d8d8fa869">EmitErrorFn</a></td>          <td class="paramname"><span class="paramname"><em>emitError</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Attribute</td>          <td class="paramname"><span class="paramname"><em>in</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_type_helper_8cpp_source.html#l00748">748</a> of file <a class="el" href="_type_helper_8cpp_source.html">TypeHelper.cpp</a>.</p>

</div>
</div>
<a id="ad4d946242ab564714c666f9d89fc8037" name="ad4d946242ab564714c666f9d89fc8037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4d946242ab564714c666f9d89fc8037">&#9670;&#160;</a></span>verifyAffineMapAttrType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mlir::LogicalResult llzk::verifyAffineMapAttrType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a36a2156534c7f7ae6aadbf0d8d8fa869">EmitErrorFn</a></td>          <td class="paramname"><span class="paramname"><em>emitError</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mlir::Attribute</td>          <td class="paramname"><span class="paramname"><em>in</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify that all AffineMapAttr only have a single result. </p>

</div>
</div>
<a id="afe6df124d315ea4af67d41601225b1a2" name="afe6df124d315ea4af67d41601225b1a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe6df124d315ea4af67d41601225b1a2">&#9670;&#160;</a></span>verifyArrayDimSizes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult llzk::verifyArrayDimSizes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a36a2156534c7f7ae6aadbf0d8d8fa869">EmitErrorFn</a></td>          <td class="paramname"><span class="paramname"><em>emitError</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayRef&lt; Attribute &gt;</td>          <td class="paramname"><span class="paramname"><em>dimensionSizes</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_type_helper_8cpp_source.html#l00770">770</a> of file <a class="el" href="_type_helper_8cpp_source.html">TypeHelper.cpp</a>.</p>

</div>
</div>
<a id="a27d82a7165519ee38626eca2062dc9ec" name="a27d82a7165519ee38626eca2062dc9ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27d82a7165519ee38626eca2062dc9ec">&#9670;&#160;</a></span>verifyArrayDimSizes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mlir::LogicalResult llzk::verifyArrayDimSizes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a36a2156534c7f7ae6aadbf0d8d8fa869">EmitErrorFn</a></td>          <td class="paramname"><span class="paramname"><em>emitError</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mlir::ArrayRef&lt; mlir::Attribute &gt;</td>          <td class="paramname"><span class="paramname"><em>dimensionSizes</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify that the array dimenstions are valid. </p>

</div>
</div>
<a id="a28b6fbe238c9f2d2f1874f246ecb4b06" name="a28b6fbe238c9f2d2f1874f246ecb4b06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28b6fbe238c9f2d2f1874f246ecb4b06">&#9670;&#160;</a></span>verifyArrayType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mlir::LogicalResult llzk::verifyArrayType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a36a2156534c7f7ae6aadbf0d8d8fa869">EmitErrorFn</a></td>          <td class="paramname"><span class="paramname"><em>emitError</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mlir::Type</td>          <td class="paramname"><span class="paramname"><em>elementType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mlir::ArrayRef&lt; mlir::Attribute &gt;</td>          <td class="paramname"><span class="paramname"><em>dimensionSizes</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify that the <a class="el" href="classllzk_1_1array_1_1_array_type.html">ArrayType</a> is valid. </p>

</div>
</div>
<a id="a499aa56be86c2cdb1852b4a402a0913a" name="a499aa56be86c2cdb1852b4a402a0913a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a499aa56be86c2cdb1852b4a402a0913a">&#9670;&#160;</a></span>verifyArrayType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult llzk::verifyArrayType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a36a2156534c7f7ae6aadbf0d8d8fa869">EmitErrorFn</a></td>          <td class="paramname"><span class="paramname"><em>emitError</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type</td>          <td class="paramname"><span class="paramname"><em>elementType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayRef&lt; Attribute &gt;</td>          <td class="paramname"><span class="paramname"><em>dimensionSizes</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_type_helper_8cpp_source.html#l00775">775</a> of file <a class="el" href="_type_helper_8cpp_source.html">TypeHelper.cpp</a>.</p>

</div>
</div>
<a id="a26ae160de4660dc25c69d9461f065d84" name="a26ae160de4660dc25c69d9461f065d84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26ae160de4660dc25c69d9461f065d84">&#9670;&#160;</a></span>verifyIntAttrType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult llzk::verifyIntAttrType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a36a2156534c7f7ae6aadbf0d8d8fa869">EmitErrorFn</a></td>          <td class="paramname"><span class="paramname"><em>emitError</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Attribute</td>          <td class="paramname"><span class="paramname"><em>in</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_type_helper_8cpp_source.html#l00733">733</a> of file <a class="el" href="_type_helper_8cpp_source.html">TypeHelper.cpp</a>.</p>

</div>
</div>
<a id="a4df6c0fdb96ccfcf9714e70332cbc6ea" name="a4df6c0fdb96ccfcf9714e70332cbc6ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4df6c0fdb96ccfcf9714e70332cbc6ea">&#9670;&#160;</a></span>verifyIntAttrType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mlir::LogicalResult llzk::verifyIntAttrType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a36a2156534c7f7ae6aadbf0d8d8fa869">EmitErrorFn</a></td>          <td class="paramname"><span class="paramname"><em>emitError</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mlir::Attribute</td>          <td class="paramname"><span class="paramname"><em>in</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify that all IntegerAttr have type IndexType. </p>

</div>
</div>
<a id="acc811579523974df9a00a8e969ea1ffc" name="acc811579523974df9a00a8e969ea1ffc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc811579523974df9a00a8e969ea1ffc">&#9670;&#160;</a></span>verifyParamOfType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mlir::LogicalResult llzk::verifyParamOfType </td>
          <td>(</td>
          <td class="paramtype">mlir::SymbolTableCollection &amp;</td>          <td class="paramname"><span class="paramname"><em>tables</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mlir::SymbolRefAttr</td>          <td class="paramname"><span class="paramname"><em>param</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mlir::Type</td>          <td class="paramname"><span class="paramname"><em>structOrArrayType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mlir::Operation *</td>          <td class="paramname"><span class="paramname"><em>origin</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ensure that the given symbol (that is used as a parameter of the given type) can be resolved. </p>

</div>
</div>
<a id="adb5ab0e54d49d74723127a7315e8ba22" name="adb5ab0e54d49d74723127a7315e8ba22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb5ab0e54d49d74723127a7315e8ba22">&#9670;&#160;</a></span>verifyParamOfType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult llzk::verifyParamOfType </td>
          <td>(</td>
          <td class="paramtype">SymbolTableCollection &amp;</td>          <td class="paramname"><span class="paramname"><em>tables</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SymbolRefAttr</td>          <td class="paramname"><span class="paramname"><em>param</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type</td>          <td class="paramname"><span class="paramname"><em>parameterizedType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Operation *</td>          <td class="paramname"><span class="paramname"><em>origin</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_symbol_helper_8cpp_source.html#l00248">248</a> of file <a class="el" href="_symbol_helper_8cpp_source.html">SymbolHelper.cpp</a>.</p>

</div>
</div>
<a id="ad11e39677b93aea53264f2ffcd504f3c" name="ad11e39677b93aea53264f2ffcd504f3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad11e39677b93aea53264f2ffcd504f3c">&#9670;&#160;</a></span>verifyParamsOfType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mlir::LogicalResult llzk::verifyParamsOfType </td>
          <td>(</td>
          <td class="paramtype">mlir::SymbolTableCollection &amp;</td>          <td class="paramname"><span class="paramname"><em>tables</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mlir::ArrayRef&lt; mlir::Attribute &gt;</td>          <td class="paramname"><span class="paramname"><em>tyParams</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mlir::Type</td>          <td class="paramname"><span class="paramname"><em>structOrArrayType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mlir::Operation *</td>          <td class="paramname"><span class="paramname"><em>origin</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ensure that any symbols that appear within the given attributes (that are parameters of the given type) can be resolved. </p>

</div>
</div>
<a id="aaa90d2946d0210b5c3be6279175cf786" name="aaa90d2946d0210b5c3be6279175cf786"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa90d2946d0210b5c3be6279175cf786">&#9670;&#160;</a></span>verifyParamsOfType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult llzk::verifyParamsOfType </td>
          <td>(</td>
          <td class="paramtype">SymbolTableCollection &amp;</td>          <td class="paramname"><span class="paramname"><em>tables</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayRef&lt; Attribute &gt;</td>          <td class="paramname"><span class="paramname"><em>tyParams</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type</td>          <td class="paramname"><span class="paramname"><em>parameterizedType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Operation *</td>          <td class="paramname"><span class="paramname"><em>origin</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_symbol_helper_8cpp_source.html#l00276">276</a> of file <a class="el" href="_symbol_helper_8cpp_source.html">SymbolHelper.cpp</a>.</p>

</div>
</div>
<a id="acea511d0810d60bdecf9d7f1e0779d8e" name="acea511d0810d60bdecf9d7f1e0779d8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acea511d0810d60bdecf9d7f1e0779d8e">&#9670;&#160;</a></span>verifyStructTypeParams() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult llzk::verifyStructTypeParams </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a36a2156534c7f7ae6aadbf0d8d8fa869">EmitErrorFn</a></td>          <td class="paramname"><span class="paramname"><em>emitError</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayAttr</td>          <td class="paramname"><span class="paramname"><em>params</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_type_helper_8cpp_source.html#l00766">766</a> of file <a class="el" href="_type_helper_8cpp_source.html">TypeHelper.cpp</a>.</p>

</div>
</div>
<a id="aed39cddd257ee780016ebcc6acce954a" name="aed39cddd257ee780016ebcc6acce954a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed39cddd257ee780016ebcc6acce954a">&#9670;&#160;</a></span>verifyStructTypeParams() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mlir::LogicalResult llzk::verifyStructTypeParams </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a36a2156534c7f7ae6aadbf0d8d8fa869">EmitErrorFn</a></td>          <td class="paramname"><span class="paramname"><em>emitError</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mlir::ArrayAttr</td>          <td class="paramname"><span class="paramname"><em>params</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify that the <a class="el" href="classllzk_1_1component_1_1_struct_type.html">StructType</a> parameters are valid. </p>

</div>
</div>
<a id="a6a440b2851118a528c4cf09f990ae4a5" name="a6a440b2851118a528c4cf09f990ae4a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a440b2851118a528c4cf09f990ae4a5">&#9670;&#160;</a></span>verifyStructTypeResolution() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mlir::FailureOr&lt; <a class="el" href="classllzk_1_1component_1_1_struct_def_op.html">component::StructDefOp</a> &gt; llzk::verifyStructTypeResolution </td>
          <td>(</td>
          <td class="paramtype">mlir::SymbolTableCollection &amp;</td>          <td class="paramname"><span class="paramname"><em>tables</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllzk_1_1component_1_1_struct_type.html">component::StructType</a></td>          <td class="paramname"><span class="paramname"><em>ty</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mlir::Operation *</td>          <td class="paramname"><span class="paramname"><em>origin</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ensure that all symbols used within the type can be resolved. </p>

</div>
</div>
<a id="a75f8539d20e1d1066b30e5b8d15b0546" name="a75f8539d20e1d1066b30e5b8d15b0546"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75f8539d20e1d1066b30e5b8d15b0546">&#9670;&#160;</a></span>verifyStructTypeResolution() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classllzk_1_1component_1_1_struct_def_op.html">StructDefOp</a> &gt; llzk::verifyStructTypeResolution </td>
          <td>(</td>
          <td class="paramtype">SymbolTableCollection &amp;</td>          <td class="paramname"><span class="paramname"><em>tables</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllzk_1_1component_1_1_struct_type.html">StructType</a></td>          <td class="paramname"><span class="paramname"><em>ty</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Operation *</td>          <td class="paramname"><span class="paramname"><em>origin</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_symbol_helper_8cpp_source.html#l00300">300</a> of file <a class="el" href="_symbol_helper_8cpp_source.html">SymbolHelper.cpp</a>.</p>

</div>
</div>
<a id="aa2361346b0d5cd8b5817a8c8b65ef23e" name="aa2361346b0d5cd8b5817a8c8b65ef23e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2361346b0d5cd8b5817a8c8b65ef23e">&#9670;&#160;</a></span>verifyTypeResolution() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::ranges::input_range Range&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">mlir::LogicalResult llzk::verifyTypeResolution </td>
          <td>(</td>
          <td class="paramtype">mlir::SymbolTableCollection &amp;</td>          <td class="paramname"><span class="paramname"><em>tables</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mlir::Operation *</td>          <td class="paramname"><span class="paramname"><em>origin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Range &amp;</td>          <td class="paramname"><span class="paramname"><em>types</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ensure that all symbols used within all Type instances can be resolved. </p>

<p class="definition">Definition at line <a class="el" href="_symbol_helper_8h_source.html#l00157">157</a> of file <a class="el" href="_symbol_helper_8h_source.html">SymbolHelper.h</a>.</p>

</div>
</div>
<a id="abcc40d684f6ca8079665a69cf2866838" name="abcc40d684f6ca8079665a69cf2866838"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcc40d684f6ca8079665a69cf2866838">&#9670;&#160;</a></span>verifyTypeResolution() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mlir::LogicalResult llzk::verifyTypeResolution </td>
          <td>(</td>
          <td class="paramtype">mlir::SymbolTableCollection &amp;</td>          <td class="paramname"><span class="paramname"><em>tables</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mlir::Operation *</td>          <td class="paramname"><span class="paramname"><em>origin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mlir::Type</td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ensure that all symbols used within the given Type instance can be resolved. </p>

</div>
</div>
<a id="a8a20668e5af9ce080f868692b9d199a6" name="a8a20668e5af9ce080f868692b9d199a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a20668e5af9ce080f868692b9d199a6">&#9670;&#160;</a></span>verifyTypeResolution() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult llzk::verifyTypeResolution </td>
          <td>(</td>
          <td class="paramtype">SymbolTableCollection &amp;</td>          <td class="paramname"><span class="paramname"><em>tables</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Operation *</td>          <td class="paramname"><span class="paramname"><em>origin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type</td>          <td class="paramname"><span class="paramname"><em>ty</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_symbol_helper_8cpp_source.html#l00324">324</a> of file <a class="el" href="_symbol_helper_8cpp_source.html">SymbolHelper.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a2fc6fe57002b3ad8de6b04de904ad83a" name="a2fc6fe57002b3ad8de6b04de904ad83a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fc6fe57002b3ad8de6b04de904ad83a">&#9670;&#160;</a></span>COMPONENT_NAME_MAIN</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char llzk::COMPONENT_NAME_MAIN[] = &quot;Main&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Symbol name for the main entry point struct/component (if any). </p>
<p>There are additional restrictions on the struct with this name:</p><ol type="1">
<li>It cannot have struct parameters.</li>
<li>The parameter types of its functions (besides the required "self" parameter) can only be <code>struct&lt;Signal&gt;</code> or <code>array&lt;.. x struct&lt;Signal&gt;&gt;</code>. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="_constants_8h_source.html#l00023">23</a> of file <a class="el" href="_constants_8h_source.html">Constants.h</a>.</p>

</div>
</div>
<a id="ab849305197e4aa934967d210a512f107" name="ab849305197e4aa934967d210a512f107"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab849305197e4aa934967d210a512f107">&#9670;&#160;</a></span>COMPONENT_NAME_SIGNAL</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char llzk::COMPONENT_NAME_SIGNAL[] = &quot;Signal&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Symbol name for the struct/component representing a signal. </p>
<p>A "signal" has direct correspondence to a circom signal or AIR/PLONK column, opposed to intermediate values or other expressions. </p>

<p class="definition">Definition at line <a class="el" href="_constants_8h_source.html#l00016">16</a> of file <a class="el" href="_constants_8h_source.html">Constants.h</a>.</p>

</div>
</div>
<a id="a078ca0039bbcd069858d9c9141c015d0" name="a078ca0039bbcd069858d9c9141c015d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a078ca0039bbcd069858d9c9141c015d0">&#9670;&#160;</a></span>FUNC_NAME_COMPUTE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char llzk::FUNC_NAME_COMPUTE[] = &quot;compute&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Symbol name for the witness generation (and resp. </p>
<p>constraint generation) functions within a component. </p>

<p class="definition">Definition at line <a class="el" href="_constants_8h_source.html#l00027">27</a> of file <a class="el" href="_constants_8h_source.html">Constants.h</a>.</p>

</div>
</div>
<a id="a353b99dc283d18cdecb549edcb8d096f" name="a353b99dc283d18cdecb549edcb8d096f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a353b99dc283d18cdecb549edcb8d096f">&#9670;&#160;</a></span>FUNC_NAME_CONSTRAIN</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char llzk::FUNC_NAME_CONSTRAIN[] = &quot;constrain&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_constants_8h_source.html#l00028">28</a> of file <a class="el" href="_constants_8h_source.html">Constants.h</a>.</p>

</div>
</div>
<a id="a1b66c1ee1b386cb29f255332f586e96d" name="a1b66c1ee1b386cb29f255332f586e96d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b66c1ee1b386cb29f255332f586e96d">&#9670;&#160;</a></span>LANG_ATTR_NAME</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char llzk::LANG_ATTR_NAME[] = &quot;veridise.lang&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Name of the attribute on the top-level ModuleOp that specifies the IR language name. </p>

<p class="definition">Definition at line <a class="el" href="_constants_8h_source.html#l00031">31</a> of file <a class="el" href="_constants_8h_source.html">Constants.h</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.13.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacellzk.html">llzk</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
    <li class="footer">Copyright 2025 Veridise Inc. under the Apache License v2.0.</li>
  </ul>
</div>
</body>
</html>
