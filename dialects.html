<!-- HTML header for doxygen 1.13.2-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LLZK: LLZK Dialects</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<!-- doxygen-awesome extensions -->
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeParagraphLink.init()
    DoxygenAwesomeInteractiveToc.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LLZK<span id="projectnumber">&#160;0.1.0</span>
   </div>
   <div id="projectbrief">Veridise&#39;s ZK Language IR</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('dialects.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">LLZK Dialects</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul>
  <li class="level1">
    <a href="#autotoc_md45">&#39;array&#39; Dialect</a>
    <ul>
      <li class="level2">
        <a href="#autotoc_md46">Types</a>
      </li>
    </ul>
  </li>
  <li class="level1">
    <a href="#autotoc_md49">&#39;bool&#39; Dialect</a>
    <ul>
      <li class="level2">
        <a href="#autotoc_md50">Operations</a>
      </li>
      <li class="level2">
        <a href="#autotoc_md70">Attributes</a>
      </li>
    </ul>
  </li>
  <li class="level1">
    <a href="#autotoc_md73">&#39;cast&#39; Dialect</a>
    <ul>
      <li class="level2">
        <a href="#autotoc_md74">Operations</a>
      </li>
    </ul>
  </li>
  <li class="level1">
    <a href="#autotoc_md81">&#39;constrain&#39; Dialect</a>
    <ul>
      <li class="level2">
        <a href="#autotoc_md82">Operations</a>
      </li>
    </ul>
  </li>
  <li class="level1">
    <a href="#autotoc_md87">&#39;felt&#39; Dialect</a>
    <ul>
      <li class="level2">
        <a href="#autotoc_md88">Operations</a>
      </li>
      <li class="level2">
        <a href="#autotoc_md133">Attributes</a>
      </li>
      <li class="level2">
        <a href="#autotoc_md136">Types</a>
      </li>
    </ul>
  </li>
  <li class="level1">
    <a href="#autotoc_md138">&#39;function&#39; Dialect</a>
    <ul>
      <li class="level2">
        <a href="#autotoc_md139">Operations</a>
      </li>
    </ul>
  </li>
  <li class="level1">
    <a href="#autotoc_md148">&#39;global&#39; Dialect</a>
    <ul>
      <li class="level2">
        <a href="#autotoc_md149">Operations</a>
      </li>
    </ul>
  </li>
  <li class="level1">
    <a href="#autotoc_md158">&#39;include&#39; Dialect</a>
    <ul>
      <li class="level2">
        <a href="#autotoc_md159">Operations</a>
      </li>
    </ul>
  </li>
  <li class="level1">
    <a href="#autotoc_md162">&#39;llzk&#39; Dialect</a>
    <ul>
      <li class="level2">
        <a href="#autotoc_md163">Attributes</a>
      </li>
    </ul>
  </li>
  <li class="level1">
    <a href="#autotoc_md167">&#39;poly&#39; Dialect</a>
    <ul>
      <li class="level2">
        <a href="#autotoc_md168">Operations</a>
      </li>
      <li class="level2">
        <a href="#autotoc_md179">Types</a>
      </li>
    </ul>
  </li>
  <li class="level1">
    <a href="#autotoc_md182">&#39;string&#39; Dialect</a>
    <ul>
      <li class="level2">
        <a href="#autotoc_md183">Operations</a>
      </li>
      <li class="level2">
        <a href="#autotoc_md187">Types</a>
      </li>
    </ul>
  </li>
  <li class="level1">
    <a href="#autotoc_md189">&#39;struct&#39; Dialect</a>
    <ul>
      <li class="level2">
        <a href="#autotoc_md190">Operations</a>
      </li>
      <li class="level2">
        <a href="#autotoc_md204">Types</a>
      </li>
    </ul>
  </li>
  <li class="level1">
    <a href="#autotoc_md207">&#39;undef&#39; Dialect</a>
    <ul>
      <li class="level2">
        <a href="#autotoc_md208">Operations</a>
      </li>
    </ul>
  </li>
</ul>
</div>
<div class="textblock"><p><a class="anchor" id="md_doc_2doxygen_27__dialects"></a></p>
<h1><a class="anchor" id="autotoc_md45"></a>
'array' Dialect</h1>
<p>LLZK array operations.</p>
<h2><a class="anchor" id="autotoc_md46"></a>
Types</h2>
<h3><a class="anchor" id="autotoc_md47"></a>
ArrayType</h3>
<p>n-dimensional array</p>
<p>Syntax:</p>
<div class="fragment"><div class="line">!array.type&lt;</div>
<div class="line">  ::mlir::Type,   # elementType</div>
<div class="line">  ::llvm::ArrayRef&lt;::mlir::Attribute&gt;,   # dimensionSizes</div>
<div class="line">  ::llvm::ArrayRef&lt;int64_t&gt;   # shape</div>
<div class="line">&gt;</div>
</div><!-- fragment --><p>Array type with a ranked shape and homogeneous element type. It can only be instantiated with the following types:</p><ul>
<li>Any LLZK type</li>
<li>IndexType</li>
<li>Unsigned integers of 1 bit (aka booleans)</li>
</ul>
<div class="fragment"><div class="line">// Example array of 5 by 2 elements of `Felt` type.</div>
<div class="line">!array.type&lt;5,2 x !felt.type&gt;</div>
<div class="line"> </div>
<div class="line">// Example array using a struct parameter for one dimension.</div>
<div class="line">!array.type&lt;5,@A x index&gt;</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md48"></a>
Parameters:</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Parameter   </th><th class="markdownTableHeadCenter">C++ type   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">elementType   </td><td class="markdownTableBodyCenter"><code>mlir::Type</code>   </td><td class="markdownTableBodyNone">Type of all elements within the array.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">dimensionSizes   </td><td class="markdownTableBodyCenter"><code>::llvm::ArrayRef&lt;::mlir::Attribute&gt;</code>   </td><td class="markdownTableBodyNone">List of array dimension size specifiers.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">shape   </td><td class="markdownTableBodyCenter"><code>::llvm::ArrayRef&lt;int64_t&gt;</code>   </td><td class="markdownTableBodyNone">Array shape, for ShapedTypeInterface, computed from <code>$dimensionSizes</code>.   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md49"></a>
'bool' Dialect</h1>
<p>LLZK boolean operations.</p>
<h2><a class="anchor" id="autotoc_md50"></a>
Operations</h2>
<h3><a class="anchor" id="autotoc_md51"></a>
<code>bool.and</code> (::llzk::boolean::AndBoolOp)</h3>
<p><em>Logical AND operator</em></p>
<p>Syntax:</p>
<div class="fragment"><div class="line">operation ::= `bool.and` $lhs `,` $rhs</div>
<div class="line">              `` custom&lt;InferredOrParsedType&gt;(type($lhs), &quot;true&quot;)</div>
<div class="line">              `` custom&lt;InferredOrParsedType&gt;(type($rhs), &quot;false&quot;)</div>
<div class="line">              attr-dict</div>
</div><!-- fragment --><p>This operation computes the logical AND (i.e. conjunction) of two <code>i1</code> (i.e. boolean) values as an <code>i1</code> value. The result is <code>1</code> if the operation is true and <code>0</code> otherwise.</p>
<p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>WitnessGen</code></p>
<p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p>
<p>Effects: <code>MemoryEffects::Effect{}</code></p>
<h4><a class="anchor" id="autotoc_md52"></a>
Operands:</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Operand   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>lhs</code>   </td><td class="markdownTableBodyNone">1-bit signless integer or type variable    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"><code>rhs</code>   </td><td class="markdownTableBodyNone">1-bit signless integer or type variable   </td></tr>
</table>
<h4><a class="anchor" id="autotoc_md53"></a>
Results:</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Result   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>result</code>   </td><td class="markdownTableBodyNone">1-bit signless integer   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md54"></a>
<code>bool.assert</code> (::llzk::boolean::AssertOp)</h3>
<p><em>Assertion operation</em></p>
<p>Syntax:</p>
<div class="fragment"><div class="line">operation ::= `bool.assert` $condition (`,` $msg^)? attr-dict</div>
</div><!-- fragment --><p>This operation asserts that a given boolean value is true. Assertions are checked statically when possible. If the condition evaluates to <code>true</code>, the assertion is removed. If <code>false</code>, an error is reported. Otherwise, the assertion is preserved. All assertions that appear in <code>constrain()</code> functions must evaluate statically (i.e. they cannot depend on inputs to the circuit) else an error is reported.</p>
<p>Assertion without message: </p><div class="fragment"><div class="line">%1 = bool.cmp lt(%a, %b)</div>
<div class="line">bool.assert %1</div>
</div><!-- fragment --><p>Assertion with a message: </p><div class="fragment"><div class="line">%1 = bool.cmp eq(%a, %b)</div>
<div class="line">bool.assert %1, &quot;expected equal values&quot;</div>
</div><!-- fragment --><p>Interfaces: <code>MemoryEffectOpInterface</code></p>
<h4><a class="anchor" id="autotoc_md55"></a>
Attributes:</h4>
<table class="doxtable">
<tr>
<th>Attribute</th><th>MLIR Type</th><th>Description </th></tr>
<tr>
<td><code>msg</code></td><td>::mlir::StringAttr</td><td>string attribute </td></tr>
</table>
<h4><a class="anchor" id="autotoc_md56"></a>
Operands:</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Operand   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>condition</code>   </td><td class="markdownTableBodyNone">1-bit signless integer   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md57"></a>
<code>bool.cmp</code> (::llzk::boolean::CmpOp)</h3>
<p><em>Compare field element values</em></p>
<p>Syntax:</p>
<div class="fragment"><div class="line">operation ::= `bool.cmp` `` $predicate `(` $lhs `,` $rhs `)` attr-dict</div>
</div><!-- fragment --><p>This operation takes two field element values and compares them according to the comparison predicate and returns an <code>i1</code>. The following comparisons are supported:</p>
<ul>
<li><code>eq</code>: equal</li>
<li><code>ne</code>: not equal</li>
<li><code>lt</code>: less than</li>
<li><code>le</code>: less than or equal</li>
<li><code>gt</code>: greater than</li>
<li><code>ge</code>: greater than or equal</li>
</ul>
<p>The result is <code>1</code> if the comparison is true and <code>0</code> otherwise.</p>
<p>The inequality operators (lt, gt, le, ge) for the finite field elements are defined by treating the field elements as integer values: <code>f1 op f2</code> iff <code>int(f1) op int(f2)</code></p>
<p>Example:</p>
<div class="fragment"><div class="line">// Less than comparison.</div>
<div class="line">%0 = bool.cmp lt(%a, %b)</div>
<div class="line"> </div>
<div class="line">// Greater than or equal comparison.</div>
<div class="line">%1 = bool.cmp ge(%a, %b)</div>
<div class="line"> </div>
<div class="line">// Not equal comparison.</div>
<div class="line">%2 = bool.cmp ne(%a, %b)</div>
</div><!-- fragment --><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p>
<p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p>
<p>Effects: <code>MemoryEffects::Effect{}</code></p>
<h4><a class="anchor" id="autotoc_md58"></a>
Attributes:</h4>
<table class="doxtable">
<tr>
<th>Attribute</th><th>MLIR Type</th><th>Description </th></tr>
<tr>
<td><code>predicate</code></td><td>::llzk::boolean::FeltCmpPredicateAttr</td><td>Field element comparison predicate </td></tr>
</table>
<h4><a class="anchor" id="autotoc_md59"></a>
Operands:</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Operand   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>lhs</code>   </td><td class="markdownTableBodyNone">finite field element    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"><code>rhs</code>   </td><td class="markdownTableBodyNone">finite field element   </td></tr>
</table>
<h4><a class="anchor" id="autotoc_md60"></a>
Results:</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Result   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>result</code>   </td><td class="markdownTableBodyNone">1-bit signless integer   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md61"></a>
<code>bool.not</code> (::llzk::boolean::NotBoolOp)</h3>
<p><em>Logical NOT operator</em></p>
<p>Syntax:</p>
<div class="fragment"><div class="line">operation ::= `bool.not` $operand</div>
<div class="line">              `` custom&lt;InferredOrParsedType&gt;(type($operand), &quot;true&quot;)</div>
<div class="line">              attr-dict</div>
</div><!-- fragment --><p>This operation computes the logical NOT (i.e. negation) of an <code>i1</code> (i.e. boolean) value as an <code>i1</code> value. The result is <code>1</code> if the operation is true and <code>0</code> otherwise.</p>
<p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>WitnessGen</code></p>
<p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p>
<p>Effects: <code>MemoryEffects::Effect{}</code></p>
<h4><a class="anchor" id="autotoc_md62"></a>
Operands:</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Operand   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>operand</code>   </td><td class="markdownTableBodyNone">1-bit signless integer or type variable   </td></tr>
</table>
<h4><a class="anchor" id="autotoc_md63"></a>
Results:</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Result   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>result</code>   </td><td class="markdownTableBodyNone">1-bit signless integer   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md64"></a>
<code>bool.or</code> (::llzk::boolean::OrBoolOp)</h3>
<p><em>Logical OR operator</em></p>
<p>Syntax:</p>
<div class="fragment"><div class="line">operation ::= `bool.or` $lhs `,` $rhs</div>
<div class="line">              `` custom&lt;InferredOrParsedType&gt;(type($lhs), &quot;true&quot;)</div>
<div class="line">              `` custom&lt;InferredOrParsedType&gt;(type($rhs), &quot;false&quot;)</div>
<div class="line">              attr-dict</div>
</div><!-- fragment --><p>This operation computes the logical OR (i.e. disjunction) of two <code>i1</code> (i.e. boolean) values as an <code>i1</code> value. The result is <code>1</code> if the operation is true and <code>0</code> otherwise.</p>
<p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>WitnessGen</code></p>
<p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p>
<p>Effects: <code>MemoryEffects::Effect{}</code></p>
<h4><a class="anchor" id="autotoc_md65"></a>
Operands:</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Operand   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>lhs</code>   </td><td class="markdownTableBodyNone">1-bit signless integer or type variable    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"><code>rhs</code>   </td><td class="markdownTableBodyNone">1-bit signless integer or type variable   </td></tr>
</table>
<h4><a class="anchor" id="autotoc_md66"></a>
Results:</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Result   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>result</code>   </td><td class="markdownTableBodyNone">1-bit signless integer   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md67"></a>
<code>bool.xor</code> (::llzk::boolean::XorBoolOp)</h3>
<p><em>Logical XOR operator</em></p>
<p>Syntax:</p>
<div class="fragment"><div class="line">operation ::= `bool.xor` $lhs `,` $rhs</div>
<div class="line">              `` custom&lt;InferredOrParsedType&gt;(type($lhs), &quot;true&quot;)</div>
<div class="line">              `` custom&lt;InferredOrParsedType&gt;(type($rhs), &quot;false&quot;)</div>
<div class="line">              attr-dict</div>
</div><!-- fragment --><p>This operation computes the logical XOR (i.e. exclusive disjunction) of two <code>i1</code> (i.e. boolean) values as an <code>i1</code> value. The result is <code>1</code> if the operation is true and <code>0</code> otherwise.</p>
<p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>WitnessGen</code></p>
<p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p>
<p>Effects: <code>MemoryEffects::Effect{}</code></p>
<h4><a class="anchor" id="autotoc_md68"></a>
Operands:</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Operand   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>lhs</code>   </td><td class="markdownTableBodyNone">1-bit signless integer or type variable    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"><code>rhs</code>   </td><td class="markdownTableBodyNone">1-bit signless integer or type variable   </td></tr>
</table>
<h4><a class="anchor" id="autotoc_md69"></a>
Results:</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Result   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>result</code>   </td><td class="markdownTableBodyNone">1-bit signless integer   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md70"></a>
Attributes</h2>
<h3><a class="anchor" id="autotoc_md71"></a>
FeltCmpPredicateAttr</h3>
<p>Field element comparison predicate</p>
<p>Syntax:</p>
<div class="fragment"><div class="line">#bool.cmp&lt;</div>
<div class="line">  ::llzk::boolean::FeltCmpPredicate   # value</div>
<div class="line">&gt;</div>
</div><!-- fragment --><p>Enum cases:</p><ul>
<li>eq (<code>EQ</code>)</li>
<li>ne (<code>NE</code>)</li>
<li>lt (<code>LT</code>)</li>
<li>le (<code>LE</code>)</li>
<li>gt (<code>GT</code>)</li>
<li>ge (<code>GE</code>) </li>
</ul>
<h4><a class="anchor" id="autotoc_md72"></a>
Parameters:</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Parameter   </th><th class="markdownTableHeadCenter">C++ type   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">value   </td><td class="markdownTableBodyCenter"><code><a class="el" href="namespacellzk_1_1boolean.html#aa2a08eb552270cddaf816ec7c01afd37">llzk::boolean::FeltCmpPredicate</a></code>   </td><td class="markdownTableBodyNone">an enum of type FeltCmpPredicate   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md73"></a>
'cast' Dialect</h1>
<p>LLZK type conversion operations.</p>
<h2><a class="anchor" id="autotoc_md74"></a>
Operations</h2>
<h3><a class="anchor" id="autotoc_md75"></a>
<code>cast.tofelt</code> (::llzk::cast::IntToFeltOp)</h3>
<p><em>Convert an integer into a field element</em></p>
<p>Syntax:</p>
<div class="fragment"><div class="line">operation ::= `cast.tofelt` $value `:` type($value) attr-dict</div>
</div><!-- fragment --><p>This operation converts a supported integer type value into a field element value.</p>
<p>Example:</p>
<div class="fragment"><div class="line">%0 = bool.cmp lt(%a, %b)</div>
<div class="line">%1 = cast.tofelt %0 : i1</div>
</div><!-- fragment --><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p>
<p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p>
<p>Effects: <code>MemoryEffects::Effect{}</code></p>
<h4><a class="anchor" id="autotoc_md76"></a>
Operands:</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Operand   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>value</code>   </td><td class="markdownTableBodyNone">1-bit signless integer or index   </td></tr>
</table>
<h4><a class="anchor" id="autotoc_md77"></a>
Results:</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Result   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>result</code>   </td><td class="markdownTableBodyNone">finite field element   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md78"></a>
<code>cast.toindex</code> (::llzk::cast::FeltToIndexOp)</h3>
<p><em>Convert a field element into an index</em></p>
<p>Syntax:</p>
<div class="fragment"><div class="line">operation ::= `cast.toindex` $value attr-dict</div>
</div><!-- fragment --><p>This operation converts a field element value into an index value to allow use as an array index or loop bound. In struct @constrain functions, the argument to this op is not allowed to be derived from a Signal struct.</p>
<p>Example: </p><div class="fragment"><div class="line">%0 = cast.toindex %a</div>
<div class="line">%1 = array.read %b[%0]</div>
</div><!-- fragment --><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p>
<p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p>
<p>Effects: <code>MemoryEffects::Effect{}</code></p>
<h4><a class="anchor" id="autotoc_md79"></a>
Operands:</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Operand   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>value</code>   </td><td class="markdownTableBodyNone">finite field element   </td></tr>
</table>
<h4><a class="anchor" id="autotoc_md80"></a>
Results:</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Result   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>result</code>   </td><td class="markdownTableBodyNone">index   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md81"></a>
'constrain' Dialect</h1>
<p>LLZK constraint emission operations.</p>
<h2><a class="anchor" id="autotoc_md82"></a>
Operations</h2>
<h3><a class="anchor" id="autotoc_md83"></a>
<code>constrain.eq</code> (::llzk::constrain::EmitEqualityOp)</h3>
<p><em>Emit an equality constraint</em></p>
<p>Syntax:</p>
<div class="fragment"><div class="line">operation ::= `constrain.eq` $lhs `,` $rhs `:` type($lhs)</div>
<div class="line">              `` custom&lt;InferredOrParsedType&gt;(type($rhs), ref(type($lhs)))</div>
<div class="line">              attr-dict</div>
</div><!-- fragment --><p>Emits an equality constraint between lhs and rhs. For the built-in Signal struct, the constraint is performed on the Signal's inner <code>@reg</code> felt field.</p>
<p>Traits: <code>Commutative</code>, <code>ConstraintGen</code>, <code>Elementwise</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p>
<p>Interfaces: <code>ConstraintOpInterface</code>, <code>SymbolUserOpInterface</code></p>
<h4><a class="anchor" id="autotoc_md84"></a>
Operands:</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Operand   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>lhs</code>   </td><td class="markdownTableBodyNone">any LLZK type, excluding non-Signal struct and string types    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"><code>rhs</code>   </td><td class="markdownTableBodyNone">any LLZK type, excluding non-Signal struct and string types   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md85"></a>
<code>constrain.in</code> (::llzk::constrain::EmitContainmentOp)</h3>
<p><em>Emit a containment constraint</em></p>
<p>Syntax:</p>
<div class="fragment"><div class="line">operation ::= `constrain.in` $lhs `,` $rhs `:` type($lhs)</div>
<div class="line">              `` custom&lt;InferredOrParsedType&gt;(type($rhs), ref(type($lhs)))</div>
<div class="line">              attr-dict</div>
</div><!-- fragment --><p>Traits: <code>ConstraintGen</code></p>
<p>Interfaces: <code>ConstraintOpInterface</code>, <code>SymbolUserOpInterface</code></p>
<h4><a class="anchor" id="autotoc_md86"></a>
Operands:</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Operand   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>lhs</code>   </td><td class="markdownTableBodyNone">n-dimensional array    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"><code>rhs</code>   </td><td class="markdownTableBodyNone">a valid array element type   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md87"></a>
'felt' Dialect</h1>
<p>LLZK felt (Field ELemenT) type and operations.</p>
<h2><a class="anchor" id="autotoc_md88"></a>
Operations</h2>
<h3><a class="anchor" id="autotoc_md89"></a>
<code>felt.add</code> (::llzk::felt::AddFeltOp)</h3>
<p><em>Addition operator for field elements</em></p>
<p>Syntax:</p>
<div class="fragment"><div class="line">operation ::= `felt.add` $lhs `,` $rhs</div>
<div class="line">              `` custom&lt;InferredOrParsedType&gt;(type($lhs), &quot;true&quot;)</div>
<div class="line">              `` custom&lt;InferredOrParsedType&gt;(type($rhs), &quot;false&quot;)</div>
<div class="line">              attr-dict</div>
</div><!-- fragment --><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code></p>
<p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p>
<p>Effects: <code>MemoryEffects::Effect{}</code></p>
<h4><a class="anchor" id="autotoc_md90"></a>
Operands:</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Operand   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>lhs</code>   </td><td class="markdownTableBodyNone">finite field element or type variable    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"><code>rhs</code>   </td><td class="markdownTableBodyNone">finite field element or type variable   </td></tr>
</table>
<h4><a class="anchor" id="autotoc_md91"></a>
Results:</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Result   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>result</code>   </td><td class="markdownTableBodyNone">finite field element   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md92"></a>
<code>felt.bit_and</code> (::llzk::felt::AndFeltOp)</h3>
<p><em>Bitwise AND operator for field elements</em></p>
<p>Syntax:</p>
<div class="fragment"><div class="line">operation ::= `felt.bit_and` $lhs `,` $rhs</div>
<div class="line">              `` custom&lt;InferredOrParsedType&gt;(type($lhs), &quot;true&quot;)</div>
<div class="line">              `` custom&lt;InferredOrParsedType&gt;(type($rhs), &quot;false&quot;)</div>
<div class="line">              attr-dict</div>
</div><!-- fragment --><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>WitnessGen</code></p>
<p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p>
<p>Effects: <code>MemoryEffects::Effect{}</code></p>
<h4><a class="anchor" id="autotoc_md93"></a>
Operands:</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Operand   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>lhs</code>   </td><td class="markdownTableBodyNone">finite field element or type variable    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"><code>rhs</code>   </td><td class="markdownTableBodyNone">finite field element or type variable   </td></tr>
</table>
<h4><a class="anchor" id="autotoc_md94"></a>
Results:</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Result   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>result</code>   </td><td class="markdownTableBodyNone">finite field element   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md95"></a>
<code>felt.bit_not</code> (::llzk::felt::NotFeltOp)</h3>
<p><em>Bit flip operator for field elements</em></p>
<p>Syntax:</p>
<div class="fragment"><div class="line">operation ::= `felt.bit_not` $operand</div>
<div class="line">              `` custom&lt;InferredOrParsedType&gt;(type($operand), &quot;true&quot;)</div>
<div class="line">              attr-dict</div>
</div><!-- fragment --><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>WitnessGen</code></p>
<p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p>
<p>Effects: <code>MemoryEffects::Effect{}</code></p>
<h4><a class="anchor" id="autotoc_md96"></a>
Operands:</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Operand   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>operand</code>   </td><td class="markdownTableBodyNone">finite field element or type variable   </td></tr>
</table>
<h4><a class="anchor" id="autotoc_md97"></a>
Results:</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Result   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>result</code>   </td><td class="markdownTableBodyNone">finite field element   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md98"></a>
<code>felt.bit_or</code> (::llzk::felt::OrFeltOp)</h3>
<p><em>Bitwise OR operator for field elements</em></p>
<p>Syntax:</p>
<div class="fragment"><div class="line">operation ::= `felt.bit_or` $lhs `,` $rhs</div>
<div class="line">              `` custom&lt;InferredOrParsedType&gt;(type($lhs), &quot;true&quot;)</div>
<div class="line">              `` custom&lt;InferredOrParsedType&gt;(type($rhs), &quot;false&quot;)</div>
<div class="line">              attr-dict</div>
</div><!-- fragment --><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>WitnessGen</code></p>
<p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p>
<p>Effects: <code>MemoryEffects::Effect{}</code></p>
<h4><a class="anchor" id="autotoc_md99"></a>
Operands:</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Operand   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>lhs</code>   </td><td class="markdownTableBodyNone">finite field element or type variable    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"><code>rhs</code>   </td><td class="markdownTableBodyNone">finite field element or type variable   </td></tr>
</table>
<h4><a class="anchor" id="autotoc_md100"></a>
Results:</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Result   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>result</code>   </td><td class="markdownTableBodyNone">finite field element   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md101"></a>
<code>felt.bit_xor</code> (::llzk::felt::XorFeltOp)</h3>
<p><em>Bitwise XOR operator for field elements</em></p>
<p>Syntax:</p>
<div class="fragment"><div class="line">operation ::= `felt.bit_xor` $lhs `,` $rhs</div>
<div class="line">              `` custom&lt;InferredOrParsedType&gt;(type($lhs), &quot;true&quot;)</div>
<div class="line">              `` custom&lt;InferredOrParsedType&gt;(type($rhs), &quot;false&quot;)</div>
<div class="line">              attr-dict</div>
</div><!-- fragment --><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>WitnessGen</code></p>
<p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p>
<p>Effects: <code>MemoryEffects::Effect{}</code></p>
<h4><a class="anchor" id="autotoc_md102"></a>
Operands:</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Operand   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>lhs</code>   </td><td class="markdownTableBodyNone">finite field element or type variable    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"><code>rhs</code>   </td><td class="markdownTableBodyNone">finite field element or type variable   </td></tr>
</table>
<h4><a class="anchor" id="autotoc_md103"></a>
Results:</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Result   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>result</code>   </td><td class="markdownTableBodyNone">finite field element   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md104"></a>
<code>felt.const</code> (::llzk::felt::FeltConstantOp)</h3>
<p><em>Field element constant</em></p>
<p>Syntax:</p>
<div class="fragment"><div class="line">operation ::= `felt.const` $value attr-dict</div>
</div><!-- fragment --><p>This operation produces a felt-typed SSA value holding an integer constant.</p>
<p>Example:</p>
<div class="fragment"><div class="line">%0 = llzk.const 42</div>
</div><!-- fragment --><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>ConstantLike</code></p>
<p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>OpAsmOpInterface</code></p>
<p>Effects: <code>MemoryEffects::Effect{}</code></p>
<h4><a class="anchor" id="autotoc_md105"></a>
Attributes:</h4>
<table class="doxtable">
<tr>
<th>Attribute</th><th>MLIR Type</th><th>Description </th></tr>
<tr>
<td><code>value</code></td><td>::llzk::felt::FeltConstAttr</td><td>finite field element </td></tr>
</table>
<h4><a class="anchor" id="autotoc_md106"></a>
Results:</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Result   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>result</code>   </td><td class="markdownTableBodyNone">finite field element   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md107"></a>
<code>felt.div</code> (::llzk::felt::DivFeltOp)</h3>
<p><em>Division operator for field elements</em></p>
<p>Syntax:</p>
<div class="fragment"><div class="line">operation ::= `felt.div` $lhs `,` $rhs</div>
<div class="line">              `` custom&lt;InferredOrParsedType&gt;(type($lhs), &quot;true&quot;)</div>
<div class="line">              `` custom&lt;InferredOrParsedType&gt;(type($rhs), &quot;false&quot;)</div>
<div class="line">              attr-dict</div>
</div><!-- fragment --><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p>
<p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p>
<p>Effects: <code>MemoryEffects::Effect{}</code></p>
<h4><a class="anchor" id="autotoc_md108"></a>
Operands:</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Operand   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>lhs</code>   </td><td class="markdownTableBodyNone">finite field element or type variable    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"><code>rhs</code>   </td><td class="markdownTableBodyNone">finite field element or type variable   </td></tr>
</table>
<h4><a class="anchor" id="autotoc_md109"></a>
Results:</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Result   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>result</code>   </td><td class="markdownTableBodyNone">finite field element   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md110"></a>
<code>felt.inv</code> (::llzk::felt::InvFeltOp)</h3>
<p><em>Inverse operator for field elements</em></p>
<p>Syntax:</p>
<div class="fragment"><div class="line">operation ::= `felt.inv` $operand</div>
<div class="line">              `` custom&lt;InferredOrParsedType&gt;(type($operand), &quot;true&quot;)</div>
<div class="line">              attr-dict</div>
</div><!-- fragment --><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>WitnessGen</code></p>
<p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p>
<p>Effects: <code>MemoryEffects::Effect{}</code></p>
<h4><a class="anchor" id="autotoc_md111"></a>
Operands:</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Operand   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>operand</code>   </td><td class="markdownTableBodyNone">finite field element or type variable   </td></tr>
</table>
<h4><a class="anchor" id="autotoc_md112"></a>
Results:</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Result   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>result</code>   </td><td class="markdownTableBodyNone">finite field element   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md113"></a>
<code>felt.mod</code> (::llzk::felt::ModFeltOp)</h3>
<p><em>Modulus/remainder operator for field elements</em></p>
<p>Syntax:</p>
<div class="fragment"><div class="line">operation ::= `felt.mod` $lhs `,` $rhs</div>
<div class="line">              `` custom&lt;InferredOrParsedType&gt;(type($lhs), &quot;true&quot;)</div>
<div class="line">              `` custom&lt;InferredOrParsedType&gt;(type($rhs), &quot;false&quot;)</div>
<div class="line">              attr-dict</div>
</div><!-- fragment --><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p>
<p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p>
<p>Effects: <code>MemoryEffects::Effect{}</code></p>
<h4><a class="anchor" id="autotoc_md114"></a>
Operands:</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Operand   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>lhs</code>   </td><td class="markdownTableBodyNone">finite field element or type variable    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"><code>rhs</code>   </td><td class="markdownTableBodyNone">finite field element or type variable   </td></tr>
</table>
<h4><a class="anchor" id="autotoc_md115"></a>
Results:</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Result   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>result</code>   </td><td class="markdownTableBodyNone">finite field element   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md116"></a>
<code>felt.mul</code> (::llzk::felt::MulFeltOp)</h3>
<p><em>Multiplication operator for field elements</em></p>
<p>Syntax:</p>
<div class="fragment"><div class="line">operation ::= `felt.mul` $lhs `,` $rhs</div>
<div class="line">              `` custom&lt;InferredOrParsedType&gt;(type($lhs), &quot;true&quot;)</div>
<div class="line">              `` custom&lt;InferredOrParsedType&gt;(type($rhs), &quot;false&quot;)</div>
<div class="line">              attr-dict</div>
</div><!-- fragment --><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code></p>
<p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p>
<p>Effects: <code>MemoryEffects::Effect{}</code></p>
<h4><a class="anchor" id="autotoc_md117"></a>
Operands:</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Operand   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>lhs</code>   </td><td class="markdownTableBodyNone">finite field element or type variable    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"><code>rhs</code>   </td><td class="markdownTableBodyNone">finite field element or type variable   </td></tr>
</table>
<h4><a class="anchor" id="autotoc_md118"></a>
Results:</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Result   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>result</code>   </td><td class="markdownTableBodyNone">finite field element   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md119"></a>
<code>felt.neg</code> (::llzk::felt::NegFeltOp)</h3>
<p><em>Negation operator for field elements</em></p>
<p>Syntax:</p>
<div class="fragment"><div class="line">operation ::= `felt.neg` $operand</div>
<div class="line">              `` custom&lt;InferredOrParsedType&gt;(type($operand), &quot;true&quot;)</div>
<div class="line">              attr-dict</div>
</div><!-- fragment --><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p>
<p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p>
<p>Effects: <code>MemoryEffects::Effect{}</code></p>
<h4><a class="anchor" id="autotoc_md120"></a>
Operands:</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Operand   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>operand</code>   </td><td class="markdownTableBodyNone">finite field element or type variable   </td></tr>
</table>
<h4><a class="anchor" id="autotoc_md121"></a>
Results:</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Result   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>result</code>   </td><td class="markdownTableBodyNone">finite field element   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md122"></a>
<code>felt.nondet</code> (::llzk::felt::FeltNonDetOp)</h3>
<p><em>Uninitialized field element</em></p>
<p>Syntax:</p>
<div class="fragment"><div class="line">operation ::= `felt.nondet` attr-dict</div>
</div><!-- fragment --><p>This operation produces a felt-typed SSA value without a specified value. This can be used in <code>constrain()</code> functions in place of expressions that cannot be included in constraints.</p>
<p>Example:</p>
<div class="fragment"><div class="line">%0 = llzk.nondet</div>
</div><!-- fragment --><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>ConstantLike</code></p>
<p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>OpAsmOpInterface</code></p>
<p>Effects: <code>MemoryEffects::Effect{}</code></p>
<h4><a class="anchor" id="autotoc_md123"></a>
Results:</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Result   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>result</code>   </td><td class="markdownTableBodyNone">finite field element   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md124"></a>
<code>felt.shl</code> (::llzk::felt::ShlFeltOp)</h3>
<p><em>Left shift operator for field elements</em></p>
<p>Syntax:</p>
<div class="fragment"><div class="line">operation ::= `felt.shl` $lhs `,` $rhs</div>
<div class="line">              `` custom&lt;InferredOrParsedType&gt;(type($lhs), &quot;true&quot;)</div>
<div class="line">              `` custom&lt;InferredOrParsedType&gt;(type($rhs), &quot;false&quot;)</div>
<div class="line">              attr-dict</div>
</div><!-- fragment --><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>WitnessGen</code></p>
<p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p>
<p>Effects: <code>MemoryEffects::Effect{}</code></p>
<h4><a class="anchor" id="autotoc_md125"></a>
Operands:</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Operand   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>lhs</code>   </td><td class="markdownTableBodyNone">finite field element or type variable    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"><code>rhs</code>   </td><td class="markdownTableBodyNone">finite field element or type variable   </td></tr>
</table>
<h4><a class="anchor" id="autotoc_md126"></a>
Results:</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Result   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>result</code>   </td><td class="markdownTableBodyNone">finite field element   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md127"></a>
<code>felt.shr</code> (::llzk::felt::ShrFeltOp)</h3>
<p><em>Right shift operator for field elements</em></p>
<p>Syntax:</p>
<div class="fragment"><div class="line">operation ::= `felt.shr` $lhs `,` $rhs</div>
<div class="line">              `` custom&lt;InferredOrParsedType&gt;(type($lhs), &quot;true&quot;)</div>
<div class="line">              `` custom&lt;InferredOrParsedType&gt;(type($rhs), &quot;false&quot;)</div>
<div class="line">              attr-dict</div>
</div><!-- fragment --><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>WitnessGen</code></p>
<p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p>
<p>Effects: <code>MemoryEffects::Effect{}</code></p>
<h4><a class="anchor" id="autotoc_md128"></a>
Operands:</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Operand   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>lhs</code>   </td><td class="markdownTableBodyNone">finite field element or type variable    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"><code>rhs</code>   </td><td class="markdownTableBodyNone">finite field element or type variable   </td></tr>
</table>
<h4><a class="anchor" id="autotoc_md129"></a>
Results:</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Result   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>result</code>   </td><td class="markdownTableBodyNone">finite field element   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md130"></a>
<code>felt.sub</code> (::llzk::felt::SubFeltOp)</h3>
<p><em>Subtraction operator for field elements</em></p>
<p>Syntax:</p>
<div class="fragment"><div class="line">operation ::= `felt.sub` $lhs `,` $rhs</div>
<div class="line">              `` custom&lt;InferredOrParsedType&gt;(type($lhs), &quot;true&quot;)</div>
<div class="line">              `` custom&lt;InferredOrParsedType&gt;(type($rhs), &quot;false&quot;)</div>
<div class="line">              attr-dict</div>
</div><!-- fragment --><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p>
<p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p>
<p>Effects: <code>MemoryEffects::Effect{}</code></p>
<h4><a class="anchor" id="autotoc_md131"></a>
Operands:</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Operand   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>lhs</code>   </td><td class="markdownTableBodyNone">finite field element or type variable    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"><code>rhs</code>   </td><td class="markdownTableBodyNone">finite field element or type variable   </td></tr>
</table>
<h4><a class="anchor" id="autotoc_md132"></a>
Results:</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Result   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>result</code>   </td><td class="markdownTableBodyNone">finite field element   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md133"></a>
Attributes</h2>
<h3><a class="anchor" id="autotoc_md134"></a>
FeltConstAttr</h3>
<p>finite field element</p>
<p>Syntax:</p>
<div class="fragment"><div class="line">#felt.felt.const&lt;</div>
<div class="line">  ::llvm::APInt   # value</div>
<div class="line">&gt;</div>
</div><!-- fragment --><p>A felt attribute represents a finite field element.</p>
<h4><a class="anchor" id="autotoc_md135"></a>
Parameters:</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Parameter   </th><th class="markdownTableHeadCenter">C++ type   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">value   </td><td class="markdownTableBodyCenter"><code>::llvm::APInt</code>   </td><td class="markdownTableBodyNone">The felt constant value   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md136"></a>
Types</h2>
<h3><a class="anchor" id="autotoc_md137"></a>
FeltType</h3>
<p>finite field element</p>
<p>Syntax: <code>!felt.type</code></p>
<h1><a class="anchor" id="autotoc_md138"></a>
'function' Dialect</h1>
<p>LLZK function operations.</p>
<h2><a class="anchor" id="autotoc_md139"></a>
Operations</h2>
<h3><a class="anchor" id="autotoc_md140"></a>
<code>function.call</code> (::llzk::function::CallOp)</h3>
<p><em>Call operation</em></p>
<p>Syntax:</p>
<div class="fragment"><div class="line">operation ::= `function.call` $callee `(` $argOperands `)`</div>
<div class="line">              ( `{` custom&lt;MultiDimAndSymbolList&gt;($mapOperands, $numDimsPerMap)^ `}` )?</div>
<div class="line">              `:` functional-type($argOperands, results)</div>
<div class="line">              custom&lt;AttrDictWithWarnings&gt;(attr-dict, prop-dict)</div>
</div><!-- fragment --><p>The <code>function.call</code> operation represents a call to another function. The operands and result types of the call must match the specified function type. The callee is encoded as a symbol reference attribute named "callee" which must be the full path to the target function from the root module (i.e. the module containing the [<a class="el" href="namespacellzk.html#a1b66c1ee1b386cb29f255332f586e96d" title="Name of the attribute on the top-level ModuleOp that specifies the IR language name.">llzk::LANG_ATTR_NAME</a>] attribute).</p>
<p>Example: </p><div class="fragment"><div class="line">// Call a global function defined in the root module.</div>
<div class="line">function.call @do_stuff(%0) : (!struct.type&lt;@Bob&gt;) -&gt; ()</div>
<div class="line">%1, %2 = function.call @split(%x) : (index) -&gt; (index, index)</div>
<div class="line"> </div>
<div class="line">// Call a function within a component</div>
<div class="line">%2 = function.call @OtherStruct::@compute(%3, %4) : (index, index) -&gt; !struct.type&lt;@OtherStruct&gt;</div>
<div class="line">function.call @OtherStruct::@constrain(%5, %6) : (!struct.type&lt;@OtherStruct&gt;, !felt.type) -&gt; ()</div>
</div><!-- fragment --><p>When the return StructType of a <code>compute()</code> function uses AffineMapAttr to express struct parameter(s) that depend on a loop variable, the optional instantiation parameter list of this operation must be used to instatiate all AffineMap used as parameters to the StructType.</p>
<p>Examples: </p><div class="fragment"><div class="line">#M = affine_map&lt;(i)[] -&gt; (5*i+1)&gt;</div>
<div class="line">%r = function.call @A::@compute(%x){(%i)} : (!felt.type) -&gt; !struct.type&lt;@A&lt;[#M]&gt;&gt;</div>
</div><!-- fragment --><p>Traits: <code>AttrSizedOperandSegments</code>, <code>MemRefsNormalizable</code>, <code>VerifySizesForMultiAffineOps&lt;1&gt;</code></p>
<p>Interfaces: <code>CallOpInterface</code>, <code>SymbolUserOpInterface</code></p>
<h4><a class="anchor" id="autotoc_md141"></a>
Attributes:</h4>
<table class="doxtable">
<tr>
<th>Attribute</th><th>MLIR Type</th><th>Description </th></tr>
<tr>
<td><code>callee</code></td><td>::mlir::SymbolRefAttr</td><td>symbol reference attribute </td></tr>
<tr>
<td><code>numDimsPerMap</code></td><td>::mlir::DenseI32ArrayAttr</td><td>i32 dense array attribute </td></tr>
<tr>
<td><code>mapOpGroupSizes</code></td><td>::mlir::DenseI32ArrayAttr</td><td>i32 dense array attribute </td></tr>
</table>
<h4><a class="anchor" id="autotoc_md142"></a>
Operands:</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Operand   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>argOperands</code>   </td><td class="markdownTableBodyNone">variadic of a valid LLZK type    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"><code>mapOperands</code>   </td><td class="markdownTableBodyNone">variadic of index   </td></tr>
</table>
<h4><a class="anchor" id="autotoc_md143"></a>
Results:</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Result   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">&laquo;unnamed&raquo;   </td><td class="markdownTableBodyNone">variadic of a valid LLZK type   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md144"></a>
<code>function.def</code> (::llzk::function::FuncDefOp)</h3>
<p><em>An operation with a name containing a single <code>SSACFG</code> region</em></p>
<p>Operations within the function cannot implicitly capture values defined outside of the function, i.e. Functions are <code>IsolatedFromAbove</code>. All external references must use function arguments or attributes that establish a symbolic connection (e.g. symbols referenced by name via a string attribute like SymbolRefAttr). An external function declaration (used when referring to a function declared in some other module) has no body. While the MLIR textual form provides a nice inline syntax for function arguments, they are internally represented as block arguments to the first block in the region.</p>
<p>Only dialect attribute names may be specified in the attribute dictionaries for function arguments, results, or the function itself.</p>
<p>Example:</p>
<div class="fragment"><div class="line">// External function definitions.</div>
<div class="line">function.def private @abort()</div>
<div class="line">function.def private @scribble(!array.type&lt;5 x !felt.type&gt;, !struct.type&lt;@Hello&gt;) -&gt; i1</div>
<div class="line"> </div>
<div class="line">// A function that returns its argument twice:</div>
<div class="line">function.def @count(%x: !felt.type) -&gt; (!felt.type, !felt.type) {</div>
<div class="line">  return %x, %x: !felt.type, !felt.type</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// Function definition within a component</div>
<div class="line">struct.def @NonZero {</div>
<div class="line">  function.def @compute(%a: !felt.type) { return }</div>
<div class="line">  function.def @constrain(%a: !felt.type) { return }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Traits: <code>AffineScope</code>, <code>AutomaticAllocationScope</code>, <code>HasParent&lt;::mlir::ModuleOp, <a class="el" href="classllzk_1_1component_1_1_struct_def_op.html">llzk::component::StructDefOp</a>&gt;</code>, <code>IsolatedFromAbove</code></p>
<p>Interfaces: <code>CallableOpInterface</code>, <code>FunctionOpInterface</code>, <code>SymbolUserOpInterface</code>, <code>Symbol</code></p>
<h4><a class="anchor" id="autotoc_md145"></a>
Attributes:</h4>
<table class="doxtable">
<tr>
<th>Attribute</th><th>MLIR Type</th><th>Description </th></tr>
<tr>
<td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute </td></tr>
<tr>
<td><code>function_type</code></td><td>::mlir::TypeAttr</td><td>type attribute of function type </td></tr>
<tr>
<td><code>arg_attrs</code></td><td>::mlir::ArrayAttr</td><td>Array of dictionary attributes </td></tr>
<tr>
<td><code>res_attrs</code></td><td>::mlir::ArrayAttr</td><td>Array of dictionary attributes </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md146"></a>
<code>function.return</code> (::llzk::function::ReturnOp)</h3>
<p><em>Function return operation</em></p>
<p>Syntax:</p>
<div class="fragment"><div class="line">operation ::= `function.return` attr-dict ($operands^ `:` type($operands))?</div>
</div><!-- fragment --><p>The <code>function.return</code> operation represents a return operation within a function. The operation takes variable number of operands and produces no results. The operand number and types must match the signature of the function that contains the operation.</p>
<p>Example:</p>
<div class="fragment"><div class="line">function.def @foo() : (!felt.type, index) {</div>
<div class="line">  ...</div>
<div class="line">  return %0, %1 : !felt.type, index</div>
<div class="line">}</div>
</div><!-- fragment --><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>HasParent&lt;::<a class="el" href="classllzk_1_1function_1_1_func_def_op.html">llzk::function::FuncDefOp</a>&gt;</code>, <code>MemRefsNormalizable</code>, <code>ReturnLike</code>, <code>Terminator</code></p>
<p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>RegionBranchTerminatorOpInterface</code></p>
<p>Effects: <code>MemoryEffects::Effect{}</code></p>
<h4><a class="anchor" id="autotoc_md147"></a>
Operands:</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Operand   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>operands</code>   </td><td class="markdownTableBodyNone">variadic of a valid LLZK type   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md148"></a>
'global' Dialect</h1>
<p>LLZK support for global values, defined outside of structs.</p>
<h2><a class="anchor" id="autotoc_md149"></a>
Operations</h2>
<h3><a class="anchor" id="autotoc_md150"></a>
<code>global.def</code> (::llzk::global::GlobalDefOp)</h3>
<p><em>Global value</em></p>
<p>Syntax:</p>
<div class="fragment"><div class="line">operation ::= `global.def` (`const` $constant^)?</div>
<div class="line">              $sym_name `:` $type</div>
<div class="line">              `` custom&lt;GlobalInitialValue&gt;($initial_value, ref($type))</div>
<div class="line">              attr-dict</div>
</div><!-- fragment --><p>Examples:</p>
<div class="fragment"><div class="line">// Global constant (denoted by &quot;const&quot; modifier) string.</div>
<div class="line">global.def const @s : !string.type = &quot;Hello World!&quot;</div>
<div class="line"> </div>
<div class="line">// Global variable (i.e. no &quot;const&quot; modifier) with initial value.</div>
<div class="line">global.def @b : i1 = false</div>
<div class="line"> </div>
<div class="line">// Uninitialized global variable.</div>
<div class="line">global.def @a : !array.type&lt;2,2 x i1&gt;</div>
</div><!-- fragment --><p>Traits: <code>HasParent&lt;mlir::ModuleOp&gt;</code></p>
<p>Interfaces: <code>SymbolUserOpInterface</code>, <code>Symbol</code></p>
<h4><a class="anchor" id="autotoc_md151"></a>
Attributes:</h4>
<table class="doxtable">
<tr>
<th>Attribute</th><th>MLIR Type</th><th>Description </th></tr>
<tr>
<td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute </td></tr>
<tr>
<td><code>constant</code></td><td>::mlir::UnitAttr</td><td>unit attribute </td></tr>
<tr>
<td><code>type</code></td><td>::mlir::TypeAttr</td><td>type attribute of any LLZK type except non-constant types </td></tr>
<tr>
<td><code>initial_value</code></td><td>::mlir::Attribute</td><td>any attribute </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md152"></a>
<code>global.read</code> (::llzk::global::GlobalReadOp)</h3>
<p><em>Read value of a global</em></p>
<p>Syntax:</p>
<div class="fragment"><div class="line">operation ::= `global.read` $name_ref `:` type($val) attr-dict</div>
</div><!-- fragment --><p>This operation reads the value of a named global.</p>
<p>Interfaces: <code>GlobalRefOpInterface</code>, <code>SymbolUserOpInterface</code></p>
<h4><a class="anchor" id="autotoc_md153"></a>
Attributes:</h4>
<table class="doxtable">
<tr>
<th>Attribute</th><th>MLIR Type</th><th>Description </th></tr>
<tr>
<td><code>name_ref</code></td><td>::mlir::SymbolRefAttr</td><td>symbol reference attribute </td></tr>
</table>
<h4><a class="anchor" id="autotoc_md154"></a>
Results:</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Result   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>val</code>   </td><td class="markdownTableBodyNone">any LLZK type except non-constant types   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md155"></a>
<code>global.write</code> (::llzk::global::GlobalWriteOp)</h3>
<p><em>Write value to a global</em></p>
<p>Syntax:</p>
<div class="fragment"><div class="line">operation ::= `global.write` $name_ref `=` $val `:` type($val) attr-dict</div>
</div><!-- fragment --><p>This operation writes a value to a named global. Not allowed for globals declared with the "const" modifier.</p>
<p>Traits: <code>WitnessGen</code></p>
<p>Interfaces: <code>GlobalRefOpInterface</code>, <code>SymbolUserOpInterface</code></p>
<h4><a class="anchor" id="autotoc_md156"></a>
Attributes:</h4>
<table class="doxtable">
<tr>
<th>Attribute</th><th>MLIR Type</th><th>Description </th></tr>
<tr>
<td><code>name_ref</code></td><td>::mlir::SymbolRefAttr</td><td>symbol reference attribute </td></tr>
</table>
<h4><a class="anchor" id="autotoc_md157"></a>
Operands:</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Operand   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>val</code>   </td><td class="markdownTableBodyNone">any LLZK type except non-constant types   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md158"></a>
'include' Dialect</h1>
<p>LLZK include operations.</p>
<h2><a class="anchor" id="autotoc_md159"></a>
Operations</h2>
<h3><a class="anchor" id="autotoc_md160"></a>
<code>include.from</code> (::llzk::include::IncludeOp)</h3>
<p><em>Include operation</em></p>
<p>Syntax:</p>
<div class="fragment"><div class="line">operation ::= `include.from` $path `as` $sym_name attr-dict</div>
</div><!-- fragment --><p>This operation imports the contents of another source file in place of itself.</p>
<p>Example:</p>
<div class="fragment"><div class="line">include.from &quot;lib.llzk&quot; as @aliasName</div>
</div><!-- fragment --><p>Traits: <code>HasParent&lt;::mlir::ModuleOp&gt;</code></p>
<p>Interfaces: <code>Symbol</code></p>
<h4><a class="anchor" id="autotoc_md161"></a>
Attributes:</h4>
<table class="doxtable">
<tr>
<th>Attribute</th><th>MLIR Type</th><th>Description </th></tr>
<tr>
<td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute </td></tr>
<tr>
<td><code>path</code></td><td>::mlir::StringAttr</td><td>string attribute </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md162"></a>
'llzk' Dialect</h1>
<p>Common LLZK attributes.</p>
<h2><a class="anchor" id="autotoc_md163"></a>
Attributes</h2>
<h3><a class="anchor" id="autotoc_md164"></a>
LoopBoundsAttr</h3>
<p>Annotation with the bounds of a loop</p>
<p>Syntax:</p>
<div class="fragment"><div class="line">#llzk.loopbounds&lt;</div>
<div class="line">  ::llvm::APInt,   # lower</div>
<div class="line">  ::llvm::APInt,   # upper</div>
<div class="line">  ::llvm::APInt   # step</div>
<div class="line">&gt;</div>
</div><!-- fragment --><p>This attribute holds information useful for the analysis of loops. Holds the bounds of the loop and the step size.</p>
<p>Example:</p>
<div class="fragment"><div class="line">scf.while ... {</div>
<div class="line">  ...</div>
<div class="line">} do {</div>
<div class="line">  ...</div>
<div class="line">} attributes { llzk.loopbounds = #llzk.loopbounds&lt;0 to 10 step 1&gt; }</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md165"></a>
Parameters:</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Parameter   </th><th class="markdownTableHeadCenter">C++ type   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">lower   </td><td class="markdownTableBodyCenter"><code>::llvm::APInt</code>   </td><td class="markdownTableBodyNone">Loop variable lower bound (inclusive)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">upper   </td><td class="markdownTableBodyCenter"><code>::llvm::APInt</code>   </td><td class="markdownTableBodyNone">Loop variable upper bound (exclusive)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">step   </td><td class="markdownTableBodyCenter"><code>::llvm::APInt</code>   </td><td class="markdownTableBodyNone">Loop variable step/increment   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md166"></a>
PublicAttr</h3>
<p>A unit attribute to mark a type as public</p>
<p>Syntax: <code>#llzk.pub</code></p>
<p>Examples:</p>
<div class="fragment"><div class="line">struct.field @field_name : !felt.type {llzk.pub}</div>
<div class="line"> </div>
<div class="line">function.def @func_name(%0: !felt.type {llzk.pub})</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md167"></a>
'poly' Dialect</h1>
<p>LLZK types and operations to support templated/parameterized structs.</p>
<h2><a class="anchor" id="autotoc_md168"></a>
Operations</h2>
<h3><a class="anchor" id="autotoc_md169"></a>
<code>poly.applymap</code> (::llzk::polymorphic::ApplyMapOp)</h3>
<p><em>Apply an AffineMap</em></p>
<p>Syntax:</p>
<div class="fragment"><div class="line">operation ::= `poly.applymap` custom&lt;DimAndSymbolList&gt;($mapOperands, $numDims) $map attr-dict</div>
</div><!-- fragment --><p>This operation applies an AffineMap to a list of SSA values, yielding a single SSA value. The number of dimension and symbol arguments must be equal to the respective number of dimensional and symbolic inputs to the AffineMap; the AffineMap has to be one-dimensional, and so this operation always returns one value. The input operands and result all have <code>index</code> type.</p>
<p>Named map example: </p><div class="fragment"><div class="line">#map10 = affine_map&lt;(d0, d1) -&gt; (d0 floordiv 8 + d1 floordiv 128)&gt;</div>
<div class="line">...</div>
<div class="line">%1 = poly.applymap(%s, %t) #map10</div>
</div><!-- fragment --><p>Inline example: </p><div class="fragment"><div class="line">%2 = poly.applymap(%42)[%n] affine_map&lt;(i)[s0] -&gt; (i+s0)&gt;</div>
</div><!-- fragment --><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p>
<p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p>
<p>Effects: <code>MemoryEffects::Effect{}</code></p>
<h4><a class="anchor" id="autotoc_md170"></a>
Attributes:</h4>
<table class="doxtable">
<tr>
<th>Attribute</th><th>MLIR Type</th><th>Description </th></tr>
<tr>
<td><code>map</code></td><td>::mlir::AffineMapAttr</td><td>AffineMap attribute </td></tr>
<tr>
<td><code>numDims</code></td><td>::mlir::IntegerAttr</td><td>index attribute </td></tr>
</table>
<h4><a class="anchor" id="autotoc_md171"></a>
Operands:</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Operand   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>mapOperands</code>   </td><td class="markdownTableBodyNone">variadic of index   </td></tr>
</table>
<h4><a class="anchor" id="autotoc_md172"></a>
Results:</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Result   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">&laquo;unnamed&raquo;   </td><td class="markdownTableBodyNone">index   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md173"></a>
<code>poly.read_const</code> (::llzk::polymorphic::ConstReadOp)</h3>
<p><em>Read value of a struct parameter</em></p>
<p>Syntax:</p>
<div class="fragment"><div class="line">operation ::= `poly.read_const` $const_name `:` type($val) attr-dict</div>
</div><!-- fragment --><p>This operation reads the value from the named constant parameter of the struct/component in which this op appears. The op itself puts some restriction on the type of this value, but leaves it to a later type-checking pass to ensure the struct parameters are instantiated with types matching the uses of the parameter within the struct.</p>
<p>Interfaces: <code>SymbolUserOpInterface</code></p>
<h4><a class="anchor" id="autotoc_md174"></a>
Attributes:</h4>
<table class="doxtable">
<tr>
<th>Attribute</th><th>MLIR Type</th><th>Description </th></tr>
<tr>
<td><code>const_name</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute </td></tr>
</table>
<h4><a class="anchor" id="autotoc_md175"></a>
Results:</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Result   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>val</code>   </td><td class="markdownTableBodyNone">integral, felt, or typevar type   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md176"></a>
<code>poly.unifiable_cast</code> (::llzk::polymorphic::UnifiableCastOp)</h3>
<p><em>Cast between two unifiable types</em></p>
<p>Syntax:</p>
<div class="fragment"><div class="line">operation ::= `poly.unifiable_cast` $input `:` functional-type($input, results) attr-dict</div>
</div><!-- fragment --><p>This operation reinterprets a value as a different type with the restriction that the input and output types of the cast are unifiable.</p>
<p>Most ops that accept LLZK types accept unifiable types as input and thus there is no need for casting between types. This op is meant to be used in situations where is not possible to modify the given or the target type and they are different but unifiable. For example, inside a conversion pattern the driver may introduce <code>unrealized_conversion_cast</code> operations if the types are not equal. This will happen regardless of whether the two types unify. This cast can be introduced instead of the default cast operation to satisfy MLIR's assumptions on type equality.</p>
<p>Example: </p><div class="fragment"><div class="line">%0 = some_other_op : !array.type&lt;@N x !felt.type&gt;</div>
<div class="line">%1 = unifiable_cast %0 : (!array.type&lt;@N x @felt.type&gt;) -&gt; !array.type&lt;affine_map&lt;()[s0, s1] -&gt; (s0 + s1)&gt; x !felt.type&gt;</div>
</div><!-- fragment --><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p>
<p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p>
<p>Effects: <code>MemoryEffects::Effect{}</code></p>
<h4><a class="anchor" id="autotoc_md177"></a>
Operands:</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Operand   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>input</code>   </td><td class="markdownTableBodyNone">a valid LLZK type   </td></tr>
</table>
<h4><a class="anchor" id="autotoc_md178"></a>
Results:</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Result   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>result</code>   </td><td class="markdownTableBodyNone">a valid LLZK type   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md179"></a>
Types</h2>
<h3><a class="anchor" id="autotoc_md180"></a>
TypeVarType</h3>
<p>type variable</p>
<p>Syntax:</p>
<div class="fragment"><div class="line">!poly.tvar&lt;</div>
<div class="line">  ::mlir::FlatSymbolRefAttr   # nameRef</div>
<div class="line">&gt;</div>
</div><!-- fragment --><p>This type serves as a placeholder for a type that is instantiated via a parameter of the struct.</p>
<p>For example, we can define a struct that holds a size-2 array where the type of the elements in the array is specified by a parameter of the struct and instantiated with a specific type at the uses of the struct.</p>
<div class="fragment"><div class="line">struct.def @A&lt;[@Ty]&gt; {</div>
<div class="line">  field @x : !array.type&lt;2 x !poly.tvar&lt;@Ty&gt;&gt;</div>
<div class="line">  ...</div>
<div class="line">}</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md181"></a>
Parameters:</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Parameter   </th><th class="markdownTableHeadCenter">C++ type   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">nameRef   </td><td class="markdownTableBodyCenter"><code>::mlir::FlatSymbolRefAttr</code>   </td><td class="markdownTableBodyNone">reference to the struct parameter   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md182"></a>
'string' Dialect</h1>
<p>LLZK string type and operations.</p>
<h2><a class="anchor" id="autotoc_md183"></a>
Operations</h2>
<h3><a class="anchor" id="autotoc_md184"></a>
<code>string.new</code> (::llzk::string::LitStringOp)</h3>
<p><em>Literal string</em></p>
<p>Syntax:</p>
<div class="fragment"><div class="line">operation ::= `string.new` $value attr-dict</div>
</div><!-- fragment --><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>ConstantLike</code></p>
<p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p>
<p>Effects: <code>MemoryEffects::Effect{}</code></p>
<h4><a class="anchor" id="autotoc_md185"></a>
Attributes:</h4>
<table class="doxtable">
<tr>
<th>Attribute</th><th>MLIR Type</th><th>Description </th></tr>
<tr>
<td><code>value</code></td><td>::mlir::StringAttr</td><td>string attribute </td></tr>
</table>
<h4><a class="anchor" id="autotoc_md186"></a>
Results:</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Result   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>result</code>   </td><td class="markdownTableBodyNone">string type   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md187"></a>
Types</h2>
<h3><a class="anchor" id="autotoc_md188"></a>
StringType</h3>
<p>string type</p>
<p>Syntax: <code>!string.type</code></p>
<h1><a class="anchor" id="autotoc_md189"></a>
'struct' Dialect</h1>
<p>LLZK component/struct operations.</p>
<h2><a class="anchor" id="autotoc_md190"></a>
Operations</h2>
<h3><a class="anchor" id="autotoc_md191"></a>
<code>struct.def</code> (::llzk::component::StructDefOp)</h3>
<p><em>Circuit component definition</em></p>
<p>Syntax:</p>
<div class="fragment"><div class="line">operation ::= `struct.def` $sym_name (`&lt;` $const_params^ `&gt;`)? $body attr-dict</div>
</div><!-- fragment --><p>This operation describes a component in a circuit. It can contain any number of fields that hold inputs, outputs, intermediate values, and subcomponents of the defined component. It also contains a <code>compute()</code> function that holds the witness generation code for the component and a <code>constrain()</code> function that holds that constraint generation code for the component.</p>
<p>Example:</p>
<div class="fragment"><div class="line">struct.def @ComponentA {</div>
<div class="line">  field @f1 : !array.type&lt;5 x index&gt;</div>
<div class="line">  field @f2 : !felt.type {llzk.pub}</div>
<div class="line"> </div>
<div class="line">  function.def @compute(%p: !felt.type) -&gt; !struct.type&lt;@ComponentA&gt; {</div>
<div class="line">    %self = struct.new : !struct.type&lt;@ComponentA&gt;</div>
<div class="line">    // initialize all fields of `%self` here</div>
<div class="line">    return %self : !struct.type&lt;@ComponentA&gt;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  function.def @constrain(%self: !struct.type&lt;@ComponentA&gt;, %p: !felt.type) {</div>
<div class="line">    // emit constraints here</div>
<div class="line">    return</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Traits: <code>HasOnlyGraphRegion</code>, <code>HasParent&lt;::mlir::ModuleOp&gt;</code>, <code>IsolatedFromAbove</code>, <code>NoTerminator</code>, <code>SetFuncAllowAttrs</code>, <code>SingleBlock</code>, <code>SymbolTable</code></p>
<p>Interfaces: <code>RegionKindInterface</code>, <code>SymbolUserOpInterface</code>, <code>Symbol</code></p>
<h4><a class="anchor" id="autotoc_md192"></a>
Attributes:</h4>
<table class="doxtable">
<tr>
<th>Attribute</th><th>MLIR Type</th><th>Description </th></tr>
<tr>
<td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute </td></tr>
<tr>
<td><code>const_params</code></td><td>::mlir::ArrayAttr</td><td>flat symbol ref array attribute </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md193"></a>
<code>struct.field</code> (::llzk::component::FieldDefOp)</h3>
<p><em>Struct field definition</em></p>
<p>Syntax:</p>
<div class="fragment"><div class="line">operation ::= `struct.field` $sym_name `:` $type attr-dict</div>
</div><!-- fragment --><p>This operation describes a field in a struct/component.</p>
<p>Example:</p>
<div class="fragment"><div class="line">struct.field @f1 : !felt.type</div>
<div class="line">struct.field @f2 : !felt.type {llzk.pub}</div>
</div><!-- fragment --><p>Traits: <code>HasParent&lt;::<a class="el" href="classllzk_1_1component_1_1_struct_def_op.html">llzk::component::StructDefOp</a>&gt;</code></p>
<p>Interfaces: <code>SymbolUserOpInterface</code>, <code>Symbol</code></p>
<h4><a class="anchor" id="autotoc_md194"></a>
Attributes:</h4>
<table class="doxtable">
<tr>
<th>Attribute</th><th>MLIR Type</th><th>Description </th></tr>
<tr>
<td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute </td></tr>
<tr>
<td><code>type</code></td><td>::mlir::TypeAttr</td><td>type attribute of a valid LLZK type </td></tr>
<tr>
<td><code>column</code></td><td>::mlir::UnitAttr</td><td>unit attribute </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md195"></a>
<code>struct.new</code> (::llzk::component::CreateStructOp)</h3>
<p><em>Create a new struct</em></p>
<p>Syntax:</p>
<div class="fragment"><div class="line">operation ::= `struct.new` `:` type($result) attr-dict</div>
</div><!-- fragment --><p>This operation creates a new, uninitialized instance of a struct.</p>
<p>Example:</p>
<div class="fragment"><div class="line">%self = struct.new : !struct.type&lt;@Reg&gt;</div>
</div><!-- fragment --><p>Traits: <code>WitnessGen</code></p>
<p>Interfaces: <code>OpAsmOpInterface</code>, <code>SymbolUserOpInterface</code></p>
<h4><a class="anchor" id="autotoc_md196"></a>
Results:</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Result   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>result</code>   </td><td class="markdownTableBodyNone">circuit component   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md197"></a>
<code>struct.readf</code> (::llzk::component::FieldReadOp)</h3>
<p><em>Read value of a struct field</em></p>
<p>Syntax:</p>
<div class="fragment"><div class="line">operation ::= `struct.readf` $component `[` $field_name `]`</div>
<div class="line">              ( `{` custom&lt;MultiDimAndSymbolList&gt;($mapOperands, $numDimsPerMap)^ `}` )?</div>
<div class="line">              `:` type($component) `,` type($val)</div>
<div class="line">              attr-dict</div>
</div><!-- fragment --><p>This operation reads the value of a named field in a struct/component.</p>
<p>The value can be read from the signals table, in which case it can be offset by a constant value. A negative value represents reading a value backwards and a positive value represents reading a value forward. Only fields marked as columns can be read in this manner.</p>
<p>Traits: <code>VerifySizesForMultiAffineOps&lt;1&gt;</code></p>
<p>Interfaces: <code>FieldRefOpInterface</code>, <code>SymbolUserOpInterface</code></p>
<h4><a class="anchor" id="autotoc_md198"></a>
Attributes:</h4>
<table class="doxtable">
<tr>
<th>Attribute</th><th>MLIR Type</th><th>Description </th></tr>
<tr>
<td><code>field_name</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute </td></tr>
<tr>
<td><code>tableOffset</code></td><td>::mlir::Attribute</td><td>symbol reference attribute or index attribute or AffineMap attribute </td></tr>
<tr>
<td><code>numDimsPerMap</code></td><td>::mlir::DenseI32ArrayAttr</td><td>i32 dense array attribute </td></tr>
<tr>
<td><code>mapOpGroupSizes</code></td><td>::mlir::DenseI32ArrayAttr</td><td>i32 dense array attribute </td></tr>
</table>
<h4><a class="anchor" id="autotoc_md199"></a>
Operands:</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Operand   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>component</code>   </td><td class="markdownTableBodyNone">circuit component    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"><code>mapOperands</code>   </td><td class="markdownTableBodyNone">variadic of index   </td></tr>
</table>
<h4><a class="anchor" id="autotoc_md200"></a>
Results:</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Result   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>val</code>   </td><td class="markdownTableBodyNone">a valid LLZK type   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md201"></a>
<code>struct.writef</code> (::llzk::component::FieldWriteOp)</h3>
<p><em>Write value to a struct field</em></p>
<p>Syntax:</p>
<div class="fragment"><div class="line">operation ::= `struct.writef` $component `[` $field_name `]` `=` $val `:` type($component) `,` type($val) attr-dict</div>
</div><!-- fragment --><p>This operation writes a value to a named field in a struct/component.</p>
<p>Traits: <code>WitnessGen</code></p>
<p>Interfaces: <code>FieldRefOpInterface</code>, <code>SymbolUserOpInterface</code></p>
<h4><a class="anchor" id="autotoc_md202"></a>
Attributes:</h4>
<table class="doxtable">
<tr>
<th>Attribute</th><th>MLIR Type</th><th>Description </th></tr>
<tr>
<td><code>field_name</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute </td></tr>
</table>
<h4><a class="anchor" id="autotoc_md203"></a>
Operands:</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Operand   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>component</code>   </td><td class="markdownTableBodyNone">circuit component    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"><code>val</code>   </td><td class="markdownTableBodyNone">a valid LLZK type   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md204"></a>
Types</h2>
<h3><a class="anchor" id="autotoc_md205"></a>
StructType</h3>
<p>circuit component</p>
<p>Syntax:</p>
<div class="fragment"><div class="line">!struct.type&lt;</div>
<div class="line">  ::mlir::SymbolRefAttr,   # nameRef</div>
<div class="line">  ::mlir::ArrayAttr   # params</div>
<div class="line">&gt;</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md206"></a>
Parameters:</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Parameter   </th><th class="markdownTableHeadCenter">C++ type   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">nameRef   </td><td class="markdownTableBodyCenter"><code>::mlir::SymbolRefAttr</code>   </td><td class="markdownTableBodyNone">Fully-qualified name of the struct definition.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">params   </td><td class="markdownTableBodyCenter"><code>::mlir::ArrayAttr</code>   </td><td class="markdownTableBodyNone">Struct parameters   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md207"></a>
'undef' Dialect</h1>
<p>LLZK undefined value support operations.</p>
<h2><a class="anchor" id="autotoc_md208"></a>
Operations</h2>
<h3><a class="anchor" id="autotoc_md209"></a>
<code>undef.undef</code> (::llzk::undef::UndefOp)</h3>
<p><em>Creates an undefined value of the specified type.</em></p>
<p>Syntax:</p>
<div class="fragment"><div class="line">operation ::= `undef.undef` `:` type($res) attr-dict</div>
</div><!-- fragment --><p>This operation has no operands or attributes. It represents an undefined value of the specified LLZK IR dialect type. This op can be introduced by the <code>llzk-array-to-scalar</code> pass if there is a read from an array index that was not dominated by an earlier write to that same index.</p>
<p>Example:</p>
<div class="fragment"><div class="line">%0 = undef.undef : !felt.type</div>
</div><!-- fragment --><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p>
<p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p>
<p>Effects: <code>MemoryEffects::Effect{}</code></p>
<h4><a class="anchor" id="autotoc_md210"></a>
Results:</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Result   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>res</code>   </td><td class="markdownTableBodyNone">a valid LLZK type   </td></tr>
</table>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.13.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
    <li class="footer">Copyright 2025 Veridise Inc. under the Apache License v2.0.</li>
  </ul>
</div>
</body>
</html>
