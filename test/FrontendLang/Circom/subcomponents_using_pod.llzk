// RUN: llzk-opt -split-input-file %s 2>&1 | FileCheck --enable-var-scope %s

//////////////////////////////////////////////////////////////////////////////////
// This example shows how to use the pod dialect for working with subcomponents
// and buses.
//////////////////////////////////////////////////////////////////////////////////
// bus Vec(N) {
//   signal p[N];
// }
//
// template Sum(N) {
//   input Vec(N) vec;
//   signal input c;
//   signal output sum;
//   var acc = c;
//   for (var i = 0; i < N; i++) {
//     acc += vec.p[i];
//   }
//   sum <== acc;
// }
//
// template SumUser() {
//   signal input x[7];
//   signal output out[2];
//   component sums[2];
//   sums[0] = Sum(4);
//   sums[0].c <== 0;
//   for (var i = 0; i < 4; i++) {
//     sums[0].vec.p[i] <== x[i];
//   }
//   sums[1] = Sum(3);
//   sums[1].c <== 1;
//   for (var i = 0; i < 3; i++) {
//     sums[1].vec.p[i] <== x[i+4];
//   }
//   out[0] <== sums[0].sum;
//   out[1] <== sums[1].sum;
// }
//
// component main = SumUser();
//////////////////////////////////////////////////////////////////////////////////

// The bus is represented with a `!pod.type`.
!Vec = !pod.type<[@p: !array.type<affine_map<(d0) -> (d0)> x !felt.type>]>

// Type used to represent the inputs of the Sum template
// We alias it here since we are going to repeat it a lot in the IR
!sums_inputs = !pod.type<[@vec: !Vec, @c: !felt.type]>
// Parameters of the Sum template.
!sums_params = !pod.type<[@N: index]>

module attributes { veridise.lang = "llzk" } {

  struct.def @Sum<[@N]> {
    struct.field @sum : !felt.type {llzk.pub}
    function.def @compute(%vec: !pod.type<[@p: !array.type<@N x !felt.type>]>, %c: !felt.type) -> !struct.type<@Sum<[@N]>> {
      %self = struct.new : <@Sum<[@N]>>
      %n = poly.read_const @N : index 
      %const_0 = arith.constant 0 : index
      %const_1 = arith.constant 1 : index
      %acc = scf.for %i = %const_0 to %n step %const_1 
        iter_args(%acc_iter = %c) -> (!felt.type)
      {
        %0 = pod.read %vec[@p] : !pod.type<[@p: !array.type<@N x !felt.type>]>, !array.type<@N x !felt.type>
        %1 = array.read %0[%i] : !array.type<@N x !felt.type>, !felt.type 
        %2 = felt.add %acc_iter, %1
        scf.yield %2 : !felt.type
      }
      struct.writef %self[@sum] = %acc : !struct.type<@Sum<[@N]>>, !felt.type
      function.return %self : !struct.type<@Sum<[@N]>>
    }
    function.def @constrain(%self: !struct.type<@Sum<[@N]>>, %vec: !pod.type<[@p: !array.type<@N x !felt.type>]>, %c: !felt.type) {
      %n = poly.read_const @N : index 
      %const_0 = arith.constant 0 : index
      %const_1 = arith.constant 1 : index
      %acc = scf.for %i = %const_0 to %n step %const_1 
        iter_args(%acc_iter = %c) -> (!felt.type)
      {
        %0 = pod.read %vec[@p] : !pod.type<[@p: !array.type<@N x !felt.type>]>, !array.type<@N x !felt.type>
        %1 = array.read %0[%i] : !array.type<@N x !felt.type>, !felt.type 
        %2 = felt.add %acc_iter, %1
        scf.yield %2 : !felt.type
      }
      %3 = struct.readf %self[@sum] : !struct.type<@Sum<[@N]>>, !felt.type
      constrain.eq %3, %acc : !felt.type
      function.return
    }
  }

  struct.def @SumUser {
    struct.field @out : !array.type<2 x !felt.type> {llzk.pub}
    struct.field @sums : !array.type<2 x !struct.type<@Sum<[affine_map<(d0) -> (d0)>]>>>
    struct.field @"sums$inputs" : !array.type<2 x !sums_inputs>
    function.def @compute(%x: !array.type<7 x !felt.type>) -> !struct.type<@SumUser> {
      // Prologue
      %self = struct.new : <@SumUser>
      %out = array.new : !array.type<2 x !felt.type>
      %sums = array.new : !array.type<2 x !struct.type<@Sum<[affine_map<(d0) -> (d0)>]>>>
      %sums_inputs = array.new : !array.type<2 x !sums_inputs>
      %sums_params = array.new : !array.type<2 x !sums_params>
      %const_0 = arith.constant 0 : index
      %const_1 = arith.constant 1 : index
      %const_4 = arith.constant 4 : index
      %const_3 = arith.constant 3 : index

      // sums[0] = Sum(4);
      %params0 = pod.new { @N = %const_4 }  : !sums_params
      %0 = pod.new  (%const_4) : !sums_inputs
      array.write %sums_params[%const_0] = %params0 : !array.type<2 x !sums_params>, !sums_params
      array.write %sums_inputs[%const_0] = %0 : !array.type<2 x !sums_inputs>, !sums_inputs

      // sums[0].c <== 0;
      %const_felt_0 = felt.const  0 
      %1 = array.read %sums_inputs[%const_0] : !array.type<2 x !sums_inputs>, !sums_inputs
      pod.write %1[@c] = %const_felt_0 : !sums_inputs, !felt.type
      array.write %sums_inputs[%const_0] = %1 : !array.type<2 x !sums_inputs>, !sums_inputs

      scf.for %i = %const_0 to %const_4 step %const_1 {
        // sums[0].vec.p[i] <== x[i];
        %8 = array.read %x[%i] : !array.type<7 x !felt.type>, !felt.type
        %9 = array.read %sums_inputs[%const_0] : !array.type<2 x !sums_inputs>, !sums_inputs
        %10 = pod.read %9[@vec] : !sums_inputs, !Vec
        %11 = pod.read %10[@p] : !Vec, !array.type<affine_map<(d0) -> (d0)> x !felt.type>
        array.write %11[%i] = %8 : !array.type<affine_map<(d0) -> (d0)> x !felt.type>, !felt.type
        pod.write %10[@p] = %11 : !Vec, !array.type<affine_map<(d0) -> (d0)> x !felt.type>
        pod.write %9[@vec] = %10 : !sums_inputs, !Vec
        array.write %sums_inputs[%const_0] = %9 : !array.type<2 x !sums_inputs>, !sums_inputs
      }

      // sums[1] = Sum(3);
      %params2 = pod.new { @N = %const_3 }  : !sums_params
      %2 = pod.new  (%const_3) : !sums_inputs
      array.write %sums_params[%const_1] = %params2 : !array.type<2 x !sums_params>, !sums_params
      array.write %sums_inputs[%const_1] = %2 : !array.type<2 x !sums_inputs>, !sums_inputs

      // sums[1].c <== 1;
      %const_felt_1 = felt.const  1
      %3 = array.read %sums_inputs[%const_1] : !array.type<2 x !sums_inputs>, !sums_inputs
      pod.write %3[@c] = %const_felt_1 : !sums_inputs, !felt.type
      array.write %sums_inputs[%const_1] = %3 : !array.type<2 x !sums_inputs>, !sums_inputs

      scf.for %i = %const_0 to %const_3 step %const_1 {
        // sums[1].vec.p[i] <== x[i+4];
        %12 = arith.addi %i, %const_4 : index 
        %13 = array.read %x[%12] : !array.type<7 x !felt.type>, !felt.type
        %14 = array.read %sums_inputs[%const_1] : !array.type<2 x !sums_inputs>, !sums_inputs
        %15 = pod.read %14[@vec] : !sums_inputs, !Vec
        %16 = pod.read %15[@p] : !Vec, !array.type<affine_map<(d0) -> (d0)> x !felt.type>
        array.write %16[%i] = %13 : !array.type<affine_map<(d0) -> (d0)> x !felt.type>, !felt.type
        pod.write %15[@p] = %16 : !Vec, !array.type<affine_map<(d0) -> (d0)> x !felt.type>
        pod.write %14[@vec] = %15 : !sums_inputs, !Vec
        array.write %sums_inputs[%const_1] = %14 : !array.type<2 x !sums_inputs>, !sums_inputs
      }

      // Constructors
      scf.for %i = %const_0 to %const_1 step %const_1 {
        %17 = array.read %sums_inputs[%i] : !array.type<2 x !sums_inputs>, !sums_inputs
        %params17 = array.read %sums_params[%i] : !array.type<2 x !sums_params>, !sums_params
        %18 = pod.read %17[@vec] : !sums_inputs, !Vec
        %19 = pod.read %17[@c] : !sums_inputs, !felt.type
        %20 = pod.read %params17[@N] : !sums_params, index
    	  %21 = function.call @Sum::@compute(%18, %19){(%20)} : (!Vec, !felt.type) -> !struct.type<@Sum<[affine_map<(d0) -> (d0)>]>>
        array.write %sums[%i] = %21 : !array.type<2 x !struct.type<@Sum<[affine_map<(d0) -> (d0)>]>>>, !struct.type<@Sum<[affine_map<(d0) -> (d0)>]>>
      }

      // out[0] <== sums[0].sum;
      %4 = array.read %sums[%const_0] : !array.type<2 x !struct.type<@Sum<[affine_map<(d0) -> (d0)>]>>>, !struct.type<@Sum<[affine_map<(d0) -> (d0)>]>>
      %5 = struct.readf %4[@sum] : !struct.type<@Sum<[affine_map<(d0) -> (d0)>]>>, !felt.type
      array.write %out[%const_0] = %5 : !array.type<2 x !felt.type>, !felt.type

      // out[1] <== sums[1].sum;
      %6 = array.read %sums[%const_1] : !array.type<2 x !struct.type<@Sum<[affine_map<(d0) -> (d0)>]>>>, !struct.type<@Sum<[affine_map<(d0) -> (d0)>]>>
      %7 = struct.readf %6[@sum] : !struct.type<@Sum<[affine_map<(d0) -> (d0)>]>>, !felt.type
      array.write %out[%const_1] = %7 : !array.type<2 x !felt.type>, !felt.type

      // Epilogue
      struct.writef %self[@out] = %out : <@SumUser>, !array.type<2 x !felt.type>
      struct.writef %self[@sums] = %sums : <@SumUser>, !array.type<2 x !struct.type<@Sum<[affine_map<(d0) -> (d0)>]>>>
      struct.writef %self[@"sums$inputs"] = %sums_inputs : <@SumUser>, !array.type<2 x !sums_inputs>
      function.return %self : !struct.type<@SumUser>
    }
    function.def @constrain(%self: !struct.type<@SumUser>, %x: !array.type<7 x !felt.type>) {
      // Prologue
      %const_0 = arith.constant 0 : index
      %const_1 = arith.constant 1 : index
      %const_4 = arith.constant 4 : index
      %const_3 = arith.constant 3 : index

      // sums[0] = Sum(4);
      // do nothing

      // sums[0].c <== 0;
      %0 = struct.readf %self[@"sums$inputs"] : <@SumUser>, !array.type<2 x !sums_inputs>
      %1 = array.read %0[%const_0] : !array.type<2 x !sums_inputs>, !sums_inputs
      %2 = pod.read %1[@c] : !sums_inputs, !felt.type
      %const_felt_0 = felt.const  0 
      constrain.eq %2, %const_felt_0 : !felt.type

      scf.for %i = %const_0 to %const_4 step %const_1 {
        // sums[0].vec.p[i] <== x[i];
        %16 = struct.readf %self[@"sums$inputs"] : <@SumUser>, !array.type<2 x !sums_inputs>
        %17 = array.read %16[%const_0] : !array.type<2 x !sums_inputs>, !sums_inputs
        %18 = pod.read %17[@vec] : !sums_inputs, !Vec
        %19 = pod.read %18[@p] : !Vec, !array.type<affine_map<(d0) -> (d0)> x !felt.type>
        %20 = array.read %19[%i] : !array.type<affine_map<(d0) -> (d0)> x !felt.type>, !felt.type
        %21 = array.read %x[%i] : !array.type<7 x !felt.type>, !felt.type
        constrain.eq %20, %21 : !felt.type
      }

      // sums[1] = Sum(3);
      // do nothing

      // sums[1].c <== 1;
      %3 = struct.readf %self[@"sums$inputs"] : <@SumUser>, !array.type<2 x !sums_inputs>
      %4 = array.read %3[%const_0] : !array.type<2 x !sums_inputs>, !sums_inputs
      %5 = pod.read %4[@c] : !sums_inputs, !felt.type
      %const_felt_1 = felt.const  1
      constrain.eq %5, %const_felt_1 : !felt.type

      scf.for %i = %const_0 to %const_3 step %const_1 {
        // sums[1].vec.p[i] <== x[i+4];
        %22 = struct.readf %self[@"sums$inputs"] : <@SumUser>, !array.type<2 x !sums_inputs>
        %23 = array.read %22[%const_1] : !array.type<2 x !sums_inputs>, !sums_inputs
        %24 = pod.read %23[@vec] : !sums_inputs, !Vec
        %25 = pod.read %24[@p] : !Vec, !array.type<affine_map<(d0) -> (d0)> x !felt.type>
        %26 = array.read %25[%i] : !array.type<affine_map<(d0) -> (d0)> x !felt.type>, !felt.type
        %27 = arith.addi %i, %const_4 : index
        %28 = array.read %x[%27] : !array.type<7 x !felt.type>, !felt.type
        constrain.eq %26, %28 : !felt.type
      }

      // out[0] <== sums[0].sum;
      %6 = struct.readf %self[@out] : <@SumUser>, !array.type<2 x !felt.type>
      %7 = array.read %6[%const_0] : !array.type<2 x !felt.type>, !felt.type
      %8 = struct.readf %self[@sums] : <@SumUser>, !array.type<2 x !struct.type<@Sum<[affine_map<(d0) -> (d0)>]>>>
      %9 = array.read %8[%const_0] : !array.type<2 x !struct.type<@Sum<[affine_map<(d0) -> (d0)>]>>>, !struct.type<@Sum<[affine_map<(d0) -> (d0)>]>>
      %10 = struct.readf %9[@sum] : !struct.type<@Sum<[affine_map<(d0) -> (d0)>]>>, !felt.type
      constrain.eq %7, %10 : !felt.type

      // out[1] <== sums[1].sum;
      %11 = struct.readf %self[@out] : <@SumUser>, !array.type<2 x !felt.type>
      %12 = array.read %11[%const_1] : !array.type<2 x !felt.type>, !felt.type
      %13 = struct.readf %self[@sums] : <@SumUser>, !array.type<2 x !struct.type<@Sum<[affine_map<(d0) -> (d0)>]>>>
      %14 = array.read %13[%const_1] : !array.type<2 x !struct.type<@Sum<[affine_map<(d0) -> (d0)>]>>>, !struct.type<@Sum<[affine_map<(d0) -> (d0)>]>>
      %15 = struct.readf %14[@sum] : !struct.type<@Sum<[affine_map<(d0) -> (d0)>]>>, !felt.type
      constrain.eq %12, %15 : !felt.type

      // Epilogue
      // Call constrain on the subcomponents
      scf.for %i = %const_0 to %const_1 step %const_1 {
        %29 = struct.readf %self[@"sums$inputs"] : <@SumUser>, !array.type<2 x !sums_inputs>
        %30 = array.read %29[%i] : !array.type<2 x !sums_inputs>, !sums_inputs
        %31 = pod.read %30[@vec] : !sums_inputs, !Vec
        %32 = pod.read %30[@c] : !sums_inputs, !felt.type
        %34 = struct.readf %self[@sums] : <@SumUser>, !array.type<2 x !struct.type<@Sum<[affine_map<(d0) -> (d0)>]>>>
        %35 = array.read %34[%i] : !array.type<2 x !struct.type<@Sum<[affine_map<(d0) -> (d0)>]>>>, !struct.type<@Sum<[affine_map<(d0) -> (d0)>]>>
        function.call @Sum::@constrain(%35, %31, %32) : (!struct.type<@Sum<[affine_map<(d0) -> (d0)>]>>, !Vec, !felt.type) -> ()
      }
      function.return
    }
  }
}

// CHECK: #[[$ATTR_0:.+]] = affine_map<(d0) -> (d0)>

// CHECK-LABEL: module attributes {veridise.lang = "llzk"} {
// CHECK-NEXT:    struct.def @Sum<[@N]> {
// CHECK-NEXT:      struct.field @sum : !felt.type {llzk.pub}
// CHECK-NEXT:      function.def @compute(%[[VAL_0:[0-9a-zA-Z_\.]+]]: !pod.type<[@p: !array.type<@N x !felt.type>]>, %[[VAL_1:[0-9a-zA-Z_\.]+]]: !felt.type) -> !struct.type<@Sum<[@N]>> attributes {function.allow_witness} {
// CHECK-NEXT:        %[[VAL_2:[0-9a-zA-Z_\.]+]] = struct.new : <@Sum<[@N]>>
// CHECK-NEXT:        %[[VAL_3:[0-9a-zA-Z_\.]+]] = poly.read_const @N : index
// CHECK-NEXT:        %[[VAL_4:[0-9a-zA-Z_\.]+]] = arith.constant 0 : index
// CHECK-NEXT:        %[[VAL_5:[0-9a-zA-Z_\.]+]] = arith.constant 1 : index
// CHECK-NEXT:        %[[VAL_6:[0-9a-zA-Z_\.]+]] = scf.for %[[VAL_7:[0-9a-zA-Z_\.]+]] = %[[VAL_4]] to %[[VAL_3]] step %[[VAL_5]] iter_args(%[[VAL_8:[0-9a-zA-Z_\.]+]] = %[[VAL_1]]) -> (!felt.type) {
// CHECK-NEXT:          %[[VAL_9:[0-9a-zA-Z_\.]+]] = pod.read %[[VAL_0]][@p] : <[@p: !array.type<@N x !felt.type>]>, !array.type<@N x !felt.type>
// CHECK-NEXT:          %[[VAL_10:[0-9a-zA-Z_\.]+]] = array.read %[[VAL_9]]{{\[}}%[[VAL_7]]] : <@N x !felt.type>, !felt.type
// CHECK-NEXT:          %[[VAL_11:[0-9a-zA-Z_\.]+]] = felt.add %[[VAL_8]], %[[VAL_10]] : !felt.type, !felt.type
// CHECK-NEXT:          scf.yield %[[VAL_11]] : !felt.type
// CHECK-NEXT:        }
// CHECK-NEXT:        struct.writef %[[VAL_2]][@sum] = %[[VAL_6]] : <@Sum<[@N]>>, !felt.type
// CHECK-NEXT:        function.return %[[VAL_2]] : !struct.type<@Sum<[@N]>>
// CHECK-NEXT:      }
// CHECK-NEXT:      function.def @constrain(%[[VAL_12:[0-9a-zA-Z_\.]+]]: !struct.type<@Sum<[@N]>>, %[[VAL_13:[0-9a-zA-Z_\.]+]]: !pod.type<[@p: !array.type<@N x !felt.type>]>, %[[VAL_14:[0-9a-zA-Z_\.]+]]: !felt.type) attributes {function.allow_constraint} {
// CHECK-NEXT:        %[[VAL_15:[0-9a-zA-Z_\.]+]] = poly.read_const @N : index
// CHECK-NEXT:        %[[VAL_16:[0-9a-zA-Z_\.]+]] = arith.constant 0 : index
// CHECK-NEXT:        %[[VAL_17:[0-9a-zA-Z_\.]+]] = arith.constant 1 : index
// CHECK-NEXT:        %[[VAL_18:[0-9a-zA-Z_\.]+]] = scf.for %[[VAL_19:[0-9a-zA-Z_\.]+]] = %[[VAL_16]] to %[[VAL_15]] step %[[VAL_17]] iter_args(%[[VAL_20:[0-9a-zA-Z_\.]+]] = %[[VAL_14]]) -> (!felt.type) {
// CHECK-NEXT:          %[[VAL_21:[0-9a-zA-Z_\.]+]] = pod.read %[[VAL_13]][@p] : <[@p: !array.type<@N x !felt.type>]>, !array.type<@N x !felt.type>
// CHECK-NEXT:          %[[VAL_22:[0-9a-zA-Z_\.]+]] = array.read %[[VAL_21]]{{\[}}%[[VAL_19]]] : <@N x !felt.type>, !felt.type
// CHECK-NEXT:          %[[VAL_23:[0-9a-zA-Z_\.]+]] = felt.add %[[VAL_20]], %[[VAL_22]] : !felt.type, !felt.type
// CHECK-NEXT:          scf.yield %[[VAL_23]] : !felt.type
// CHECK-NEXT:        }
// CHECK-NEXT:        %[[VAL_24:[0-9a-zA-Z_\.]+]] = struct.readf %[[VAL_12]][@sum] : <@Sum<[@N]>>, !felt.type
// CHECK-NEXT:        constrain.eq %[[VAL_24]], %[[VAL_18]] : !felt.type, !felt.type
// CHECK-NEXT:        function.return
// CHECK-NEXT:      }
// CHECK-NEXT:    }
// CHECK-NEXT:    struct.def @SumUser {
// CHECK-NEXT:      struct.field @out : !array.type<2 x !felt.type> {llzk.pub}
// CHECK-NEXT:      struct.field @sums : !array.type<2 x !struct.type<@Sum<[#[[$ATTR_0]]]>>>
// CHECK-NEXT:      struct.field @sums$inputs : !array.type<2 x !pod.type<[@vec: !pod.type<[@p: !array.type<#[[$ATTR_0]] x !felt.type>]>, @c: !felt.type, @N: index]>>
// CHECK-NEXT:      function.def @compute(%[[VAL_25:[0-9a-zA-Z_\.]+]]: !array.type<7 x !felt.type>) -> !struct.type<@SumUser> attributes {function.allow_witness} {
// CHECK-NEXT:        %[[VAL_26:[0-9a-zA-Z_\.]+]] = struct.new : <@SumUser>
// CHECK-NEXT:        %[[VAL_27:[0-9a-zA-Z_\.]+]] = array.new  : <2 x !felt.type>
// CHECK-NEXT:        %[[VAL_28:[0-9a-zA-Z_\.]+]] = array.new  : <2 x !struct.type<@Sum<[#[[$ATTR_0]]]>>>
// CHECK-NEXT:        %[[VAL_29:[0-9a-zA-Z_\.]+]] = array.new  : <2 x !pod.type<[@vec: !pod.type<[@p: !array.type<#[[$ATTR_0]] x !felt.type>]>, @c: !felt.type, @N: index]>>
// CHECK-NEXT:        %[[VAL_30:[0-9a-zA-Z_\.]+]] = arith.constant 0 : index
// CHECK-NEXT:        %[[VAL_31:[0-9a-zA-Z_\.]+]] = arith.constant 1 : index
// CHECK-NEXT:        %[[VAL_32:[0-9a-zA-Z_\.]+]] = arith.constant 4 : index
// CHECK-NEXT:        %[[VAL_33:[0-9a-zA-Z_\.]+]] = arith.constant 3 : index
// CHECK-NEXT:        %[[VAL_34:[0-9a-zA-Z_\.]+]] = pod.new { @N = %[[VAL_32]] } (%[[VAL_32]]) : <[@vec: !pod.type<[@p: !array.type<#[[$ATTR_0]] x !felt.type>]>, @c: !felt.type, @N: index]>
// CHECK-NEXT:        array.write %[[VAL_29]]{{\[}}%[[VAL_30]]] = %[[VAL_34]] : <2 x !pod.type<[@vec: !pod.type<[@p: !array.type<#[[$ATTR_0]] x !felt.type>]>, @c: !felt.type, @N: index]>>, !pod.type<[@vec: !pod.type<[@p: !array.type<#[[$ATTR_0]] x !felt.type>]>, @c: !felt.type, @N: index]>
// CHECK-NEXT:        %[[VAL_35:[0-9a-zA-Z_\.]+]] = felt.const  0
// CHECK-NEXT:        %[[VAL_36:[0-9a-zA-Z_\.]+]] = array.read %[[VAL_29]]{{\[}}%[[VAL_30]]] : <2 x !pod.type<[@vec: !pod.type<[@p: !array.type<#[[$ATTR_0]] x !felt.type>]>, @c: !felt.type, @N: index]>>, !pod.type<[@vec: !pod.type<[@p: !array.type<#[[$ATTR_0]] x !felt.type>]>, @c: !felt.type, @N: index]>
// CHECK-NEXT:        pod.write %[[VAL_36]][@c] = %[[VAL_35]] : <[@vec: !pod.type<[@p: !array.type<#[[$ATTR_0]] x !felt.type>]>, @c: !felt.type, @N: index]>, !felt.type
// CHECK-NEXT:        array.write %[[VAL_29]]{{\[}}%[[VAL_30]]] = %[[VAL_36]] : <2 x !pod.type<[@vec: !pod.type<[@p: !array.type<#[[$ATTR_0]] x !felt.type>]>, @c: !felt.type, @N: index]>>, !pod.type<[@vec: !pod.type<[@p: !array.type<#[[$ATTR_0]] x !felt.type>]>, @c: !felt.type, @N: index]>
// CHECK-NEXT:        scf.for %[[VAL_37:[0-9a-zA-Z_\.]+]] = %[[VAL_30]] to %[[VAL_32]] step %[[VAL_31]] {
// CHECK-NEXT:          %[[VAL_38:[0-9a-zA-Z_\.]+]] = array.read %[[VAL_25]]{{\[}}%[[VAL_37]]] : <7 x !felt.type>, !felt.type
// CHECK-NEXT:          %[[VAL_39:[0-9a-zA-Z_\.]+]] = array.read %[[VAL_29]]{{\[}}%[[VAL_30]]] : <2 x !pod.type<[@vec: !pod.type<[@p: !array.type<#[[$ATTR_0]] x !felt.type>]>, @c: !felt.type, @N: index]>>, !pod.type<[@vec: !pod.type<[@p: !array.type<#[[$ATTR_0]] x !felt.type>]>, @c: !felt.type, @N: index]>
// CHECK-NEXT:          %[[VAL_40:[0-9a-zA-Z_\.]+]] = pod.read %[[VAL_39]][@vec] : <[@vec: !pod.type<[@p: !array.type<#[[$ATTR_0]] x !felt.type>]>, @c: !felt.type, @N: index]>, !pod.type<[@p: !array.type<#[[$ATTR_0]] x !felt.type>]>
// CHECK-NEXT:          %[[VAL_41:[0-9a-zA-Z_\.]+]] = pod.read %[[VAL_40]][@p] : <[@p: !array.type<#[[$ATTR_0]] x !felt.type>]>, !array.type<#[[$ATTR_0]] x !felt.type>
// CHECK-NEXT:          array.write %[[VAL_41]]{{\[}}%[[VAL_37]]] = %[[VAL_38]] : <#[[$ATTR_0]] x !felt.type>, !felt.type
// CHECK-NEXT:          pod.write %[[VAL_40]][@p] = %[[VAL_41]] : <[@p: !array.type<#[[$ATTR_0]] x !felt.type>]>, !array.type<#[[$ATTR_0]] x !felt.type>
// CHECK-NEXT:          pod.write %[[VAL_39]][@vec] = %[[VAL_40]] : <[@vec: !pod.type<[@p: !array.type<#[[$ATTR_0]] x !felt.type>]>, @c: !felt.type, @N: index]>, !pod.type<[@p: !array.type<#[[$ATTR_0]] x !felt.type>]>
// CHECK-NEXT:          array.write %[[VAL_29]]{{\[}}%[[VAL_30]]] = %[[VAL_39]] : <2 x !pod.type<[@vec: !pod.type<[@p: !array.type<#[[$ATTR_0]] x !felt.type>]>, @c: !felt.type, @N: index]>>, !pod.type<[@vec: !pod.type<[@p: !array.type<#[[$ATTR_0]] x !felt.type>]>, @c: !felt.type, @N: index]>
// CHECK-NEXT:        }
// CHECK-NEXT:        %[[VAL_42:[0-9a-zA-Z_\.]+]] = pod.new { @N = %[[VAL_33]] } (%[[VAL_33]]) : <[@vec: !pod.type<[@p: !array.type<#[[$ATTR_0]] x !felt.type>]>, @c: !felt.type, @N: index]>
// CHECK-NEXT:        array.write %[[VAL_29]]{{\[}}%[[VAL_31]]] = %[[VAL_42]] : <2 x !pod.type<[@vec: !pod.type<[@p: !array.type<#[[$ATTR_0]] x !felt.type>]>, @c: !felt.type, @N: index]>>, !pod.type<[@vec: !pod.type<[@p: !array.type<#[[$ATTR_0]] x !felt.type>]>, @c: !felt.type, @N: index]>
// CHECK-NEXT:        %[[VAL_43:[0-9a-zA-Z_\.]+]] = felt.const  1
// CHECK-NEXT:        %[[VAL_44:[0-9a-zA-Z_\.]+]] = array.read %[[VAL_29]]{{\[}}%[[VAL_31]]] : <2 x !pod.type<[@vec: !pod.type<[@p: !array.type<#[[$ATTR_0]] x !felt.type>]>, @c: !felt.type, @N: index]>>, !pod.type<[@vec: !pod.type<[@p: !array.type<#[[$ATTR_0]] x !felt.type>]>, @c: !felt.type, @N: index]>
// CHECK-NEXT:        pod.write %[[VAL_44]][@c] = %[[VAL_43]] : <[@vec: !pod.type<[@p: !array.type<#[[$ATTR_0]] x !felt.type>]>, @c: !felt.type, @N: index]>, !felt.type
// CHECK-NEXT:        array.write %[[VAL_29]]{{\[}}%[[VAL_31]]] = %[[VAL_44]] : <2 x !pod.type<[@vec: !pod.type<[@p: !array.type<#[[$ATTR_0]] x !felt.type>]>, @c: !felt.type, @N: index]>>, !pod.type<[@vec: !pod.type<[@p: !array.type<#[[$ATTR_0]] x !felt.type>]>, @c: !felt.type, @N: index]>
// CHECK-NEXT:        scf.for %[[VAL_45:[0-9a-zA-Z_\.]+]] = %[[VAL_30]] to %[[VAL_33]] step %[[VAL_31]] {
// CHECK-NEXT:          %[[VAL_46:[0-9a-zA-Z_\.]+]] = arith.addi %[[VAL_45]], %[[VAL_32]] : index
// CHECK-NEXT:          %[[VAL_47:[0-9a-zA-Z_\.]+]] = array.read %[[VAL_25]]{{\[}}%[[VAL_46]]] : <7 x !felt.type>, !felt.type
// CHECK-NEXT:          %[[VAL_48:[0-9a-zA-Z_\.]+]] = array.read %[[VAL_29]]{{\[}}%[[VAL_31]]] : <2 x !pod.type<[@vec: !pod.type<[@p: !array.type<#[[$ATTR_0]] x !felt.type>]>, @c: !felt.type, @N: index]>>, !pod.type<[@vec: !pod.type<[@p: !array.type<#[[$ATTR_0]] x !felt.type>]>, @c: !felt.type, @N: index]>
// CHECK-NEXT:          %[[VAL_49:[0-9a-zA-Z_\.]+]] = pod.read %[[VAL_48]][@vec] : <[@vec: !pod.type<[@p: !array.type<#[[$ATTR_0]] x !felt.type>]>, @c: !felt.type, @N: index]>, !pod.type<[@p: !array.type<#[[$ATTR_0]] x !felt.type>]>
// CHECK-NEXT:          %[[VAL_50:[0-9a-zA-Z_\.]+]] = pod.read %[[VAL_49]][@p] : <[@p: !array.type<#[[$ATTR_0]] x !felt.type>]>, !array.type<#[[$ATTR_0]] x !felt.type>
// CHECK-NEXT:          array.write %[[VAL_50]]{{\[}}%[[VAL_45]]] = %[[VAL_47]] : <#[[$ATTR_0]] x !felt.type>, !felt.type
// CHECK-NEXT:          pod.write %[[VAL_49]][@p] = %[[VAL_50]] : <[@p: !array.type<#[[$ATTR_0]] x !felt.type>]>, !array.type<#[[$ATTR_0]] x !felt.type>
// CHECK-NEXT:          pod.write %[[VAL_48]][@vec] = %[[VAL_49]] : <[@vec: !pod.type<[@p: !array.type<#[[$ATTR_0]] x !felt.type>]>, @c: !felt.type, @N: index]>, !pod.type<[@p: !array.type<#[[$ATTR_0]] x !felt.type>]>
// CHECK-NEXT:          array.write %[[VAL_29]]{{\[}}%[[VAL_31]]] = %[[VAL_48]] : <2 x !pod.type<[@vec: !pod.type<[@p: !array.type<#[[$ATTR_0]] x !felt.type>]>, @c: !felt.type, @N: index]>>, !pod.type<[@vec: !pod.type<[@p: !array.type<#[[$ATTR_0]] x !felt.type>]>, @c: !felt.type, @N: index]>
// CHECK-NEXT:        }
// CHECK-NEXT:        scf.for %[[VAL_51:[0-9a-zA-Z_\.]+]] = %[[VAL_30]] to %[[VAL_31]] step %[[VAL_31]] {
// CHECK-NEXT:          %[[VAL_52:[0-9a-zA-Z_\.]+]] = array.read %[[VAL_29]]{{\[}}%[[VAL_51]]] : <2 x !pod.type<[@vec: !pod.type<[@p: !array.type<#[[$ATTR_0]] x !felt.type>]>, @c: !felt.type, @N: index]>>, !pod.type<[@vec: !pod.type<[@p: !array.type<#[[$ATTR_0]] x !felt.type>]>, @c: !felt.type, @N: index]>
// CHECK-NEXT:          %[[VAL_53:[0-9a-zA-Z_\.]+]] = pod.read %[[VAL_52]][@vec] : <[@vec: !pod.type<[@p: !array.type<#[[$ATTR_0]] x !felt.type>]>, @c: !felt.type, @N: index]>, !pod.type<[@p: !array.type<#[[$ATTR_0]] x !felt.type>]>
// CHECK-NEXT:          %[[VAL_54:[0-9a-zA-Z_\.]+]] = pod.read %[[VAL_52]][@c] : <[@vec: !pod.type<[@p: !array.type<#[[$ATTR_0]] x !felt.type>]>, @c: !felt.type, @N: index]>, !felt.type
// CHECK-NEXT:          %[[VAL_55:[0-9a-zA-Z_\.]+]] = pod.read %[[VAL_52]][@N] : <[@vec: !pod.type<[@p: !array.type<#[[$ATTR_0]] x !felt.type>]>, @c: !felt.type, @N: index]>, index
// CHECK-NEXT:          %[[VAL_56:[0-9a-zA-Z_\.]+]] = function.call @Sum::@compute(%[[VAL_53]], %[[VAL_54]]) {(%[[VAL_55]])} : (!pod.type<[@p: !array.type<#[[$ATTR_0]] x !felt.type>]>, !felt.type) -> !struct.type<@Sum<[#[[$ATTR_0]]]>>
// CHECK-NEXT:          array.write %[[VAL_28]]{{\[}}%[[VAL_51]]] = %[[VAL_56]] : <2 x !struct.type<@Sum<[#[[$ATTR_0]]]>>>, !struct.type<@Sum<[#[[$ATTR_0]]]>>
// CHECK-NEXT:        }
// CHECK-NEXT:        %[[VAL_57:[0-9a-zA-Z_\.]+]] = array.read %[[VAL_28]]{{\[}}%[[VAL_30]]] : <2 x !struct.type<@Sum<[#[[$ATTR_0]]]>>>, !struct.type<@Sum<[#[[$ATTR_0]]]>>
// CHECK-NEXT:        %[[VAL_58:[0-9a-zA-Z_\.]+]] = struct.readf %[[VAL_57]][@sum] : <@Sum<[#[[$ATTR_0]]]>>, !felt.type
// CHECK-NEXT:        array.write %[[VAL_27]]{{\[}}%[[VAL_30]]] = %[[VAL_58]] : <2 x !felt.type>, !felt.type
// CHECK-NEXT:        %[[VAL_59:[0-9a-zA-Z_\.]+]] = array.read %[[VAL_28]]{{\[}}%[[VAL_31]]] : <2 x !struct.type<@Sum<[#[[$ATTR_0]]]>>>, !struct.type<@Sum<[#[[$ATTR_0]]]>>
// CHECK-NEXT:        %[[VAL_60:[0-9a-zA-Z_\.]+]] = struct.readf %[[VAL_59]][@sum] : <@Sum<[#[[$ATTR_0]]]>>, !felt.type
// CHECK-NEXT:        array.write %[[VAL_27]]{{\[}}%[[VAL_31]]] = %[[VAL_60]] : <2 x !felt.type>, !felt.type
// CHECK-NEXT:        struct.writef %[[VAL_26]][@out] = %[[VAL_27]] : <@SumUser>, !array.type<2 x !felt.type>
// CHECK-NEXT:        struct.writef %[[VAL_26]][@sums] = %[[VAL_28]] : <@SumUser>, !array.type<2 x !struct.type<@Sum<[#[[$ATTR_0]]]>>>
// CHECK-NEXT:        struct.writef %[[VAL_26]][@sums$inputs] = %[[VAL_29]] : <@SumUser>, !array.type<2 x !pod.type<[@vec: !pod.type<[@p: !array.type<#[[$ATTR_0]] x !felt.type>]>, @c: !felt.type, @N: index]>>
// CHECK-NEXT:        function.return %[[VAL_26]] : !struct.type<@SumUser>
// CHECK-NEXT:      }
// CHECK-NEXT:      function.def @constrain(%[[VAL_61:[0-9a-zA-Z_\.]+]]: !struct.type<@SumUser>, %[[VAL_62:[0-9a-zA-Z_\.]+]]: !array.type<7 x !felt.type>) attributes {function.allow_constraint} {
// CHECK-NEXT:        function.return
// CHECK-NEXT:      }
// CHECK-NEXT:    }
// CHECK-NEXT:  }
