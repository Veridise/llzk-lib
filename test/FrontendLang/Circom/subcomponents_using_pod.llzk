// RUN: llzk-opt -split-input-file %s 2>&1 | FileCheck --enable-var-scope %s


//////////////////////////////////////////////////////////////////////////////////
// This example shows how to use the pod dialect for working with subcomponents
// and buses.
//////////////////////////////////////////////////////////////////////////////////
// bus Vec(N) {
//   signal p[N];
// }
//
// template Sum(N) {
//   input Vec(N) vec;
//   signal input c;
//   signal output sum;
//   var acc = c;
//   for (var i = 0; i < N; i++) {
//     acc += vec.p[i];
//   }
//   sum <== acc;
// }
//
// template SumUser() {
//   signal input x[7];
//   signal output out[2];
//   component sums[2];
//   sums[0] = Sum(4);
//   sums[0].c <== 0;
//   for (var i = 0; i < 4; i++) {
//     sums[0].vec.p[i] <== x[i];
//   }
//   sums[1] = Sum(3);
//   sums[1].c <== 1;
//   for (var i = 0; i < 3; i++) {
//     sums[1].vec.p[i] <== x[i+4];
//   }
//   out[0] <== sums[0].sum;
//   out[1] <== sums[1].sum;
// }
//
// component main = SumUser();
//////////////////////////////////////////////////////////////////////////////////

// The bus is represented with a `!pod.type`.
!Vec = !pod.type<[@p: !array.type<affine_map<(d0) -> (d0)> x !felt.type>]>

// Type used to represent the inputs of the Sum template
// We alias it here since we are going to repeat it a lot in the IR
!sums_inputs = !pod.type<[@vec: !Vec, @c: !felt.type, @N: index]>

module attributes { veridise.lang = "llzk" } {

  struct.def @Sum<[@N]> {
    struct.field @sum : !felt.type {llzk.pub}
    function.def @compute(%vec: !pod.type<[@p: !array.type<@N x !felt.type>]>, %c: !felt.type) -> !struct.type<@Sum<[@N]>> {
      %self = struct.new : <@Sum<[@N]>>
      %n = poly.read_const @N : index 
      %const_0 = arith.constant 0 : index
      %const_1 = arith.constant 1 : index
      %acc = scf.for %i = %const_0 to %n step %const_1 
        iter_args(%acc = %c) -> (!felt.type)
      {
        %0 = pod.read %vec[@p] : !pod.type<[@p: !array.type<@N x !felt.type>]>, !array.type<@N x !felt.type>
        %1 = array.read %0[%i] : !array.type<@N x !felt.type>, !felt.type 
        %2 = felt.add %acc, %1
        scf.yield %2 : !felt.type
      }
      struct.writef %self[@sum] = %acc : !struct.type<@Sum<[@N]>>, !felt.type
      function.return %self : !struct.type<@Sum<[@N]>>
    }
    function.def @constrain(%self: !struct.type<@Sum<[@N]>>, %vec: !pod.type<[@p: !array.type<@N x !felt.type>]>, %c: !felt.type) {
      %n = poly.read_const @N : index 
      %const_0 = arith.constant 0 : index
      %const_1 = arith.constant 1 : index
      %acc = scf.for %i = %const_0 to %n step %const_1 
        iter_args(%acc = %c) -> (!felt.type)
      {
        %0 = pod.read %vec[@p] : !pod.type<[@p: !array.type<@N x !felt.type>]>, !array.type<@N x !felt.type>
        %1 = array.read %0[%i] : !array.type<@N x !felt.type>, !felt.type 
        %2 = felt.add %acc, %1
        scf.yield %2 : !felt.type
      }
      %3 = struct.readf %self[@sum] : !struct.type<@Sum<[@N]>>, !felt.type
      constrain.eq %3, %acc : !felt.type
      function.return
    }
  }

  struct.def @SumUser {
    struct.field @out : !array.type<2 x !felt.type> {llzk.pub}
    struct.field @sums : !array.type<2 x !struct.type<@Sum<[affine_map<(d0) -> (d0)>]>>>
    struct.field @"sums$inputs" : !array.type<2 x !sums_inputs>
    function.def @compute(%x: !array.type<7 x !felt.type>) -> !struct.type<@SumUser> {
      // Prologue
      %self = struct.new : <@SumUser>
      %out = array.new : !array.type<2 x !felt.type>
      %sums = array.new : !array.type<2 x !struct.type<@Sum<[affine_map<(d0) -> (d0)>]>>>
      %sums_inputs = array.new : !array.type<2 x !sums_inputs>
      %const_0 = arith.constant 0 : index
      %const_1 = arith.constant 1 : index
      %const_4 = arith.constant 4 : index
      %const_3 = arith.constant 3 : index

      // sums[0] = Sum(4);
      %0 = pod.new { @N = %const_4 } (%const_4) : !sums_inputs
      array.write %sums_inputs[%const_0] = %0 : !array.type<2 x !sums_inputs>, !sums_inputs

      // sums[0].c <== 0;
      %const_felt_0 = felt.const  0 
      %1 = array.read %sums_inputs[%const_0] : !array.type<2 x !sums_inputs>, !sums_inputs
      pod.write %1[@c] = %const_felt_0 : !sums_inputs, !felt.type
      array.write %sums_inputs[%const_0] = %1 : !array.type<2 x !sums_inputs>, !sums_inputs

      scf.for %i = %const_0 to %const_4 step %const_1 {
        // sums[0].vec.p[i] <== x[i];
        %8 = array.read %x[%i] : !array.type<7 x !felt.type>, !felt.type
        %9 = array.read %sums_inputs[%const_0] : !array.type<2 x !sums_inputs>, !sums_inputs
        %10 = pod.read %9[@vec] : !sums_inputs, !Vec
        %11 = pod.read %10[@p] : !Vec, !array.type<affine_map<(d0) -> (d0)> x !felt.type>
        array.write %11[%i] = %8 : !array.type<affine_map<(d0) -> (d0)> x !felt.type>, !felt.type
        pod.write %10[@p] = %11 : !Vec, !array.type<affine_map<(d0) -> (d0)> x !felt.type>
        pod.write %9[@vec] = %10 : !sums_inputs, !Vec
        array.write %sums_inputs[%const_0] = %9 : !array.type<2 x !sums_inputs>, !sums_inputs
      }

      // sums[1] = Sum(3);
      %2 = pod.new { @N = %const_3 } (%const_3) : !sums_inputs
      array.write %sums_inputs[%const_1] = %2 : !array.type<2 x !sums_inputs>, !sums_inputs

      // sums[1].c <== 1;
      %const_felt_1 = felt.const  1
      %3 = array.read %sums_inputs[%const_1] : !array.type<2 x !sums_inputs>, !sums_inputs
      pod.write %3[@c] = %const_felt_1 : !sums_inputs, !felt.type
      array.write %sums_inputs[%const_1] = %3 : !array.type<2 x !sums_inputs>, !sums_inputs

      scf.for %i = %const_0 to %const_3 step %const_1 {
        // sums[1].vec.p[i] <== x[i+4];
        %12 = arith.addi %i, %const_4 : index 
        %13 = array.read %x[%12] : !array.type<7 x !felt.type>, !felt.type
        %14 = array.read %sums_inputs[%const_1] : !array.type<2 x !sums_inputs>, !sums_inputs
        %15 = pod.read %14[@vec] : !sums_inputs, !Vec
        %16 = pod.read %15[@p] : !Vec, !array.type<affine_map<(d0) -> (d0)> x !felt.type>
        array.write %16[%i] = %13 : !array.type<affine_map<(d0) -> (d0)> x !felt.type>, !felt.type
        pod.write %15[@p] = %16 : !Vec, !array.type<affine_map<(d0) -> (d0)> x !felt.type>
        pod.write %14[@vec] = %15 : !sums_inputs, !Vec
        array.write %sums_inputs[%const_1] = %14 : !array.type<2 x !sums_inputs>, !sums_inputs
      }

      // Constructors
      scf.for %i = %const_0 to %const_1 step %const_1 {
        %17 = array.read %sums_inputs[%i] : !array.type<2 x !sums_inputs>, !sums_inputs
        %18 = pod.read %17[@vec] : !sums_inputs, !Vec
        %19 = pod.read %17[@c] : !sums_inputs, !felt.type
        %20 = pod.read %17[@N] : !sums_inputs, index
    	  %21 = function.call @Sum::@compute(%18, %19){(%20)} : (!Vec, !felt.type) -> !struct.type<@Sum<[affine_map<(d0) -> (d0)>]>>
        array.write %sums[%i] = %21 : !array.type<2 x !struct.type<@Sum<[affine_map<(d0) -> (d0)>]>>>, !struct.type<@Sum<[affine_map<(d0) -> (d0)>]>>
      }

      // out[0] <== sums[0].sum;
      %4 = array.read %sums[%const_0] : !array.type<2 x !struct.type<@Sum<[affine_map<(d0) -> (d0)>]>>>, !struct.type<@Sum<[affine_map<(d0) -> (d0)>]>>
      %5 = struct.readf %4[@sum] : !struct.type<@Sum<[affine_map<(d0) -> (d0)>]>>, !felt.type
      array.write %out[%const_0] = %5 : !array.type<2 x !felt.type>, !felt.type

      // out[1] <== sums[1].sum;
      %6 = array.read %sums[%const_1] : !array.type<2 x !struct.type<@Sum<[affine_map<(d0) -> (d0)>]>>>, !struct.type<@Sum<[affine_map<(d0) -> (d0)>]>>
      %7 = struct.readf %6[@sum] : !struct.type<@Sum<[affine_map<(d0) -> (d0)>]>>, !felt.type
      array.write %out[%const_1] = %7 : !array.type<2 x !felt.type>, !felt.type

      // Epilogue
      struct.writef %self[@out] = %out : <@SumUser>, !array.type<2 x !felt.type>
      struct.writef %self[@sums] = %sums : <@SumUser>, !array.type<2 x !struct.type<@Sum<[affine_map<(d0) -> (d0)>]>>>
      struct.writef %self[@"sums$inputs"] = %sums_inputs : <@SumUser>, !array.type<2 x !sums_inputs>
      function.return %self : !struct.type<@SumUser>
    }
    function.def @constrain(%self: !struct.type<@SumUser>, %x: !array.type<7 x !felt.type>) {
      function.return
    }
  }
}
