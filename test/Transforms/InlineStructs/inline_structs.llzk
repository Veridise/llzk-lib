// RUN: llzk-opt -split-input-file -llzk-flatten -llzk-inline-structs -verify-diagnostics %s | FileCheck %s

// TESTS: a basic scenario of inling 2 levels deep
module attributes {veridise.lang = "llzk"} {
  struct.def @Component1A {
    struct.field @f1 : !felt.type
    struct.field @f2 : !felt.type

    function.def @compute(%z: !felt.type) -> !struct.type<@Component1A> {
      %self = struct.new : !struct.type<@Component1A>
      struct.writef %self[@f1] = %z : !struct.type<@Component1A>, !felt.type
      struct.writef %self[@f2] = %z : !struct.type<@Component1A>, !felt.type
      function.return %self : !struct.type<@Component1A>
    }

    function.def @constrain(%self: !struct.type<@Component1A>, %z: !felt.type) {
      %a = struct.readf %self[@f1] : !struct.type<@Component1A>, !felt.type
      constrain.eq %a, %z : !felt.type
      %b = struct.readf %self[@f2] : !struct.type<@Component1A>, !felt.type
      constrain.eq %b, %z : !felt.type
      function.return
    }
  }

  struct.def @Component1B {
    struct.field @f2 : !struct.type<@Component1A>

    function.def @compute(%z: !felt.type) -> !struct.type<@Component1B> {
      %self = struct.new : !struct.type<@Component1B>
      %q = function.call @Component1A::@compute(%z) : (!felt.type) -> !struct.type<@Component1A>
      struct.writef %self[@f2] = %q : !struct.type<@Component1B>, !struct.type<@Component1A>
      function.return %self : !struct.type<@Component1B>
    }

    function.def @constrain(%self: !struct.type<@Component1B>, %z: !felt.type) {
      %q = struct.readf %self[@f2] : !struct.type<@Component1B>, !struct.type<@Component1A>
      function.call @Component1A::@constrain(%q, %z) : (!struct.type<@Component1A>,!felt.type) -> ()
      function.return
    }
  }

  struct.def @Main {
    struct.field @f : !struct.type<@Component1B>

    function.def @compute() -> !struct.type<@Main> {
      %z = felt.const 42
      %self = struct.new : !struct.type<@Main>
      %c = function.call @Component1B::@compute(%z) : (!felt.type) -> !struct.type<@Component1B>
      struct.writef %self[@f] = %c : !struct.type<@Main>, !struct.type<@Component1B>
      function.return %self : !struct.type<@Main>
    }

    function.def @constrain(%self: !struct.type<@Main>) {
      %z = felt.const 42
      %c = struct.readf %self[@f] : !struct.type<@Main>, !struct.type<@Component1B>
      function.call @Component1B::@constrain(%c, %z) : (!struct.type<@Component1B>,!felt.type) -> ()
      function.return
    }
  }
}
// CHECK-LABEL:   struct.def @Main {
// CHECK-NEXT:      struct.field @"f:!s<@Component1B>+f2:!s<@Component1A>+f1" : !felt.type
// CHECK-NEXT:      struct.field @"f:!s<@Component1B>+f2:!s<@Component1A>+f2" : !felt.type
// CHECK-NEXT:      function.def @compute() -> !struct.type<@Main> attributes {function.allow_witness} {
// CHECK-NEXT:        %[[VAL_0:[0-9a-zA-Z_\.]+]] = felt.const 42
// CHECK-NEXT:        %[[VAL_1:[0-9a-zA-Z_\.]+]] = struct.new : <@Main>
// CHECK-NEXT:        struct.writef %[[VAL_1]][@"f:!s<@Component1B>+f2:!s<@Component1A>+f1"] = %[[VAL_0]] : <@Main>, !felt.type
// CHECK-NEXT:        struct.writef %[[VAL_1]][@"f:!s<@Component1B>+f2:!s<@Component1A>+f2"] = %[[VAL_0]] : <@Main>, !felt.type
// CHECK-NEXT:        function.return %[[VAL_1]] : !struct.type<@Main>
// CHECK-NEXT:      }
// CHECK-NEXT:      function.def @constrain(%[[VAL_2:[0-9a-zA-Z_\.]+]]: !struct.type<@Main>) attributes {function.allow_constraint} {
// CHECK-NEXT:        %[[VAL_3:[0-9a-zA-Z_\.]+]] = felt.const 42
// CHECK-NEXT:        %[[VAL_4:[0-9a-zA-Z_\.]+]] = struct.readf %[[VAL_2]][@"f:!s<@Component1B>+f2:!s<@Component1A>+f1"] : <@Main>, !felt.type
// CHECK-NEXT:        constrain.eq %[[VAL_4]], %[[VAL_3]] : !felt.type, !felt.type
// CHECK-NEXT:        %[[VAL_5:[0-9a-zA-Z_\.]+]] = struct.readf %[[VAL_2]][@"f:!s<@Component1B>+f2:!s<@Component1A>+f2"] : <@Main>, !felt.type
// CHECK-NEXT:        constrain.eq %[[VAL_5]], %[[VAL_3]] : !felt.type, !felt.type
// CHECK-NEXT:        function.return
// CHECK-NEXT:      }
// CHECK-NEXT:    }
// -----

// TESTS: multiple callees inlined into the same caller
module attributes {veridise.lang = "llzk"} {
  struct.def @Component2A {
    struct.field @f1 : index
    struct.field @f2 : i1

    function.def @compute(%a: index, %b: i1) -> !struct.type<@Component2A> {
      %self = struct.new : !struct.type<@Component2A>
      struct.writef %self[@f1] = %a : !struct.type<@Component2A>, index
      struct.writef %self[@f2] = %b : !struct.type<@Component2A>, i1
      function.return %self : !struct.type<@Component2A>
    }

    function.def @constrain(%self: !struct.type<@Component2A>, %a: index, %b: i1) {
      %x = struct.readf %self[@f1] : !struct.type<@Component2A>, index
      constrain.eq %a, %x : index
      %y = struct.readf %self[@f2] : !struct.type<@Component2A>, i1
      constrain.eq %b, %y : i1
      function.return
    }
  }

  struct.def @Component2B {
    struct.field @f1 : !string.type

    function.def @compute(%z: !string.type) -> !struct.type<@Component2B> {
      %self = struct.new : !struct.type<@Component2B>
      struct.writef %self[@f1] = %z : !struct.type<@Component2B>, !string.type
      function.return %self : !struct.type<@Component2B>
    }

    function.def @constrain(%self: !struct.type<@Component2B>, %z: !string.type) {
      %a = struct.readf %self[@f1] : !struct.type<@Component2B>, !string.type
      function.return
    }
  }

  struct.def @Main {
    struct.field @f1 : !struct.type<@Component2B>
    struct.field @f2 : !struct.type<@Component2A>

    function.def @compute() -> !struct.type<@Main> {
      %42 = arith.constant 42 : index
      %T = arith.constant true
      %s = string.new "Hello World"
      //
      %self = struct.new : !struct.type<@Main>
      %a = function.call @Component2A::@compute(%42,%T) : (index,i1) -> !struct.type<@Component2A>
      %b = function.call @Component2B::@compute(%s) : (!string.type) -> !struct.type<@Component2B>
      struct.writef %self[@f1] = %b : !struct.type<@Main>, !struct.type<@Component2B>
      struct.writef %self[@f2] = %a : !struct.type<@Main>, !struct.type<@Component2A>
      function.return %self : !struct.type<@Main>
    }

    function.def @constrain(%self: !struct.type<@Main>) {
      %42 = arith.constant 42 : index
      %T = arith.constant true
      %s = string.new "Hello World"
      //
      %a = struct.readf %self[@f2] : !struct.type<@Main>, !struct.type<@Component2A>
      %b = struct.readf %self[@f1] : !struct.type<@Main>, !struct.type<@Component2B>
      function.call @Component2B::@constrain(%b, %s) : (!struct.type<@Component2B>,!string.type) -> ()
      function.call @Component2A::@constrain(%a, %42, %T) : (!struct.type<@Component2A>,index,i1) -> ()
      function.return
    }
  }
}
// CHECK-LABEL:   struct.def @Main {
// CHECK-NEXT:      struct.field @"f1:!s<@Component2B>+f1" : !string.type
// CHECK-NEXT:      struct.field @"f2:!s<@Component2A>+f1" : index
// CHECK-NEXT:      struct.field @"f2:!s<@Component2A>+f2" : i1
// CHECK-NEXT:      function.def @compute() -> !struct.type<@Main> attributes {function.allow_witness} {
// CHECK-NEXT:        %[[VAL_0:[0-9a-zA-Z_\.]+]] = arith.constant 42 : index
// CHECK-NEXT:        %[[VAL_1:[0-9a-zA-Z_\.]+]] = arith.constant true
// CHECK-NEXT:        %[[VAL_2:[0-9a-zA-Z_\.]+]] = string.new "Hello World"
// CHECK-NEXT:        %[[VAL_3:[0-9a-zA-Z_\.]+]] = struct.new : <@Main>
// CHECK-NEXT:        struct.writef %[[VAL_3]][@"f2:!s<@Component2A>+f1"] = %[[VAL_0]] : <@Main>, index
// CHECK-NEXT:        struct.writef %[[VAL_3]][@"f2:!s<@Component2A>+f2"] = %[[VAL_1]] : <@Main>, i1
// CHECK-NEXT:        struct.writef %[[VAL_3]][@"f1:!s<@Component2B>+f1"] = %[[VAL_2]] : <@Main>, !string.type
// CHECK-NEXT:        function.return %[[VAL_3]] : !struct.type<@Main>
// CHECK-NEXT:      }
// CHECK-NEXT:      function.def @constrain(%[[VAL_4:[0-9a-zA-Z_\.]+]]: !struct.type<@Main>) attributes {function.allow_constraint} {
// CHECK-NEXT:        %[[VAL_5:[0-9a-zA-Z_\.]+]] = arith.constant 42 : index
// CHECK-NEXT:        %[[VAL_6:[0-9a-zA-Z_\.]+]] = arith.constant true
// CHECK-NEXT:        %[[VAL_7:[0-9a-zA-Z_\.]+]] = string.new "Hello World"
// CHECK-NEXT:        %[[VAL_8:[0-9a-zA-Z_\.]+]] = struct.readf %[[VAL_4]][@"f1:!s<@Component2B>+f1"] : <@Main>, !string.type
// CHECK-NEXT:        %[[VAL_9:[0-9a-zA-Z_\.]+]] = struct.readf %[[VAL_4]][@"f2:!s<@Component2A>+f1"] : <@Main>, index
// CHECK-NEXT:        constrain.eq %[[VAL_5]], %[[VAL_9]] : index, index
// CHECK-NEXT:        %[[VAL_10:[0-9a-zA-Z_\.]+]] = struct.readf %[[VAL_4]][@"f2:!s<@Component2A>+f2"] : <@Main>, i1
// CHECK-NEXT:        constrain.eq %[[VAL_6]], %[[VAL_10]] : i1, i1
// CHECK-NEXT:        function.return
// CHECK-NEXT:      }
// CHECK-NEXT:    }
// -----

// TESTS:
//  - same callee inlined multiple times into one caller
//  - a struct that has multiple fields of the same StructType
module attributes {veridise.lang = "llzk"} {
  struct.def @Component3A {
    struct.field @f1 : index
    struct.field @f2 : i1

    function.def @compute(%a: index, %b: i1) -> !struct.type<@Component3A> {
      %self = struct.new : !struct.type<@Component3A>
      struct.writef %self[@f1] = %a : !struct.type<@Component3A>, index
      struct.writef %self[@f2] = %b : !struct.type<@Component3A>, i1
      function.return %self : !struct.type<@Component3A>
    }

    function.def @constrain(%self: !struct.type<@Component3A>, %a: index, %b: i1) {
      %x = struct.readf %self[@f1] : !struct.type<@Component3A>, index
      constrain.eq %a, %x : index
      %y = struct.readf %self[@f2] : !struct.type<@Component3A>, i1
      constrain.eq %b, %y : i1
      function.return
    }
  }

  struct.def @Main {
    struct.field @f1 : !struct.type<@Component3A>
    struct.field @f2 : !struct.type<@Component3A>
    struct.field @f3 : !struct.type<@Component3A>

    function.def @compute() -> !struct.type<@Main> {
      %24 = arith.constant 24 : index
      %76 = arith.constant 76 : index
      %99 = arith.constant 99 : index
      %T = arith.constant true
      %F = arith.constant false
      //
      %self = struct.new : !struct.type<@Main>
      %a = function.call @Component3A::@compute(%24, %T) : (index,i1) -> !struct.type<@Component3A>
      struct.writef %self[@f1] = %a : !struct.type<@Main>, !struct.type<@Component3A>
      %b = function.call @Component3A::@compute(%76, %F) : (index,i1) -> !struct.type<@Component3A>
      %c = function.call @Component3A::@compute(%99, %T) : (index,i1) -> !struct.type<@Component3A>
      struct.writef %self[@f2] = %b : !struct.type<@Main>, !struct.type<@Component3A>
      struct.writef %self[@f3] = %c : !struct.type<@Main>, !struct.type<@Component3A>
      function.return %self : !struct.type<@Main>
    }

    function.def @constrain(%self: !struct.type<@Main>) {
      %24 = arith.constant 24 : index
      %76 = arith.constant 76 : index
      %99 = arith.constant 99 : index
      %T = arith.constant true
      %F = arith.constant false
      //
      %a = struct.readf %self[@f1] : !struct.type<@Main>, !struct.type<@Component3A>
      function.call @Component3A::@constrain(%a, %24, %T) : (!struct.type<@Component3A>,index,i1) -> ()
      %b = struct.readf %self[@f2] : !struct.type<@Main>, !struct.type<@Component3A>
      function.call @Component3A::@constrain(%a, %76, %F) : (!struct.type<@Component3A>,index,i1) -> ()
      %c = struct.readf %self[@f3] : !struct.type<@Main>, !struct.type<@Component3A>
      function.call @Component3A::@constrain(%a, %99, %T) : (!struct.type<@Component3A>,index,i1) -> ()
      function.return
    }
  }
}
// CHECK-LABEL:   struct.def @Main {
// CHECK-NEXT:      struct.field @"f1:!s<@Component3A>+f1" : index
// CHECK-NEXT:      struct.field @"f1:!s<@Component3A>+f2" : i1
// CHECK-NEXT:      struct.field @"f2:!s<@Component3A>+f1" : index
// CHECK-NEXT:      struct.field @"f2:!s<@Component3A>+f2" : i1
// CHECK-NEXT:      struct.field @"f3:!s<@Component3A>+f1" : index
// CHECK-NEXT:      struct.field @"f3:!s<@Component3A>+f2" : i1
// CHECK-NEXT:      function.def @compute() -> !struct.type<@Main> attributes {function.allow_witness} {
// CHECK-NEXT:        %[[VAL_0:[0-9a-zA-Z_\.]+]] = arith.constant 24 : index
// CHECK-NEXT:        %[[VAL_1:[0-9a-zA-Z_\.]+]] = arith.constant 76 : index
// CHECK-NEXT:        %[[VAL_2:[0-9a-zA-Z_\.]+]] = arith.constant 99 : index
// CHECK-NEXT:        %[[VAL_3:[0-9a-zA-Z_\.]+]] = arith.constant true
// CHECK-NEXT:        %[[VAL_4:[0-9a-zA-Z_\.]+]] = arith.constant false
// CHECK-NEXT:        %[[VAL_5:[0-9a-zA-Z_\.]+]] = struct.new : <@Main>
// CHECK-NEXT:        struct.writef %[[VAL_5]][@"f1:!s<@Component3A>+f1"] = %[[VAL_0]] : <@Main>, index
// CHECK-NEXT:        struct.writef %[[VAL_5]][@"f1:!s<@Component3A>+f2"] = %[[VAL_3]] : <@Main>, i1
// CHECK-NEXT:        struct.writef %[[VAL_5]][@"f2:!s<@Component3A>+f1"] = %[[VAL_1]] : <@Main>, index
// CHECK-NEXT:        struct.writef %[[VAL_5]][@"f2:!s<@Component3A>+f2"] = %[[VAL_4]] : <@Main>, i1
// CHECK-NEXT:        struct.writef %[[VAL_5]][@"f3:!s<@Component3A>+f1"] = %[[VAL_2]] : <@Main>, index
// CHECK-NEXT:        struct.writef %[[VAL_5]][@"f3:!s<@Component3A>+f2"] = %[[VAL_3]] : <@Main>, i1
// CHECK-NEXT:        function.return %[[VAL_5]] : !struct.type<@Main>
// CHECK-NEXT:      }
// CHECK-NEXT:      function.def @constrain(%[[VAL_6:[0-9a-zA-Z_\.]+]]: !struct.type<@Main>) attributes {function.allow_constraint} {
// CHECK-NEXT:        %[[VAL_7:[0-9a-zA-Z_\.]+]] = arith.constant 24 : index
// CHECK-NEXT:        %[[VAL_8:[0-9a-zA-Z_\.]+]] = arith.constant 76 : index
// CHECK-NEXT:        %[[VAL_9:[0-9a-zA-Z_\.]+]] = arith.constant 99 : index
// CHECK-NEXT:        %[[VAL_10:[0-9a-zA-Z_\.]+]] = arith.constant true
// CHECK-NEXT:        %[[VAL_11:[0-9a-zA-Z_\.]+]] = arith.constant false
// CHECK-NEXT:        %[[VAL_12:[0-9a-zA-Z_\.]+]] = struct.readf %[[VAL_6]][@"f1:!s<@Component3A>+f1"] : <@Main>, index
// CHECK-NEXT:        constrain.eq %[[VAL_7]], %[[VAL_12]] : index, index
// CHECK-NEXT:        %[[VAL_13:[0-9a-zA-Z_\.]+]] = struct.readf %[[VAL_6]][@"f1:!s<@Component3A>+f2"] : <@Main>, i1
// CHECK-NEXT:        constrain.eq %[[VAL_10]], %[[VAL_13]] : i1, i1
// CHECK-NEXT:        %[[VAL_14:[0-9a-zA-Z_\.]+]] = struct.readf %[[VAL_6]][@"f1:!s<@Component3A>+f1"] : <@Main>, index
// CHECK-NEXT:        constrain.eq %[[VAL_8]], %[[VAL_14]] : index, index
// CHECK-NEXT:        %[[VAL_15:[0-9a-zA-Z_\.]+]] = struct.readf %[[VAL_6]][@"f1:!s<@Component3A>+f2"] : <@Main>, i1
// CHECK-NEXT:        constrain.eq %[[VAL_11]], %[[VAL_15]] : i1, i1
// CHECK-NEXT:        %[[VAL_16:[0-9a-zA-Z_\.]+]] = struct.readf %[[VAL_6]][@"f1:!s<@Component3A>+f1"] : <@Main>, index
// CHECK-NEXT:        constrain.eq %[[VAL_9]], %[[VAL_16]] : index, index
// CHECK-NEXT:        %[[VAL_17:[0-9a-zA-Z_\.]+]] = struct.readf %[[VAL_6]][@"f1:!s<@Component3A>+f2"] : <@Main>, i1
// CHECK-NEXT:        constrain.eq %[[VAL_10]], %[[VAL_17]] : i1, i1
// CHECK-NEXT:        function.return
// CHECK-NEXT:      }
// CHECK-NEXT:    }
// -----

// TESTS: same callee inlined into different callers
module attributes {veridise.lang = "llzk"} {
  struct.def @Component4A {
    struct.field @f : !array.type<4 x !felt.type>

    function.def @compute(%a: !felt.type, %b: !felt.type, %c: !felt.type, %d: !felt.type) -> !struct.type<@Component4A> {
      %self = struct.new : !struct.type<@Component4A>
      %arr = array.new %a, %b, %c, %d : !array.type<4 x !felt.type>
      struct.writef %self[@f] = %arr : !struct.type<@Component4A>, !array.type<4 x !felt.type>
      function.return %self : !struct.type<@Component4A>
    }

    function.def @constrain(%self: !struct.type<@Component4A>, %a: !felt.type, %b: !felt.type, %c: !felt.type, %d: !felt.type) {
      %arr = struct.readf %self[@f] : !struct.type<@Component4A>, !array.type<4 x !felt.type>
      %brr = array.new %a, %b, %c, %d : !array.type<4 x !felt.type>
      constrain.eq %arr, %brr : !array.type<4 x !felt.type>
      function.return
    }
  }

  struct.def @Component4B {
    struct.field @f : !struct.type<@Component4A>

    function.def @compute() -> !struct.type<@Component4B> {
      %a = felt.const 3
      %b = felt.const 4
      %c = felt.const 5
      %d = felt.const 6
      %self = struct.new : !struct.type<@Component4B>
      %x = function.call @Component4A::@compute(%a,%b,%c,%d) : (!felt.type,!felt.type,!felt.type,!felt.type) -> !struct.type<@Component4A>
      struct.writef %self[@f] = %x : !struct.type<@Component4B>, !struct.type<@Component4A>
      function.return %self : !struct.type<@Component4B>
    }

    function.def @constrain(%self: !struct.type<@Component4B>) {
      %a = felt.const 3
      %b = felt.const 4
      %c = felt.const 5
      %d = felt.const 6
      %x = struct.readf %self[@f] : !struct.type<@Component4B>, !struct.type<@Component4A>
      function.call @Component4A::@constrain(%x,%a,%b,%c,%d) : (!struct.type<@Component4A>,!felt.type,!felt.type,!felt.type,!felt.type) -> ()
      function.return
    }
  }

  struct.def @Component4C {
    struct.field @f : !struct.type<@Component4A>

    function.def @compute(%f: !felt.type) -> !struct.type<@Component4C> {
      %self = struct.new : !struct.type<@Component4C>
      %x = function.call @Component4A::@compute(%f,%f,%f,%f) : (!felt.type,!felt.type,!felt.type,!felt.type) -> !struct.type<@Component4A>
      struct.writef %self[@f] = %x : !struct.type<@Component4C>, !struct.type<@Component4A>
      function.return %self : !struct.type<@Component4C>
    }

    function.def @constrain(%self: !struct.type<@Component4C>, %f: !felt.type) {
      %x = struct.readf %self[@f] : !struct.type<@Component4C>, !struct.type<@Component4A>
      function.call @Component4A::@constrain(%x,%f,%f,%f,%f) : (!struct.type<@Component4A>,!felt.type,!felt.type,!felt.type,!felt.type) -> ()
      function.return
    }
  }

  struct.def @Main {
    struct.field @f1 : !struct.type<@Component4B>
    struct.field @f2 : !struct.type<@Component4C>

    function.def @compute() -> !struct.type<@Main> {
      %self = struct.new : !struct.type<@Main>
      %2 = felt.const 2
      %c = function.call @Component4C::@compute(%2) : (!felt.type) -> !struct.type<@Component4C>
      %b = function.call @Component4B::@compute() : () -> !struct.type<@Component4B>
      struct.writef %self[@f1] = %b : !struct.type<@Main>, !struct.type<@Component4B>
      struct.writef %self[@f2] = %c : !struct.type<@Main>, !struct.type<@Component4C>
      function.return %self : !struct.type<@Main>
    }

    function.def @constrain(%self: !struct.type<@Main>) {
      %c = struct.readf %self[@f2] : !struct.type<@Main>, !struct.type<@Component4C>
      %b = struct.readf %self[@f1] : !struct.type<@Main>, !struct.type<@Component4B>
      function.call @Component4B::@constrain(%b) : (!struct.type<@Component4B>) -> ()
      %2 = felt.const 2
      function.call @Component4C::@constrain(%c, %2) : (!struct.type<@Component4C>,!felt.type) -> ()
      function.return
    }
  }
}
// CHECK-LABEL:   struct.def @Main {
// CHECK-NEXT:      struct.field @"f1:!s<@Component4B>+f:!s<@Component4A>+f" : !array.type<4 x !felt.type>
// CHECK-NEXT:      struct.field @"f2:!s<@Component4C>+f:!s<@Component4A>+f" : !array.type<4 x !felt.type>
// CHECK-NEXT:      function.def @compute() -> !struct.type<@Main> attributes {function.allow_witness} {
// CHECK-NEXT:        %[[VAL_0:[0-9a-zA-Z_\.]+]] = felt.const 2
// CHECK-NEXT:        %[[VAL_1:[0-9a-zA-Z_\.]+]] = struct.new : <@Main>
// CHECK-NEXT:        %[[VAL_2:[0-9a-zA-Z_\.]+]] = array.new %[[VAL_0]], %[[VAL_0]], %[[VAL_0]], %[[VAL_0]] : <4 x !felt.type>
// CHECK-NEXT:        struct.writef %[[VAL_1]][@"f2:!s<@Component4C>+f:!s<@Component4A>+f"] = %[[VAL_2]] : <@Main>, !array.type<4 x !felt.type>
// CHECK-NEXT:        %[[VAL_3:[0-9a-zA-Z_\.]+]] = felt.const 3
// CHECK-NEXT:        %[[VAL_4:[0-9a-zA-Z_\.]+]] = felt.const 4
// CHECK-NEXT:        %[[VAL_5:[0-9a-zA-Z_\.]+]] = felt.const 5
// CHECK-NEXT:        %[[VAL_6:[0-9a-zA-Z_\.]+]] = felt.const 6
// CHECK-NEXT:        %[[VAL_7:[0-9a-zA-Z_\.]+]] = array.new %[[VAL_3]], %[[VAL_4]], %[[VAL_5]], %[[VAL_6]] : <4 x !felt.type>
// CHECK-NEXT:        struct.writef %[[VAL_1]][@"f1:!s<@Component4B>+f:!s<@Component4A>+f"] = %[[VAL_7]] : <@Main>, !array.type<4 x !felt.type>
// CHECK-NEXT:        function.return %[[VAL_1]] : !struct.type<@Main>
// CHECK-NEXT:      }
// CHECK-NEXT:      function.def @constrain(%[[VAL_8:[0-9a-zA-Z_\.]+]]: !struct.type<@Main>) attributes {function.allow_constraint} {
// CHECK-NEXT:        %[[VAL_9:[0-9a-zA-Z_\.]+]] = felt.const 2
// CHECK-NEXT:        %[[VAL_10:[0-9a-zA-Z_\.]+]] = felt.const 3
// CHECK-NEXT:        %[[VAL_11:[0-9a-zA-Z_\.]+]] = felt.const 4
// CHECK-NEXT:        %[[VAL_12:[0-9a-zA-Z_\.]+]] = felt.const 5
// CHECK-NEXT:        %[[VAL_13:[0-9a-zA-Z_\.]+]] = felt.const 6
// CHECK-NEXT:        %[[VAL_14:[0-9a-zA-Z_\.]+]] = struct.readf %[[VAL_8]][@"f1:!s<@Component4B>+f:!s<@Component4A>+f"] : <@Main>, !array.type<4 x !felt.type>
// CHECK-NEXT:        %[[VAL_15:[0-9a-zA-Z_\.]+]] = array.new %[[VAL_10]], %[[VAL_11]], %[[VAL_12]], %[[VAL_13]] : <4 x !felt.type>
// CHECK-NEXT:        constrain.eq %[[VAL_14]], %[[VAL_15]] : !array.type<4 x !felt.type>, !array.type<4 x !felt.type>
// CHECK-NEXT:        %[[VAL_16:[0-9a-zA-Z_\.]+]] = struct.readf %[[VAL_8]][@"f2:!s<@Component4C>+f:!s<@Component4A>+f"] : <@Main>, !array.type<4 x !felt.type>
// CHECK-NEXT:        %[[VAL_17:[0-9a-zA-Z_\.]+]] = array.new %[[VAL_9]], %[[VAL_9]], %[[VAL_9]], %[[VAL_9]] : <4 x !felt.type>
// CHECK-NEXT:        constrain.eq %[[VAL_16]], %[[VAL_17]] : !array.type<4 x !felt.type>, !array.type<4 x !felt.type>
// CHECK-NEXT:        function.return
// CHECK-NEXT:      }
// CHECK-NEXT:    }
// -----

// TESTS: no main struct
module attributes {veridise.lang = "llzk"} {
  struct.def @Component5A {
    struct.field @f1 : !felt.type
    struct.field @f2 : !felt.type

    function.def @compute(%z: !felt.type) -> !struct.type<@Component5A> {
      %self = struct.new : !struct.type<@Component5A>
      struct.writef %self[@f1] = %z : !struct.type<@Component5A>, !felt.type
      struct.writef %self[@f2] = %z : !struct.type<@Component5A>, !felt.type
      function.return %self : !struct.type<@Component5A>
    }

    function.def @constrain(%self: !struct.type<@Component5A>, %z: !felt.type) {
      %a = struct.readf %self[@f1] : !struct.type<@Component5A>, !felt.type
      constrain.eq %a, %z : !felt.type
      %b = struct.readf %self[@f2] : !struct.type<@Component5A>, !felt.type
      constrain.eq %b, %z : !felt.type
      function.return
    }
  }

  struct.def @Component5B {
    struct.field @f2 : !struct.type<@Component5A>

    function.def @compute(%z: !felt.type) -> !struct.type<@Component5B> {
      %self = struct.new : !struct.type<@Component5B>
      %q = function.call @Component5A::@compute(%z) : (!felt.type) -> !struct.type<@Component5A>
      struct.writef %self[@f2] = %q : !struct.type<@Component5B>, !struct.type<@Component5A>
      function.return %self : !struct.type<@Component5B>
    }

    function.def @constrain(%self: !struct.type<@Component5B>, %z: !felt.type) {
      %q = struct.readf %self[@f2] : !struct.type<@Component5B>, !struct.type<@Component5A>
      function.call @Component5A::@constrain(%q, %z) : (!struct.type<@Component5A>,!felt.type) -> ()
      function.return
    }
  }
}
// CHECK-LABEL:   struct.def @Component5B {
// CHECK-NEXT:      struct.field @"f2:!s<@Component5A>+f1" : !felt.type
// CHECK-NEXT:      struct.field @"f2:!s<@Component5A>+f2" : !felt.type
// CHECK-NEXT:      function.def @compute(%[[VAL_0:[0-9a-zA-Z_\.]+]]: !felt.type) -> !struct.type<@Component5B> attributes {function.allow_witness} {
// CHECK-NEXT:        %[[VAL_1:[0-9a-zA-Z_\.]+]] = struct.new : <@Component5B>
// CHECK-NEXT:        struct.writef %[[VAL_1]][@"f2:!s<@Component5A>+f1"] = %[[VAL_0]] : <@Component5B>, !felt.type
// CHECK-NEXT:        struct.writef %[[VAL_1]][@"f2:!s<@Component5A>+f2"] = %[[VAL_0]] : <@Component5B>, !felt.type
// CHECK-NEXT:        function.return %[[VAL_1]] : !struct.type<@Component5B>
// CHECK-NEXT:      }
// CHECK-NEXT:      function.def @constrain(%[[VAL_2:[0-9a-zA-Z_\.]+]]: !struct.type<@Component5B>, %[[VAL_3:[0-9a-zA-Z_\.]+]]: !felt.type) attributes {function.allow_constraint} {
// CHECK-NEXT:        %[[VAL_4:[0-9a-zA-Z_\.]+]] = struct.readf %[[VAL_2]][@"f2:!s<@Component5A>+f1"] : <@Component5B>, !felt.type
// CHECK-NEXT:        constrain.eq %[[VAL_4]], %[[VAL_3]] : !felt.type, !felt.type
// CHECK-NEXT:        %[[VAL_5:[0-9a-zA-Z_\.]+]] = struct.readf %[[VAL_2]][@"f2:!s<@Component5A>+f2"] : <@Component5B>, !felt.type
// CHECK-NEXT:        constrain.eq %[[VAL_5]], %[[VAL_3]] : !felt.type, !felt.type
// CHECK-NEXT:        function.return
// CHECK-NEXT:      }
// CHECK-NEXT:    }
// -----

// TESTS: Call to "constrain" but not "compute"
module attributes {veridise.lang = "llzk"} {
  struct.def @Component6A {
    struct.field @f1 : !felt.type
    struct.field @f2 : !felt.type

    function.def @compute(%z: !felt.type) -> !struct.type<@Component6A> {
      %self = struct.new : !struct.type<@Component6A>
      struct.writef %self[@f1] = %z : !struct.type<@Component6A>, !felt.type
      struct.writef %self[@f2] = %z : !struct.type<@Component6A>, !felt.type
      function.return %self : !struct.type<@Component6A>
    }

    function.def @constrain(%self: !struct.type<@Component6A>, %z: !felt.type) {
      %a = struct.readf %self[@f1] : !struct.type<@Component6A>, !felt.type
      constrain.eq %a, %z : !felt.type
      %b = struct.readf %self[@f2] : !struct.type<@Component6A>, !felt.type
      constrain.eq %b, %z : !felt.type
      function.return
    }
  }

  struct.def @Main {
    struct.field @f2 : !struct.type<@Component6A>

    function.def @compute() -> !struct.type<@Main> {
      %2 = felt.const 2
      %self = struct.new : !struct.type<@Main>
      function.return %self : !struct.type<@Main>
    }

    function.def @constrain(%self: !struct.type<@Main>) {
      %2 = felt.const 2
      %q = struct.readf %self[@f2] : !struct.type<@Main>, !struct.type<@Component6A>
      function.call @Component6A::@constrain(%q, %2) : (!struct.type<@Component6A>,!felt.type) -> ()
      function.return
    }
  }
}
// CHECK-LABEL:   struct.def @Main {
// CHECK-NEXT:      struct.field @"f2:!s<@Component6A>+f1" : !felt.type
// CHECK-NEXT:      struct.field @"f2:!s<@Component6A>+f2" : !felt.type
// CHECK-NEXT:      function.def @compute() -> !struct.type<@Main> attributes {function.allow_witness} {
// CHECK-NEXT:        %[[VAL_0:[0-9a-zA-Z_\.]+]] = struct.new : <@Main>
// CHECK-NEXT:        function.return %[[VAL_0]] : !struct.type<@Main>
// CHECK-NEXT:      }
// CHECK-NEXT:      function.def @constrain(%[[VAL_1:[0-9a-zA-Z_\.]+]]: !struct.type<@Main>) attributes {function.allow_constraint} {
// CHECK-NEXT:        %[[VAL_2:[0-9a-zA-Z_\.]+]] = felt.const 2
// CHECK-NEXT:        %[[VAL_3:[0-9a-zA-Z_\.]+]] = struct.readf %[[VAL_1]][@"f2:!s<@Component6A>+f1"] : <@Main>, !felt.type
// CHECK-NEXT:        constrain.eq %[[VAL_3]], %[[VAL_2]] : !felt.type, !felt.type
// CHECK-NEXT:        %[[VAL_4:[0-9a-zA-Z_\.]+]] = struct.readf %[[VAL_1]][@"f2:!s<@Component6A>+f2"] : <@Main>, !felt.type
// CHECK-NEXT:        constrain.eq %[[VAL_4]], %[[VAL_2]] : !felt.type, !felt.type
// CHECK-NEXT:        function.return
// CHECK-NEXT:      }
// CHECK-NEXT:    }
// -----

// TESTS: Call to "compute" but not "constrain"
// Inlining does not occur since it's based on "constrain" calls.
module attributes {veridise.lang = "llzk"} {
  struct.def @Component7A {
    struct.field @f1 : !felt.type
    struct.field @f2 : !felt.type

    function.def @compute(%z: !felt.type) -> !struct.type<@Component7A> {
      %self = struct.new : !struct.type<@Component7A>
      struct.writef %self[@f1] = %z : !struct.type<@Component7A>, !felt.type
      struct.writef %self[@f2] = %z : !struct.type<@Component7A>, !felt.type
      function.return %self : !struct.type<@Component7A>
    }

    function.def @constrain(%self: !struct.type<@Component7A>, %z: !felt.type) {
      %a = struct.readf %self[@f1] : !struct.type<@Component7A>, !felt.type
      constrain.eq %a, %z : !felt.type
      %b = struct.readf %self[@f2] : !struct.type<@Component7A>, !felt.type
      constrain.eq %b, %z : !felt.type
      function.return
    }
  }

  struct.def @Main {
    struct.field @f2 : !struct.type<@Component7A>

    function.def @compute() -> !struct.type<@Main> {
      %2 = felt.const 2
      %self = struct.new : !struct.type<@Main>
      %q = function.call @Component7A::@compute(%2) : (!felt.type) -> !struct.type<@Component7A>
      struct.writef %self[@f2] = %q : !struct.type<@Main>, !struct.type<@Component7A>
      function.return %self : !struct.type<@Main>
    }

    function.def @constrain(%self: !struct.type<@Main>) {
      %q = struct.readf %self[@f2] : !struct.type<@Main>, !struct.type<@Component7A>
      function.return
    }
  }
}
// CHECK-LABEL:   struct.def @Component7A {
// CHECK-NEXT:      struct.field @f1 : !felt.type
// CHECK-NEXT:      struct.field @f2 : !felt.type
// CHECK-NEXT:      function.def @compute(%[[VAL_0:[0-9a-zA-Z_\.]+]]: !felt.type) -> !struct.type<@Component7A> attributes {function.allow_witness} {
// CHECK-NEXT:        %[[VAL_1:[0-9a-zA-Z_\.]+]] = struct.new : <@Component7A>
// CHECK-NEXT:        struct.writef %[[VAL_1]][@f1] = %[[VAL_0]] : <@Component7A>, !felt.type
// CHECK-NEXT:        struct.writef %[[VAL_1]][@f2] = %[[VAL_0]] : <@Component7A>, !felt.type
// CHECK-NEXT:        function.return %[[VAL_1]] : !struct.type<@Component7A>
// CHECK-NEXT:      }
// CHECK-NEXT:      function.def @constrain(%[[VAL_2:[0-9a-zA-Z_\.]+]]: !struct.type<@Component7A>, %[[VAL_3:[0-9a-zA-Z_\.]+]]: !felt.type) attributes {function.allow_constraint} {
// CHECK-NEXT:        %[[VAL_4:[0-9a-zA-Z_\.]+]] = struct.readf %[[VAL_2]][@f1] : <@Component7A>, !felt.type
// CHECK-NEXT:        constrain.eq %[[VAL_4]], %[[VAL_3]] : !felt.type, !felt.type
// CHECK-NEXT:        %[[VAL_5:[0-9a-zA-Z_\.]+]] = struct.readf %[[VAL_2]][@f2] : <@Component7A>, !felt.type
// CHECK-NEXT:        constrain.eq %[[VAL_5]], %[[VAL_3]] : !felt.type, !felt.type
// CHECK-NEXT:        function.return
// CHECK-NEXT:      }
// CHECK-NEXT:    }
//
// CHECK-LABEL:   struct.def @Main {
// CHECK-NEXT:      struct.field @f2 : !struct.type<@Component7A>
// CHECK-NEXT:      function.def @compute() -> !struct.type<@Main> attributes {function.allow_witness} {
// CHECK-NEXT:        %[[VAL_0:[0-9a-zA-Z_\.]+]] = felt.const 2
// CHECK-NEXT:        %[[VAL_1:[0-9a-zA-Z_\.]+]] = struct.new : <@Main>
// CHECK-NEXT:        %[[VAL_2:[0-9a-zA-Z_\.]+]] = function.call @Component7A::@compute(%[[VAL_0]]) : (!felt.type) -> !struct.type<@Component7A>
// CHECK-NEXT:        struct.writef %[[VAL_1]][@f2] = %[[VAL_2]] : <@Main>, !struct.type<@Component7A>
// CHECK-NEXT:        function.return %[[VAL_1]] : !struct.type<@Main>
// CHECK-NEXT:      }
// CHECK-NEXT:      function.def @constrain(%[[VAL_3:[0-9a-zA-Z_\.]+]]: !struct.type<@Main>) attributes {function.allow_constraint} {
// CHECK-NEXT:        %[[VAL_4:[0-9a-zA-Z_\.]+]] = struct.readf %[[VAL_3]][@f2] : <@Main>, !struct.type<@Component7A>
// CHECK-NEXT:        function.return
// CHECK-NEXT:      }
// CHECK-NEXT:    }
// -----

// TESTS: Neither "compute" nor "constrain" is called
// Inlining does not occur since it's based on "constrain" calls.
module attributes {veridise.lang = "llzk"} {
  struct.def @Component8A {
    struct.field @f1 : !felt.type
    struct.field @f2 : !felt.type

    function.def @compute(%z: !felt.type) -> !struct.type<@Component8A> {
      %self = struct.new : !struct.type<@Component8A>
      struct.writef %self[@f1] = %z : !struct.type<@Component8A>, !felt.type
      struct.writef %self[@f2] = %z : !struct.type<@Component8A>, !felt.type
      function.return %self : !struct.type<@Component8A>
    }

    function.def @constrain(%self: !struct.type<@Component8A>, %z: !felt.type) {
      %a = struct.readf %self[@f1] : !struct.type<@Component8A>, !felt.type
      constrain.eq %a, %z : !felt.type
      %b = struct.readf %self[@f2] : !struct.type<@Component8A>, !felt.type
      constrain.eq %b, %z : !felt.type
      function.return
    }
  }

  struct.def @Main {
    struct.field @f2 : !struct.type<@Component8A>

    function.def @compute() -> !struct.type<@Main> {
      %self = struct.new : !struct.type<@Main>
      function.return %self : !struct.type<@Main>
    }

    function.def @constrain(%self: !struct.type<@Main>) {
      %q = struct.readf %self[@f2] : !struct.type<@Main>, !struct.type<@Component8A>
      function.return
    }
  }
}
// CHECK-LABEL:   struct.def @Component8A {
// CHECK-NEXT:      struct.field @f1 : !felt.type
// CHECK-NEXT:      struct.field @f2 : !felt.type
// CHECK-NEXT:      function.def @compute(%[[VAL_0:[0-9a-zA-Z_\.]+]]: !felt.type) -> !struct.type<@Component8A> attributes {function.allow_witness} {
// CHECK-NEXT:        %[[VAL_1:[0-9a-zA-Z_\.]+]] = struct.new : <@Component8A>
// CHECK-NEXT:        struct.writef %[[VAL_1]][@f1] = %[[VAL_0]] : <@Component8A>, !felt.type
// CHECK-NEXT:        struct.writef %[[VAL_1]][@f2] = %[[VAL_0]] : <@Component8A>, !felt.type
// CHECK-NEXT:        function.return %[[VAL_1]] : !struct.type<@Component8A>
// CHECK-NEXT:      }
// CHECK-NEXT:      function.def @constrain(%[[VAL_2:[0-9a-zA-Z_\.]+]]: !struct.type<@Component8A>, %[[VAL_3:[0-9a-zA-Z_\.]+]]: !felt.type) attributes {function.allow_constraint} {
// CHECK-NEXT:        %[[VAL_4:[0-9a-zA-Z_\.]+]] = struct.readf %[[VAL_2]][@f1] : <@Component8A>, !felt.type
// CHECK-NEXT:        constrain.eq %[[VAL_4]], %[[VAL_3]] : !felt.type, !felt.type
// CHECK-NEXT:        %[[VAL_5:[0-9a-zA-Z_\.]+]] = struct.readf %[[VAL_2]][@f2] : <@Component8A>, !felt.type
// CHECK-NEXT:        constrain.eq %[[VAL_5]], %[[VAL_3]] : !felt.type, !felt.type
// CHECK-NEXT:        function.return
// CHECK-NEXT:      }
// CHECK-NEXT:    }
//
// CHECK-LABEL:   struct.def @Main {
// CHECK-NEXT:      struct.field @f2 : !struct.type<@Component8A>
// CHECK-NEXT:      function.def @compute() -> !struct.type<@Main> attributes {function.allow_witness} {
// CHECK-NEXT:        %[[VAL_0:[0-9a-zA-Z_\.]+]] = struct.new : <@Main>
// CHECK-NEXT:        function.return %[[VAL_0]] : !struct.type<@Main>
// CHECK-NEXT:      }
// CHECK-NEXT:      function.def @constrain(%[[VAL_1:[0-9a-zA-Z_\.]+]]: !struct.type<@Main>) attributes {function.allow_constraint} {
// CHECK-NEXT:        %[[VAL_2:[0-9a-zA-Z_\.]+]] = struct.readf %[[VAL_1]][@f2] : <@Main>, !struct.type<@Component8A>
// CHECK-NEXT:        function.return
// CHECK-NEXT:      }
// CHECK-NEXT:    }
// -----

// TESTS: Result of a field read has use(s) other than parameter to constrain function.
module attributes {veridise.lang = "llzk"} {
  struct.def @Component9A {
    struct.field @f : !felt.type

    function.def @compute() -> !struct.type<@Component9A> {
      %self = struct.new : !struct.type<@Component9A>
      %12 = felt.const 12
      struct.writef %self[@f] = %12 : !struct.type<@Component9A>, !felt.type
      function.return %self : !struct.type<@Component9A>
    }

    function.def @constrain(%self: !struct.type<@Component9A>) {
      function.return
    }
  }

  struct.def @Main {
    struct.field @fa : !struct.type<@Component9A>

    function.def @compute() -> !struct.type<@Main> {
      %self = struct.new : !struct.type<@Main>
      %a = function.call @Component9A::@compute() : () -> !struct.type<@Component9A>
      struct.writef %self[@fa] = %a : !struct.type<@Main>, !struct.type<@Component9A>
      function.return %self : !struct.type<@Main>
    }

    function.def @constrain(%self: !struct.type<@Main>) {
      %a = struct.readf %self[@fa] : !struct.type<@Main>, !struct.type<@Component9A>
      function.call @Component9A::@constrain(%a) : (!struct.type<@Component9A>) -> ()
      %b = struct.readf %a[@f] : !struct.type<@Component9A>, !felt.type
      %12 = felt.const 12
      constrain.eq %12, %b : !felt.type
      function.return
    }
  }
}
// CHECK-LABEL:   struct.def @Main {
// CHECK-NEXT:      struct.field @"fa:!s<@Component9A>+f" : !felt.type
// CHECK-NEXT:      function.def @compute() -> !struct.type<@Main> attributes {function.allow_witness} {
// CHECK-NEXT:        %[[V0:[0-9a-zA-Z_\.]+]] = struct.new : <@Main>
// CHECK-NEXT:        %[[V1:[0-9a-zA-Z_\.]+]] = felt.const  12
// CHECK-NEXT:        struct.writef %[[V0]][@"fa:!s<@Component9A>+f"] = %[[V1]] : <@Main>, !felt.type
// CHECK-NEXT:        function.return %[[V0]] : !struct.type<@Main>
// CHECK-NEXT:      }
// CHECK-NEXT:      function.def @constrain(%[[V2:[0-9a-zA-Z_\.]+]]: !struct.type<@Main>) attributes {function.allow_constraint} {
// CHECK-NEXT:        %[[V3:[0-9a-zA-Z_\.]+]] = felt.const  12
// CHECK-NEXT:        %[[V4:[0-9a-zA-Z_\.]+]] = struct.readf %[[V2]][@"fa:!s<@Component9A>+f"] : <@Main>, !felt.type
// CHECK-NEXT:        constrain.eq %[[V4]], %[[V3]] : !felt.type, !felt.type
// CHECK-NEXT:        function.return
// CHECK-NEXT:      }
// CHECK-NEXT:    }


// // TESTS: Passing struct as parameter
// module attributes {veridise.lang = "llzk"} {
//   struct.def @Component9A {
//     struct.field @f : !felt.type
//
//     function.def @compute() -> !struct.type<@Component9A> {
//       %self = struct.new : !struct.type<@Component9A>
//       %12 = felt.const 12
//       struct.writef %self[@f] = %12 : !struct.type<@Component9A>, !felt.type
//       function.return %self : !struct.type<@Component9A>
//     }
//
//     function.def @constrain(%self: !struct.type<@Component9A>) {
//       %12 = felt.const 12
//       %c = struct.readf %self[@f] : !struct.type<@Component9A>, !felt.type
//       constrain.eq %12, %c : !felt.type
//       function.return
//     }
//   }
//
//   struct.def @Component9B {
//     struct.field @f : !felt.type
//
//     function.def @compute(%a: !struct.type<@Component9A>) -> !struct.type<@Component9B> {
//       %self = struct.new : !struct.type<@Component9B>
//       %r = struct.readf %a[@f] : !struct.type<@Component9A>, !felt.type
//       %m = felt.mul %r, %r
//       struct.writef %self[@f] = %m : !struct.type<@Component9B>, !felt.type
//       function.return %self : !struct.type<@Component9B>
//     }
//
//     function.def @constrain(%self: !struct.type<@Component9B>, %a: !struct.type<@Component9A>) {
//       %r = struct.readf %a[@f] : !struct.type<@Component9A>, !felt.type
//       %m = felt.mul %r, %r
//       %m2 = struct.readf %self[@f]: !struct.type<@Component9B>, !felt.type
//       constrain.eq %m, %m2 : !felt.type
//       function.return
//     }
//   }
//
//   struct.def @Main {
//     struct.field @fa : !struct.type<@Component9A>
//     struct.field @fb : !struct.type<@Component9B>
//
//     function.def @compute() -> !struct.type<@Main> {
//       %self = struct.new : !struct.type<@Main>
//       %a = function.call @Component9A::@compute() : () -> !struct.type<@Component9A>
//       struct.writef %self[@fa] = %a : !struct.type<@Main>, !struct.type<@Component9A>
//       %b = function.call @Component9B::@compute(%a) : (!struct.type<@Component9A>) -> !struct.type<@Component9B>
//       struct.writef %self[@fb] = %b : !struct.type<@Main>, !struct.type<@Component9B>
//       function.return %self : !struct.type<@Main>
//     }
//
//     function.def @constrain(%self: !struct.type<@Main>) {
//       %a = struct.readf %self[@fa] : !struct.type<@Main>, !struct.type<@Component9A>
//       function.call @Component9A::@constrain(%a) : (!struct.type<@Component9A>) -> ()
//       %b = struct.readf %self[@fb] : !struct.type<@Main>, !struct.type<@Component9B>
//       function.call @Component9B::@constrain(%b, %a) : (!struct.type<@Component9B>,!struct.type<@Component9A>) -> ()
//       function.return
//     }
//   }
// }
// TODO: CHECK
// TODO: ADD SPLIT
//
// // TESTS: result of call to "@compute" used as param to a free function
// // The param must be split and fields of the component passed individually.
// module attributes {veridise.lang = "llzk"} {
//   function.def private @temp(%0: !struct.type<@Component10A>)
//
//   struct.def @Component10A {
//     struct.field @f1 : !felt.type
//     struct.field @f2 : !felt.type
//
//     function.def @compute(%z: !felt.type) -> !struct.type<@Component10A> {
//       %self = struct.new : !struct.type<@Component10A>
//       struct.writef %self[@f1] = %z : !struct.type<@Component10A>, !felt.type
//       struct.writef %self[@f2] = %z : !struct.type<@Component10A>, !felt.type
//       function.return %self : !struct.type<@Component10A>
//     }
//
//     function.def @constrain(%self: !struct.type<@Component10A>, %z: !felt.type) {
//       %a = struct.readf %self[@f1] : !struct.type<@Component10A>, !felt.type
//       constrain.eq %a, %z : !felt.type
//       %b = struct.readf %self[@f2] : !struct.type<@Component10A>, !felt.type
//       constrain.eq %b, %z : !felt.type
//       function.return
//     }
//   }
//
//   struct.def @Main {
//     struct.field @f2 : !struct.type<@Component10A>
//
//     function.def @compute() -> !struct.type<@Main> {
//       %self = struct.new : !struct.type<@Main>
//       %z = felt.const 42
//       %q = function.call @Component10A::@compute(%z) : (!felt.type) -> !struct.type<@Component10A>
//       struct.writef %self[@f2] = %q : !struct.type<@Main>, !struct.type<@Component10A>
//       function.call @temp(%q) : (!struct.type<@Component10A>) -> ()
//       function.return %self : !struct.type<@Main>
//     }
//
//     function.def @constrain(%self: !struct.type<@Main>) {
//       %z = felt.const 42
//       %q = struct.readf %self[@f2] : !struct.type<@Main>, !struct.type<@Component10A>
//       function.call @Component10A::@constrain(%q, %z) : (!struct.type<@Component10A>,!felt.type) -> ()
//       function.return
//     }
//   }
// }
// TODO: CHECK
// TODO: ADD SPLIT
//
// // TESTS: The result of calling "compute" is stored to more than one field.
// // This case has no realistic use case so maybe just assert in the compute handler.
// module attributes {veridise.lang = "llzk"} {
//   struct.def @Component11A {
//     struct.field @f : !felt.type
//
//     function.def @compute(%z: !felt.type) -> !struct.type<@Component11A> {
//       %self = struct.new : !struct.type<@Component11A>
//       struct.writef %self[@f] = %z : !struct.type<@Component11A>, !felt.type
//       function.return %self : !struct.type<@Component11A>
//     }
//
//     function.def @constrain(%self: !struct.type<@Component11A>, %z: !felt.type) {
//       %a = struct.readf %self[@f] : !struct.type<@Component11A>, !felt.type
//       constrain.eq %a, %z : !felt.type
//       function.return
//     }
//   }
//
//   struct.def @Main {
//     struct.field @f1 : !struct.type<@Component11A>
//     struct.field @f2 : !struct.type<@Component11A>
//
//     function.def @compute() -> !struct.type<@Main> {
//       %self = struct.new : !struct.type<@Main>
//       %z = felt.const 42
//       %q = function.call @Component11A::@compute(%z) : (!felt.type) -> !struct.type<@Component11A>
//       struct.writef %self[@f1] = %q : !struct.type<@Main>, !struct.type<@Component11A>
//       struct.writef %self[@f2] = %q : !struct.type<@Main>, !struct.type<@Component11A>
//       function.return %self : !struct.type<@Main>
//     }
//
//     function.def @constrain(%self: !struct.type<@Main>) {
//       %z = felt.const 42
//       %p = struct.readf %self[@f1] : !struct.type<@Main>, !struct.type<@Component11A>
//       function.call @Component11A::@constrain(%p, %z) : (!struct.type<@Component11A>,!felt.type) -> ()
//       %q = struct.readf %self[@f2] : !struct.type<@Main>, !struct.type<@Component11A>
//       function.call @Component11A::@constrain(%q, %z) : (!struct.type<@Component11A>,!felt.type) -> ()
//       function.return
//     }
//   }
// }
// TODO: CHECK
// TODO: ADD SPLIT
//
// // TESTS:  The @Signal struct must NOT be inlined
// !Signal = !struct.type<@Signal>
// module attributes {veridise.lang = "llzk"} {
//   // pre-defined
//   struct.def @Signal {
//     struct.field @reg : !felt.type {llzk.pub}

//     function.def @compute(%v: !felt.type) -> !struct.type<@Signal> {
//       %self = struct.new : !struct.type<@Signal>
//       struct.writef %self[@reg] = %v : !struct.type<@Signal>, !felt.type
//       function.return %self : !struct.type<@Signal>
//     }

//     function.def @constrain(%self: !struct.type<@Signal>, %v: !felt.type) {
//       function.return
//     }
//   }

//   struct.def @Component12 {
//     struct.field @f : !Signal

//     function.def @compute(%0: !Signal) -> !struct.type<@Component12> {
//       %self = struct.new : !struct.type<@Component12>
//       struct.writef %self[@f] = %0 : !struct.type<@Component12>, !Signal
//       function.return %self : !struct.type<@Component12>
//     }
//     function.def @constrain(%self: !struct.type<@Component12>, %0: !Signal) {
//       %b = struct.readf %self[@f] : !struct.type<@Component12>, !Signal
//       constrain.eq %b, %0 : !Signal
//       function.return
//     }
//   }

//   struct.def @Main {
//     struct.field @f : !struct.type<@Component12>
  
//     function.def @compute(%0: !Signal) -> !struct.type<@Main> {
//       %self = struct.new : !struct.type<@Main>
//       %q = function.call @Component12::@compute(%0) : (!Signal) -> !struct.type<@Component12>
//       struct.writef %self[@f] = %q : !struct.type<@Main>, !struct.type<@Component12>
//       function.return %self : !struct.type<@Main>
//     }
  
//     function.def @constrain(%self: !struct.type<@Main>, %0: !Signal) {
//       %p = struct.readf %self[@f] : !struct.type<@Main>, !struct.type<@Component12>
//       function.call @Component12::@constrain(%p, %0) : (!struct.type<@Component12>,!Signal) -> ()
//       function.return
//     }
//   }
// }



// TODO: create tests for:
// - when inlining struct with parameters, must replace the parameters
