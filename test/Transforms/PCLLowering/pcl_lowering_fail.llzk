// RUN: llzk-opt -I %S -split-input-file -llzk-to-pcl -verify-diagnostics %s

!F = !felt.type
module attributes {veridise.lang = "llzk"} {
  // Order the structs so that the field ref is converted before the field itself
  struct.def @ComponentA2 {
    function.def @compute(%p: !struct.type<@ComponentA1>) -> !struct.type<@ComponentA2> {
      %self = struct.new : !struct.type<@ComponentA2>
      %r = struct.readf %p[@f1] : !struct.type<@ComponentA1>, !array.type<4,3 x !F>
      function.return %self : !struct.type<@ComponentA2>
    }

    // expected-error@+1 {{arg is expected to be a felt}}
    function.def @constrain(%self: !struct.type<@ComponentA2>, %p: !struct.type<@ComponentA1>) {
      function.return
    }
  }

  struct.def @ComponentA1 {
    struct.field @f1 : !array.type<4,3 x !F>

    function.def @constrain(%self: !struct.type<@ComponentA1>) { function.return }
    function.def @compute() -> !struct.type<@ComponentA1> {
      %self = struct.new : !struct.type<@ComponentA1>
      function.return %self : !struct.type<@ComponentA1>
    }
  }
}

// -----

!F = !felt.type
module attributes {veridise.lang = "llzk"} {
  struct.def @ComponentA1 {
    // expected-error@+1 {{Field must be felt type. Found '!array.type<4,3 x !felt.type>' for field: f1}}
    struct.field @f1 : !array.type<4,3 x !F>

    function.def @constrain(%self: !struct.type<@ComponentA1>) { function.return }
    function.def @compute() -> !struct.type<@ComponentA1> {
      %self = struct.new : !struct.type<@ComponentA1>
      function.return %self : !struct.type<@ComponentA1>
    }
  }
}