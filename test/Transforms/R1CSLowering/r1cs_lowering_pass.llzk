// RUN: llzk-opt -I %S -split-input-file -llzk-r1cs-lowering-pass -verify-diagnostics %s | FileCheck --enable-var-scope %s

module attributes {veridise.lang = "llzk"} {
  // lowers constraints to be at most degree 2 polynomials
  struct.def @CmpConstraint {
    function.def @compute(%a: !felt.type, %b: !felt.type, %c: !felt.type) -> !struct.type<@CmpConstraint> {
      %self = struct.new : !struct.type<@CmpConstraint>
      function.return %self : !struct.type<@CmpConstraint>
    }

    function.def @constrain(%self: !struct.type<@CmpConstraint>, %a: !felt.type, %b: !felt.type, %c: !felt.type) {
      %z = felt.mul %a, %b
      %0 = felt.mul %a, %c
      constrain.eq %0, %z : !felt.type
      function.return
    }
  }
}

// CHECK-LABEL:   struct.def @CmpConstraint {
// CHECK:           function.def @compute(%[[VAL_0:.*]]: !felt.type, %[[VAL_1:.*]]: !felt.type, %[[VAL_2:.*]]: !felt.type) -> !struct.type<@CmpConstraint> attributes {function.allow_witness} {
// CHECK:             %[[VAL_3:.*]] = struct.new : <@CmpConstraint>
// CHECK:             %[[VAL_4:.*]] = felt.mul %[[VAL_0]], %[[VAL_2]] : !felt.type, !felt.type
// CHECK:             struct.writef %[[VAL_3]][@__llzk_r1cs_lowering_pass_aux_field_0] = %[[VAL_4]] : <@CmpConstraint>, !felt.type
// CHECK:             function.return %[[VAL_3]] : !struct.type<@CmpConstraint>
// CHECK:           }
// CHECK:           function.def @constrain(%[[VAL_5:.*]]: !struct.type<@CmpConstraint>, %[[VAL_6:.*]]: !felt.type, %[[VAL_7:.*]]: !felt.type, %[[VAL_8:.*]]: !felt.type) attributes {function.allow_constraint} {
// CHECK:             %[[VAL_9:.*]] = felt.mul %[[VAL_6]], %[[VAL_7]] : !felt.type, !felt.type
// CHECK:             %[[VAL_10:.*]] = felt.mul %[[VAL_6]], %[[VAL_8]] : !felt.type, !felt.type
// CHECK:             %[[VAL_11:.*]] = struct.readf %[[VAL_5]][@__llzk_r1cs_lowering_pass_aux_field_0] : <@CmpConstraint>, !felt.type
// CHECK:             constrain.eq %[[VAL_11]], %[[VAL_10]] : !felt.type, !felt.type
// CHECK:             constrain.eq %[[VAL_11]], %[[VAL_9]] : !felt.type, !felt.type
// CHECK:             function.return
// CHECK:           }
// CHECK:           struct.field @__llzk_r1cs_lowering_pass_aux_field_0 : !felt.type
// CHECK:         }
// -----


module attributes {veridise.lang = "llzk"} {
  // lowers constraints to be at most degree 2 polynomials
  struct.def @CmpConstraint {
    struct.field @val: !felt.type
    function.def @compute(%a: !felt.type, %b: !felt.type, %c: !felt.type) -> !struct.type<@CmpConstraint> {
      %self = struct.new : !struct.type<@CmpConstraint>
      function.return %self : !struct.type<@CmpConstraint>
    }

    function.def @constrain(%self: !struct.type<@CmpConstraint>, %a: !felt.type, %b: !felt.type, %c: !felt.type) {
      %z = felt.mul %a, %b
      %0 = felt.mul %b, %c
      %1 = felt.add %0, %z
      %7 = struct.readf %self[@val] : !struct.type<@CmpConstraint>, !felt.type
      constrain.eq %1, %z : !felt.type
      %2 = felt.add %z, %b
      constrain.eq %7, %2 : !felt.type
      function.return
    }
  }
}

// CHECK-LABEL:   struct.def @CmpConstraint {
// CHECK:           struct.field @val : !felt.type
// CHECK:           function.def @compute(%[[VAL_0:.*]]: !felt.type, %[[VAL_1:.*]]: !felt.type, %[[VAL_2:.*]]: !felt.type) -> !struct.type<@CmpConstraint> attributes {function.allow_witness} {
// CHECK:             %[[VAL_3:.*]] = struct.new : <@CmpConstraint>
// CHECK:             %[[VAL_4:.*]] = felt.mul %[[VAL_1]], %[[VAL_2]] : !felt.type, !felt.type
// CHECK:             struct.writef %[[VAL_3]][@__llzk_r1cs_lowering_pass_aux_field_0] = %[[VAL_4]] : <@CmpConstraint>, !felt.type
// CHECK:             %[[VAL_5:.*]] = struct.readf %[[VAL_3]][@__llzk_r1cs_lowering_pass_aux_field_0] : <@CmpConstraint>, !felt.type
// CHECK:             %[[VAL_6:.*]] = felt.mul %[[VAL_0]], %[[VAL_1]] : !felt.type, !felt.type
// CHECK:             %[[VAL_7:.*]] = felt.add %[[VAL_5]], %[[VAL_6]] : !felt.type, !felt.type
// CHECK:             struct.writef %[[VAL_3]][@__llzk_r1cs_lowering_pass_aux_field_1] = %[[VAL_7]] : <@CmpConstraint>, !felt.type
// CHECK:             function.return %[[VAL_3]] : !struct.type<@CmpConstraint>
// CHECK:           }
// CHECK:           function.def @constrain(%[[VAL_8:.*]]: !struct.type<@CmpConstraint>, %[[VAL_9:.*]]: !felt.type, %[[VAL_10:.*]]: !felt.type, %[[VAL_11:.*]]: !felt.type) attributes {function.allow_constraint} {
// CHECK:             %[[VAL_12:.*]] = felt.mul %[[VAL_9]], %[[VAL_10]] : !felt.type, !felt.type
// CHECK:             %[[VAL_13:.*]] = felt.mul %[[VAL_10]], %[[VAL_11]] : !felt.type, !felt.type
// CHECK:             %[[VAL_14:.*]] = struct.readf %[[VAL_8]][@__llzk_r1cs_lowering_pass_aux_field_0] : <@CmpConstraint>, !felt.type
// CHECK:             constrain.eq %[[VAL_14]], %[[VAL_13]] : !felt.type, !felt.type
// CHECK:             %[[VAL_15:.*]] = felt.add %[[VAL_14]], %[[VAL_12]] : !felt.type, !felt.type
// CHECK:             %[[VAL_16:.*]] = struct.readf %[[VAL_8]][@val] : <@CmpConstraint>, !felt.type
// CHECK:             %[[VAL_17:.*]] = struct.readf %[[VAL_8]][@__llzk_r1cs_lowering_pass_aux_field_1] : <@CmpConstraint>, !felt.type
// CHECK:             constrain.eq %[[VAL_17]], %[[VAL_15]] : !felt.type, !felt.type
// CHECK:             constrain.eq %[[VAL_17]], %[[VAL_12]] : !felt.type, !felt.type
// CHECK:             %[[VAL_18:.*]] = felt.add %[[VAL_12]], %[[VAL_10]] : !felt.type, !felt.type
// CHECK:             constrain.eq %[[VAL_16]], %[[VAL_18]] : !felt.type, !felt.type
// CHECK:             function.return
// CHECK:           }
// CHECK:           struct.field @__llzk_r1cs_lowering_pass_aux_field_0 : !felt.type
// CHECK:           struct.field @__llzk_r1cs_lowering_pass_aux_field_1 : !felt.type
// CHECK:         }
// -----


module attributes {veridise.lang = "llzk"} {
  // lowers constraints to be at most degree 2 polynomials
  struct.def @CmpConstraint {
    struct.field @val: !felt.type
    function.def @compute(%a: !felt.type, %b: !felt.type, %c: !felt.type) -> !struct.type<@CmpConstraint> {
      %self = struct.new : !struct.type<@CmpConstraint>
      function.return %self : !struct.type<@CmpConstraint>
    }

    function.def @constrain(%self: !struct.type<@CmpConstraint>, %a: !felt.type, %b: !felt.type, %c: !felt.type) {
      %z = felt.mul %a, %b
      %0 = felt.mul %b, %c
      %1 = felt.add %0, %z
      %2 = felt.neg %1
      %7 = struct.readf %self[@val] : !struct.type<@CmpConstraint>, !felt.type
      constrain.eq %2, %z : !felt.type
      %3 = felt.add %z, %b
      constrain.eq %7, %3 : !felt.type
      function.return
    }
  }
}


// CHECK-LABEL:   struct.def @CmpConstraint {
// CHECK:           struct.field @val : !felt.type
// CHECK:           function.def @compute(%[[VAL_0:.*]]: !felt.type, %[[VAL_1:.*]]: !felt.type, %[[VAL_2:.*]]: !felt.type) -> !struct.type<@CmpConstraint> attributes {function.allow_witness} {
// CHECK:             %[[VAL_3:.*]] = struct.new : <@CmpConstraint>
// CHECK:             %[[VAL_4:.*]] = felt.mul %[[VAL_1]], %[[VAL_2]] : !felt.type, !felt.type
// CHECK:             struct.writef %[[VAL_3]][@__llzk_r1cs_lowering_pass_aux_field_0] = %[[VAL_4]] : <@CmpConstraint>, !felt.type
// CHECK:             %[[VAL_5:.*]] = struct.readf %[[VAL_3]][@__llzk_r1cs_lowering_pass_aux_field_0] : <@CmpConstraint>, !felt.type
// CHECK:             %[[VAL_6:.*]] = felt.mul %[[VAL_0]], %[[VAL_1]] : !felt.type, !felt.type
// CHECK:             %[[VAL_7:.*]] = felt.add %[[VAL_5]], %[[VAL_6]] : !felt.type, !felt.type
// CHECK:             %[[VAL_8:.*]] = felt.neg %[[VAL_7]] : !felt.type
// CHECK:             struct.writef %[[VAL_3]][@__llzk_r1cs_lowering_pass_aux_field_1] = %[[VAL_8]] : <@CmpConstraint>, !felt.type
// CHECK:             function.return %[[VAL_3]] : !struct.type<@CmpConstraint>
// CHECK:           }
// CHECK:           function.def @constrain(%[[VAL_9:.*]]: !struct.type<@CmpConstraint>, %[[VAL_10:.*]]: !felt.type, %[[VAL_11:.*]]: !felt.type, %[[VAL_12:.*]]: !felt.type) attributes {function.allow_constraint} {
// CHECK:             %[[VAL_13:.*]] = felt.mul %[[VAL_10]], %[[VAL_11]] : !felt.type, !felt.type
// CHECK:             %[[VAL_14:.*]] = felt.mul %[[VAL_11]], %[[VAL_12]] : !felt.type, !felt.type
// CHECK:             %[[VAL_15:.*]] = struct.readf %[[VAL_9]][@__llzk_r1cs_lowering_pass_aux_field_0] : <@CmpConstraint>, !felt.type
// CHECK:             constrain.eq %[[VAL_15]], %[[VAL_14]] : !felt.type, !felt.type
// CHECK:             %[[VAL_16:.*]] = felt.add %[[VAL_15]], %[[VAL_13]] : !felt.type, !felt.type
// CHECK:             %[[VAL_17:.*]] = felt.neg %[[VAL_16]] : !felt.type
// CHECK:             %[[VAL_18:.*]] = struct.readf %[[VAL_9]][@val] : <@CmpConstraint>, !felt.type
// CHECK:             %[[VAL_19:.*]] = struct.readf %[[VAL_9]][@__llzk_r1cs_lowering_pass_aux_field_1] : <@CmpConstraint>, !felt.type
// CHECK:             constrain.eq %[[VAL_19]], %[[VAL_17]] : !felt.type, !felt.type
// CHECK:             constrain.eq %[[VAL_19]], %[[VAL_13]] : !felt.type, !felt.type
// CHECK:             %[[VAL_20:.*]] = felt.add %[[VAL_13]], %[[VAL_11]] : !felt.type, !felt.type
// CHECK:             constrain.eq %[[VAL_18]], %[[VAL_20]] : !felt.type, !felt.type
// CHECK:             function.return
// CHECK:           }
// CHECK:           struct.field @__llzk_r1cs_lowering_pass_aux_field_0 : !felt.type
// CHECK:           struct.field @__llzk_r1cs_lowering_pass_aux_field_1 : !felt.type
// CHECK:         }
// -----

module attributes {veridise.lang = "llzk"} {
  // lowers constraints to be at most degree 2 polynomials
  struct.def @CmpConstraint {
    struct.field @val: !felt.type
    function.def @compute(%a: !felt.type, %b: !felt.type, %c: !felt.type) -> !struct.type<@CmpConstraint> {
      %self = struct.new : !struct.type<@CmpConstraint>
      function.return %self : !struct.type<@CmpConstraint>
    }

    function.def @constrain(%self: !struct.type<@CmpConstraint>, %a: !felt.type, %b: !felt.type, %c: !felt.type) {
      %z = felt.mul %a, %b
      %0 = felt.mul %b, %c
      %1 = felt.sub %0, %z
      %2 = felt.neg %1
      %7 = struct.readf %self[@val] : !struct.type<@CmpConstraint>, !felt.type
      constrain.eq %2, %z : !felt.type
      %3 = felt.sub %z, %b
      constrain.eq %7, %3 : !felt.type
      function.return
    }
  }
}

// CHECK-LABEL:   struct.def @CmpConstraint {
// CHECK:           struct.field @val : !felt.type
// CHECK:           function.def @compute(%[[VAL_0:.*]]: !felt.type, %[[VAL_1:.*]]: !felt.type, %[[VAL_2:.*]]: !felt.type) -> !struct.type<@CmpConstraint> attributes {function.allow_witness} {
// CHECK:             %[[VAL_3:.*]] = struct.new : <@CmpConstraint>
// CHECK:             %[[VAL_4:.*]] = felt.mul %[[VAL_1]], %[[VAL_2]] : !felt.type, !felt.type
// CHECK:             struct.writef %[[VAL_3]][@__llzk_r1cs_lowering_pass_aux_field_0] = %[[VAL_4]] : <@CmpConstraint>, !felt.type
// CHECK:             %[[VAL_5:.*]] = struct.readf %[[VAL_3]][@__llzk_r1cs_lowering_pass_aux_field_0] : <@CmpConstraint>, !felt.type
// CHECK:             %[[VAL_6:.*]] = felt.mul %[[VAL_0]], %[[VAL_1]] : !felt.type, !felt.type
// CHECK:             %[[VAL_7:.*]] = felt.sub %[[VAL_5]], %[[VAL_6]] : !felt.type, !felt.type
// CHECK:             %[[VAL_8:.*]] = felt.neg %[[VAL_7]] : !felt.type
// CHECK:             struct.writef %[[VAL_3]][@__llzk_r1cs_lowering_pass_aux_field_1] = %[[VAL_8]] : <@CmpConstraint>, !felt.type
// CHECK:             function.return %[[VAL_3]] : !struct.type<@CmpConstraint>
// CHECK:           }
// CHECK:           function.def @constrain(%[[VAL_9:.*]]: !struct.type<@CmpConstraint>, %[[VAL_10:.*]]: !felt.type, %[[VAL_11:.*]]: !felt.type, %[[VAL_12:.*]]: !felt.type) attributes {function.allow_constraint} {
// CHECK:             %[[VAL_13:.*]] = felt.mul %[[VAL_10]], %[[VAL_11]] : !felt.type, !felt.type
// CHECK:             %[[VAL_14:.*]] = felt.mul %[[VAL_11]], %[[VAL_12]] : !felt.type, !felt.type
// CHECK:             %[[VAL_15:.*]] = struct.readf %[[VAL_9]][@__llzk_r1cs_lowering_pass_aux_field_0] : <@CmpConstraint>, !felt.type
// CHECK:             constrain.eq %[[VAL_15]], %[[VAL_14]] : !felt.type, !felt.type
// CHECK:             %[[VAL_16:.*]] = felt.sub %[[VAL_15]], %[[VAL_13]] : !felt.type, !felt.type
// CHECK:             %[[VAL_17:.*]] = felt.neg %[[VAL_16]] : !felt.type
// CHECK:             %[[VAL_18:.*]] = struct.readf %[[VAL_9]][@val] : <@CmpConstraint>, !felt.type
// CHECK:             %[[VAL_19:.*]] = struct.readf %[[VAL_9]][@__llzk_r1cs_lowering_pass_aux_field_1] : <@CmpConstraint>, !felt.type
// CHECK:             constrain.eq %[[VAL_19]], %[[VAL_17]] : !felt.type, !felt.type
// CHECK:             constrain.eq %[[VAL_19]], %[[VAL_13]] : !felt.type, !felt.type
// CHECK:             %[[VAL_20:.*]] = felt.sub %[[VAL_13]], %[[VAL_11]] : !felt.type, !felt.type
// CHECK:             constrain.eq %[[VAL_18]], %[[VAL_20]] : !felt.type, !felt.type
// CHECK:             function.return
// CHECK:           }
// CHECK:           struct.field @__llzk_r1cs_lowering_pass_aux_field_0 : !felt.type
// CHECK:           struct.field @__llzk_r1cs_lowering_pass_aux_field_1 : !felt.type
// CHECK:         }
