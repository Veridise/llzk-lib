// RUN: llzk-opt -I %S -split-input-file -llzk-inline-includes -llzk-print-interval-analysis="field=babybear print-compute-intervals propagate-input-constraints" %s 2>&1 | FileCheck %s

module attributes {veridise.lang = "llzk"} {
  struct.def @BoolAnd {
    struct.field @case0 : i1
    struct.field @case1 : i1
    struct.field @case2 : i1
    struct.field @case3 : i1
    struct.field @case4 : i1
    struct.field @case5 : i1
    struct.field @case6 : i1
    struct.field @case7 : i1
    struct.field @case8 : i1

    function.def @compute(%a: !felt.type) -> !struct.type<@BoolAnd> {
      %self = struct.new : !struct.type<@BoolAnd>

      %1 = felt.const 1
      %2 = felt.const 2

      %true = bool.cmp eq(%1, %1)
      %false = bool.cmp eq(%1, %2)
      %any = bool.cmp eq(%a, %1)

      %case0 = bool.and %true, %true
      %case1 = bool.and %true, %false
      %case2 = bool.and %false, %true
      %case3 = bool.and %false, %false
      %case4 = bool.and %any, %any
      %case5 = bool.and %any, %true
      %case6 = bool.and %true, %any
      %case7 = bool.and %any, %false
      %case8 = bool.and %false, %any

      struct.writef %self[@case0] = %case0 : <@BoolAnd>, i1
      struct.writef %self[@case1] = %case1 : <@BoolAnd>, i1
      struct.writef %self[@case2] = %case2 : <@BoolAnd>, i1
      struct.writef %self[@case3] = %case3 : <@BoolAnd>, i1
      struct.writef %self[@case4] = %case4 : <@BoolAnd>, i1
      struct.writef %self[@case5] = %case5 : <@BoolAnd>, i1
      struct.writef %self[@case6] = %case6 : <@BoolAnd>, i1
      struct.writef %self[@case7] = %case7 : <@BoolAnd>, i1
      struct.writef %self[@case8] = %case8 : <@BoolAnd>, i1

      function.return %self : !struct.type<@BoolAnd>
    }

    function.def @constrain(%self: !struct.type<@BoolAnd>, %a: !felt.type) {
      function.return
    }
  }
}

// CHECK-LABEL: compute {
// CHECK-NEXT:     %arg0 in Entire
// CHECK-NEXT:     %self[@case0] in Degenerate(1)
// CHECK-NEXT:     %self[@case1] in Degenerate(0)
// CHECK-NEXT:     %self[@case2] in Degenerate(0)
// CHECK-NEXT:     %self[@case3] in Degenerate(0)
// CHECK-NEXT:     %self[@case4] in TypeA:[ 0, 1 ]
// CHECK-NEXT:     %self[@case5] in TypeA:[ 0, 1 ]
// CHECK-NEXT:     %self[@case6] in TypeA:[ 0, 1 ]
// CHECK-NEXT:     %self[@case7] in Degenerate(0)
// CHECK-NEXT:     %self[@case8] in Degenerate(0)
// CHECK-NEXT: }

// -----

module attributes {veridise.lang = "llzk"} {
  struct.def @BoolOr {
    struct.field @case0 : i1
    struct.field @case1 : i1
    struct.field @case2 : i1
    struct.field @case3 : i1
    struct.field @case4 : i1
    struct.field @case5 : i1
    struct.field @case6 : i1
    struct.field @case7 : i1
    struct.field @case8 : i1

    function.def @compute(%a: !felt.type) -> !struct.type<@BoolOr> {
      %self = struct.new : !struct.type<@BoolOr>

      %1 = felt.const 1
      %2 = felt.const 2

      %true = bool.cmp eq(%1, %1)
      %false = bool.cmp eq(%1, %2)
      %any = bool.cmp eq(%a, %1)

      %case0 = bool.or %true, %true
      %case1 = bool.or %true, %false
      %case2 = bool.or %false, %true
      %case3 = bool.or %false, %false
      %case4 = bool.or %any, %any
      %case5 = bool.or %any, %true
      %case6 = bool.or %true, %any
      %case7 = bool.or %any, %false
      %case8 = bool.or %false, %any

      struct.writef %self[@case0] = %case0 : <@BoolOr>, i1
      struct.writef %self[@case1] = %case1 : <@BoolOr>, i1
      struct.writef %self[@case2] = %case2 : <@BoolOr>, i1
      struct.writef %self[@case3] = %case3 : <@BoolOr>, i1
      struct.writef %self[@case4] = %case4 : <@BoolOr>, i1
      struct.writef %self[@case5] = %case5 : <@BoolOr>, i1
      struct.writef %self[@case6] = %case6 : <@BoolOr>, i1
      struct.writef %self[@case7] = %case7 : <@BoolOr>, i1
      struct.writef %self[@case8] = %case8 : <@BoolOr>, i1

      function.return %self : !struct.type<@BoolOr>
    }

    function.def @constrain(%self: !struct.type<@BoolOr>, %a: !felt.type) {
      function.return
    }
  }
}

// CHECK-LABEL: compute {
// CHECK-NEXT:     %arg0 in Entire
// CHECK-NEXT:     %self[@case0] in Degenerate(1)
// CHECK-NEXT:     %self[@case1] in Degenerate(1)
// CHECK-NEXT:     %self[@case2] in Degenerate(1)
// CHECK-NEXT:     %self[@case3] in Degenerate(0)
// CHECK-NEXT:     %self[@case4] in TypeA:[ 0, 1 ]
// CHECK-NEXT:     %self[@case5] in Degenerate(1)
// CHECK-NEXT:     %self[@case6] in Degenerate(1)
// CHECK-NEXT:     %self[@case7] in TypeA:[ 0, 1 ]
// CHECK-NEXT:     %self[@case8] in TypeA:[ 0, 1 ]
// CHECK-NEXT: }

// -----

module attributes {veridise.lang = "llzk"} {
  struct.def @BoolXor {
    struct.field @case0 : i1
    struct.field @case1 : i1
    struct.field @case2 : i1
    struct.field @case3 : i1
    struct.field @case4 : i1
    struct.field @case5 : i1
    struct.field @case6 : i1
    struct.field @case7 : i1
    struct.field @case8 : i1

    function.def @compute(%a: !felt.type) -> !struct.type<@BoolXor> {
      %self = struct.new : !struct.type<@BoolXor>

      %1 = felt.const 1
      %2 = felt.const 2

      %true = bool.cmp eq(%1, %1)
      %false = bool.cmp eq(%1, %2)
      %any = bool.cmp eq(%a, %1)

      %case0 = bool.xor %true, %true
      %case1 = bool.xor %true, %false
      %case2 = bool.xor %false, %true
      %case3 = bool.xor %false, %false
      %case4 = bool.xor %any, %any
      %case5 = bool.xor %any, %true
      %case6 = bool.xor %true, %any
      %case7 = bool.xor %any, %false
      %case8 = bool.xor %false, %any

      struct.writef %self[@case0] = %case0 : <@BoolXor>, i1
      struct.writef %self[@case1] = %case1 : <@BoolXor>, i1
      struct.writef %self[@case2] = %case2 : <@BoolXor>, i1
      struct.writef %self[@case3] = %case3 : <@BoolXor>, i1
      struct.writef %self[@case4] = %case4 : <@BoolXor>, i1
      struct.writef %self[@case5] = %case5 : <@BoolXor>, i1
      struct.writef %self[@case6] = %case6 : <@BoolXor>, i1
      struct.writef %self[@case7] = %case7 : <@BoolXor>, i1
      struct.writef %self[@case8] = %case8 : <@BoolXor>, i1

      function.return %self : !struct.type<@BoolXor>
    }

    function.def @constrain(%self: !struct.type<@BoolXor>, %a: !felt.type) {
      function.return
    }
  }
}

// CHECK-LABEL: compute {
// CHECK-NEXT:     %arg0 in Entire
// CHECK-NEXT:     %self[@case0] in Degenerate(0)
// CHECK-NEXT:     %self[@case1] in Degenerate(1)
// CHECK-NEXT:     %self[@case2] in Degenerate(1)
// CHECK-NEXT:     %self[@case3] in Degenerate(0)
// CHECK-NEXT:     %self[@case4] in TypeA:[ 0, 1 ]
// CHECK-NEXT:     %self[@case5] in TypeA:[ 0, 1 ]
// CHECK-NEXT:     %self[@case6] in TypeA:[ 0, 1 ]
// CHECK-NEXT:     %self[@case7] in TypeA:[ 0, 1 ]
// CHECK-NEXT:     %self[@case8] in TypeA:[ 0, 1 ]
// CHECK-NEXT: }

// -----

module attributes {veridise.lang = "llzk"} {
  struct.def @BoolNot {
    struct.field @case0 : i1
    struct.field @case1 : i1
    struct.field @case2 : i1

    function.def @compute(%a: !felt.type) -> !struct.type<@BoolNot> {
      %self = struct.new : !struct.type<@BoolNot>

      %1 = felt.const 1
      %2 = felt.const 2

      %true = bool.cmp eq(%1, %1)
      %false = bool.cmp eq(%1, %2)
      %any = bool.cmp eq(%a, %1)

      %case0 = bool.not %true
      %case1 = bool.not %false
      %case2 = bool.not %any

      struct.writef %self[@case0] = %case0 : <@BoolNot>, i1
      struct.writef %self[@case1] = %case1 : <@BoolNot>, i1
      struct.writef %self[@case2] = %case2 : <@BoolNot>, i1

      function.return %self : !struct.type<@BoolNot>
    }

    function.def @constrain(%self: !struct.type<@BoolNot>, %a: !felt.type) {
      function.return
    }
  }
}

// CHECK-LABEL: compute {
// CHECK-NEXT:     %arg0 in Entire
// CHECK-NEXT:     %self[@case0] in Degenerate(0)
// CHECK-NEXT:     %self[@case1] in Degenerate(1)
// CHECK-NEXT:     %self[@case2] in  TypeA:[ 0, 1 ]
// CHECK-NEXT: }

// -----

module attributes {veridise.lang = "llzk"} {
  struct.def @BitAnd {
    struct.field @case0 : !felt.type
    struct.field @case1 : !felt.type
    struct.field @case2 : !felt.type
    struct.field @case3 : !felt.type

    function.def @compute(%a: !felt.type, %b: !felt.type) -> !struct.type<@BitAnd> {
      %self = struct.new : !struct.type<@BitAnd>

      %ff = felt.const 255 // 0xff
      %2 = felt.const 2

      %case0 = felt.bit_and %a, %b
      %case1 = felt.bit_and %a, %ff
      %case2 = felt.bit_and %ff, %a
      %case3 = felt.bit_and %2, %ff

      struct.writef %self[@case0] = %case0 : <@BitAnd>, !felt.type
      struct.writef %self[@case1] = %case1 : <@BitAnd>, !felt.type
      struct.writef %self[@case2] = %case2 : <@BitAnd>, !felt.type
      struct.writef %self[@case3] = %case3 : <@BitAnd>, !felt.type

      function.return %self : !struct.type<@BitAnd>
    }

    function.def @constrain(%self: !struct.type<@BitAnd>, %a: !felt.type, %b: !felt.type) {
      function.return
    }
  }
}

// CHECK-LABEL: compute {
// CHECK-NEXT:     %arg0 in Entire
// CHECK-NEXT:     %arg1 in Entire
// CHECK-NEXT:     %self[@case0] in Entire
// CHECK-NEXT:     %self[@case1] in TypeA:[ 0, 255 ]
// CHECK-NEXT:     %self[@case2] in TypeA:[ 0, 255 ]
// CHECK-NEXT:     %self[@case3] in Degenerate(2)
// CHECK-NEXT: }

// -----

module attributes {veridise.lang = "llzk"} {
  struct.def @ShiftLeft {
    struct.field @case0 : !felt.type
    struct.field @case1 : !felt.type
    struct.field @case2 : !felt.type
    struct.field @case3 : !felt.type
    struct.field @case4 : !felt.type

    function.def @compute(%a: !felt.type, %b: !felt.type) -> !struct.type<@ShiftLeft> {
      %self = struct.new : !struct.type<@ShiftLeft>

      %ff = felt.const 255 // 0xff
      %2 = felt.const 2

      %case0 = felt.shl %a, %b
      %case1 = felt.shl %a, %2
      %case2 = felt.shl %ff, %2
      %case3 = felt.shl %b, %ff
      %case4 = felt.shl %2, %ff

      struct.writef %self[@case0] = %case0 : <@ShiftLeft>, !felt.type
      struct.writef %self[@case1] = %case1 : <@ShiftLeft>, !felt.type
      struct.writef %self[@case2] = %case2 : <@ShiftLeft>, !felt.type
      struct.writef %self[@case3] = %case3 : <@ShiftLeft>, !felt.type
      struct.writef %self[@case4] = %case4 : <@ShiftLeft>, !felt.type

      function.return %self : !struct.type<@ShiftLeft>
    }

    function.def @constrain(%self: !struct.type<@ShiftLeft>, %a: !felt.type, %b: !felt.type) {
      function.return
    }
  }
}

// CHECK-LABEL: compute {
// CHECK-NEXT:     %arg0 in Entire
// CHECK-NEXT:     %arg1 in Entire
// CHECK-NEXT:     %self[@case0] in Entire
// CHECK-NEXT:     %self[@case1] in Entire
// CHECK-NEXT:     %self[@case2] in Degenerate(1020)
// CHECK-NEXT:     %self[@case3] in Entire
// CHECK-NEXT:     %self[@case4] in Entire
// CHECK-NEXT: }

// -----

module attributes {veridise.lang = "llzk"} {
  struct.def @ShiftRight {
    struct.field @case0 : !felt.type
    struct.field @case1 : !felt.type
    struct.field @case2 : !felt.type
    struct.field @case3 : !felt.type
    struct.field @case4 : !felt.type

    function.def @compute(%a: !felt.type, %b: !felt.type) -> !struct.type<@ShiftRight> {
      %self = struct.new : !struct.type<@ShiftRight>

      %ff = felt.const 255 // 0xff
      %2 = felt.const 2

      %case0 = felt.shr %a, %b
      %case1 = felt.shr %a, %2
      %case2 = felt.shr %ff, %2
      %case3 = felt.shr %b, %ff
      %case4 = felt.shr %2, %ff

      struct.writef %self[@case0] = %case0 : <@ShiftRight>, !felt.type
      struct.writef %self[@case1] = %case1 : <@ShiftRight>, !felt.type
      struct.writef %self[@case2] = %case2 : <@ShiftRight>, !felt.type
      struct.writef %self[@case3] = %case3 : <@ShiftRight>, !felt.type
      struct.writef %self[@case4] = %case4 : <@ShiftRight>, !felt.type

      function.return %self : !struct.type<@ShiftRight>
    }

    function.def @constrain(%self: !struct.type<@ShiftRight>, %a: !felt.type, %b: !felt.type) {
      function.return
    }
  }
}

// CHECK-LABEL: compute {
// CHECK-NEXT:     %arg0 in Entire
// CHECK-NEXT:     %arg1 in Entire
// CHECK-NEXT:     %self[@case0] in Entire
// CHECK-NEXT:     %self[@case1] in Entire
// CHECK-NEXT:     %self[@case2] in Degenerate(63)
// CHECK-NEXT:     %self[@case3] in Entire
// CHECK-NEXT:     %self[@case4] in Degenerate(0)
// CHECK-NEXT: }
