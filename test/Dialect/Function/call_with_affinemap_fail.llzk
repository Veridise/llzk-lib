// RUN: llzk-opt -I %input_dir -split-input-file -verify-diagnostics %s

// -----
module attributes {veridise.lang = "llzk"} {
  include.from "Inputs/header_11.llzk" as @Lib

  struct.def @MissingInstantiations {
    function.def @compute(%n: index) -> !struct.struct<@MissingInstantiations> {
      %self = struct.new : !struct.struct<@MissingInstantiations>
      // expected-error@+1 {{'function.call' op map instantiation group count (0) does not match the number of affine map instantiations (1) required by the type}}
      %x = function.call @Lib::@D1::@compute() : () -> !struct.struct<@Lib::@D1<[affine_map<(i)->(i)>]>>
      function.return %self : !struct.struct<@MissingInstantiations>
    }

    function.def @constrain(%self: !struct.struct<@MissingInstantiations>, %n: index) { function.return }
  }
}
// -----
module attributes {veridise.lang = "llzk"} {
  include.from "Inputs/header_11.llzk" as @Lib

  struct.def @EmptyInstantiations {
    function.def @compute(%n: index) -> !struct.struct<@EmptyInstantiations> {
      %self = struct.new : !struct.struct<@EmptyInstantiations>
      // expected-error@+1 {{expected '(' in operand list}}
      %x = function.call @Lib::@D1::@compute(){} : () -> !struct.struct<@Lib::@D1<[affine_map<(i)->(i)>]>>
      function.return %self : !struct.struct<@EmptyInstantiations>
    }

    function.def @constrain(%self: !struct.struct<@EmptyInstantiations>, %n: index) { function.return }
  }
}
// -----
module attributes {veridise.lang = "llzk"} {
  include.from "Inputs/header_11.llzk" as @Lib

  struct.def @TooFewInstantiations {
    function.def @compute(%n: index) -> !struct.struct<@TooFewInstantiations> {
      %self = struct.new : !struct.struct<@TooFewInstantiations>
      // expected-error@+1 {{'function.call' op map instantiation group count (1) does not match the number of affine map instantiations (2) required by the type}}
      %x = function.call @Lib::@D2::@compute(){(%n)[]} : () -> !struct.struct<@Lib::@D2<[affine_map<(i)->(i)>, affine_map<(i)->(i)>]>>
      function.return %self : !struct.struct<@TooFewInstantiations>
    }

    function.def @constrain(%self: !struct.struct<@TooFewInstantiations>, %n: index) { function.return }
  }
}
// -----
module attributes {veridise.lang = "llzk"} {
  include.from "Inputs/header_11.llzk" as @Lib

  struct.def @TooManyInstantiations {
    function.def @compute(%n: index) -> !struct.struct<@TooManyInstantiations> {
      %self = struct.new : !struct.struct<@TooManyInstantiations>
      // expected-error@+1 {{'function.call' op map instantiation group count (2) does not match the number of affine map instantiations (1) required by the type}}
      %x = function.call @Lib::@D1::@compute(){(%n)[], ()[%n]} : () -> !struct.struct<@Lib::@D1<[affine_map<(i)->(i)>]>>
      function.return %self : !struct.struct<@TooManyInstantiations>
    }

    function.def @constrain(%self: !struct.struct<@TooManyInstantiations>, %n: index) { function.return }
  }
}
// -----
module attributes {veridise.lang = "llzk"} {
  include.from "Inputs/header_11.llzk" as @Lib

  struct.def @TooFewDimensions {
    function.def @compute(%n: index) -> !struct.struct<@TooFewDimensions> {
      %self = struct.new : !struct.struct<@TooFewDimensions>
      // expected-error@+1 {{'function.call' op instantiation of map 0 expected 1 but found 0 dimension values in ()}}
      %x = function.call @Lib::@D1::@compute(){()[%n]} : () -> !struct.struct<@Lib::@D1<[affine_map<(i)->(i)>]>>
      function.return %self : !struct.struct<@TooFewDimensions>
    }

    function.def @constrain(%self: !struct.struct<@TooFewDimensions>, %n: index) { function.return }
  }
}
// -----
module attributes {veridise.lang = "llzk"} {
  include.from "Inputs/header_11.llzk" as @Lib

  struct.def @TooManyDimensions {
    function.def @compute(%a: index, %b: index) -> !struct.struct<@TooManyDimensions> {
      %self = struct.new : !struct.struct<@TooManyDimensions>
      // expected-error@+1 {{'function.call' op instantiation of map 0 expected 1 but found 2 dimension values in ()}}
      %x = function.call @Lib::@D1::@compute(){ (%a,%b)[] } : () -> !struct.struct<@Lib::@D1<[affine_map<(i)->(i)>]>>
      function.return %self : !struct.struct<@TooManyDimensions>
    }

    function.def @constrain(%self: !struct.struct<@TooManyDimensions>, %a: index, %b: index) { function.return }
  }
}
// -----
module attributes {veridise.lang = "llzk"} {
  include.from "Inputs/header_11.llzk" as @Lib

  struct.def @TooFewSymbols {
    function.def @compute(%n: index) -> !struct.struct<@TooFewSymbols> {
      %self = struct.new : !struct.struct<@TooFewSymbols>
      // expected-error@+1 {{'function.call' op instantiation of map 0 expected 1 but found 0 symbol values in []}}
      %x = function.call @Lib::@D1::@compute(){(%n)[]} : () -> !struct.struct<@Lib::@D1<[affine_map<(i)[k] -> (5*i+k)>]>>
      function.return %self : !struct.struct<@TooFewSymbols>
    }

    function.def @constrain(%self: !struct.struct<@TooFewSymbols>, %n: index) { function.return }
  }
}
// -----
module attributes {veridise.lang = "llzk"} {
  include.from "Inputs/header_11.llzk" as @Lib

  struct.def @TooManySymbols {
    function.def @compute(%a: index, %b: index, %c: index) -> !struct.struct<@TooManySymbols> {
      %self = struct.new : !struct.struct<@TooManySymbols>
      // expected-error@+1 {{'function.call' op instantiation of map 0 expected 1 but found 2 symbol values in []}}
      %x = function.call @Lib::@D1::@compute(){ (%a)[%b, %c] } : () -> !struct.struct<@Lib::@D1<[affine_map<(i)[k] -> (5*i+k)>]>>
      function.return %self : !struct.struct<@TooManySymbols>
    }

    function.def @constrain(%self: !struct.struct<@TooManySymbols>, %a: index, %b: index, %c: index) { function.return }
  }
}
// -----
module attributes {veridise.lang = "llzk"} {
  struct.def @CallUnknownConstrainWithMapInit<[@S]> {
    function.def @compute(%0: !llzk.tvar<@S>) -> !struct.struct<@CallUnknownConstrainWithMapInit<[@S]>> {
      %self = struct.new : !struct.struct<@CallUnknownConstrainWithMapInit<[@S]>>
      function.return %self : !struct.struct<@CallUnknownConstrainWithMapInit<[@S]>>
    }

    function.def @constrain(%self: !struct.struct<@CallUnknownConstrainWithMapInit<[@S]>>, %0: !llzk.tvar<@S>) {
      %i = arith.constant 28 : index
      // expected-error@+1 {{'function.call' op can only have affine map instantiations when targeting a "@compute" function}}
      function.call @S::@constrain(%0){ (%i) } : (!llzk.tvar<@S>) -> ()
      function.return
    }
  }
}
// -----
module attributes {veridise.lang = "llzk"} {
  include.from "Inputs/header_11.llzk" as @Lib

  struct.def @CallKnownConstrainWithMapInit {
    function.def @compute(%0: !struct.struct<@Lib::@D0>) -> !struct.struct<@CallKnownConstrainWithMapInit> {
      %self = struct.new : !struct.struct<@CallKnownConstrainWithMapInit>
      function.return %self : !struct.struct<@CallKnownConstrainWithMapInit>
    }

    function.def @constrain(%self: !struct.struct<@CallKnownConstrainWithMapInit>, %0: !struct.struct<@Lib::@D0>) {
      %i = arith.constant 28 : index
      // expected-error@+1 {{'function.call' op can only have affine map instantiations when targeting a "@compute" function}}
      function.call @Lib::@D0::@constrain(%0){ (%i) } : (!struct.struct<@Lib::@D0>) -> ()
      function.return
    }
  }
}
// -----
module attributes {veridise.lang = "llzk"} {
  function.def @global_id(%0: index) -> index {
    function.return %0 : index
  }

  struct.def @CallKnownGlobalWithMapInit {
    function.def @compute() -> !struct.struct<@CallKnownGlobalWithMapInit> {
      %self = struct.new : !struct.struct<@CallKnownGlobalWithMapInit>
      %i = arith.constant 28 : index
      // expected-error@+1 {{'function.call' op can only have affine map instantiations when targeting a "@compute" function}}
      %0 = function.call @global_id(%i){ (%i) } : (index) -> (index)
      function.return %self : !struct.struct<@CallKnownGlobalWithMapInit>
    }

    function.def @constrain(%self: !struct.struct<@CallKnownGlobalWithMapInit>) { function.return }
  }
}

// -----
module attributes {veridise.lang = "llzk"} {
  include.from "Inputs/header_11.llzk" as @Lib

  struct.def @TooFewResults {
    function.def @compute(%a: index, %b: index, %c: index) -> !struct.struct<@TooManySymbols> {
      %self = struct.new : !struct.struct<@TooManySymbols>
      // expected-error@+1 {{AffineMapAttr must yield a single result, but found 0 results}}
      %x = function.call @Lib::@D1::@compute(){ (%a)[%b, %c] } : () -> !struct.struct<@Lib::@D1<[affine_map<(i)[k, j] -> ()>]>>
      function.return %self : !struct.struct<@TooManySymbols>
    }

    function.def @constrain(%self: !struct.struct<@TooManySymbols>, %a: index, %b: index, %c: index) { function.return }
  }
}

// -----
module attributes {veridise.lang = "llzk"} {
  include.from "Inputs/header_11.llzk" as @Lib

  struct.def @TooManyResults {
    function.def @compute(%a: index, %b: index, %c: index) -> !struct.struct<@TooManySymbols> {
      %self = struct.new : !struct.struct<@TooManySymbols>
      // expected-error@+1 {{AffineMapAttr must yield a single result, but found 5 results}}
      %x = function.call @Lib::@D1::@compute(){ (%a)[%b, %c] } : () -> !struct.struct<@Lib::@D1<[affine_map<(i)[k, j] -> (5*i+k, j, i, k, 7)>]>>
      function.return %self : !struct.struct<@TooManySymbols>
    }

    function.def @constrain(%self: !struct.struct<@TooManySymbols>, %a: index, %b: index, %c: index) { function.return }
  }
}
