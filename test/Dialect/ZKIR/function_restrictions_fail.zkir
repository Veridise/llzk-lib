// RUN: zkir-opt -split-input-file -verify-diagnostics %s

module attributes {veridise.lang = "zkir"} {
  zkir.struct @emiteq_in_compute {
    func @compute(%a: !zkir.felt, %b: !zkir.felt) -> !zkir.struct<@emiteq_in_compute> {
      // expected-error@+1 {{'zkir.emit_eq' op only valid within a 'zkir.func' named "@constrain" within a 'zkir.struct' definition}}
      zkir.emit_eq %a, %b : !zkir.felt
      %self = new_struct : !zkir.struct<@emiteq_in_compute>
      return %self : !zkir.struct<@emiteq_in_compute>
    }

    func @constrain(%self: !zkir.struct<@emiteq_in_compute>, %a: !zkir.felt, %b: !zkir.felt) { return }
  }
}
// -----
module attributes {veridise.lang = "zkir"} {
  zkir.struct @emiteq_in_compute_in_loop {
    func @compute(%a: !zkir.felt, %b: !zkir.felt) -> !zkir.struct<@emiteq_in_compute_in_loop> {
      %lb = index.constant 0
      %up = index.constant 4
      %step = index.constant 1
      scf.for %iv = %lb to %up step %step {
        // expected-error@+1 {{'zkir.emit_eq' op only valid within a 'zkir.func' named "@constrain" within a 'zkir.struct' definition}}
        zkir.emit_eq %a, %b : !zkir.felt
      }
      %self = new_struct : !zkir.struct<@emiteq_in_compute_in_loop>
      return %self : !zkir.struct<@emiteq_in_compute_in_loop>
    }

    func @constrain(%self: !zkir.struct<@emiteq_in_compute_in_loop>, %a: !zkir.felt, %b: !zkir.felt) { return }
  }
}
// -----
module attributes {veridise.lang = "zkir"} {
  zkir.struct @emiteq_in_compute_in_deep_branches {
    func @compute(%a: i1, %b: i1, %c: i1, %x: !zkir.felt, %y: !zkir.felt) -> !zkir.struct<@emiteq_in_compute_in_deep_branches> {
      scf.if %a {
        scf.if %b {
          scf.if %c {
            // expected-error@+1 {{'zkir.emit_eq' op only valid within a 'zkir.func' named "@constrain" within a 'zkir.struct' definition}}
            zkir.emit_eq %x, %y : !zkir.felt
          }
        }
      }
      %self = new_struct : !zkir.struct<@emiteq_in_compute_in_deep_branches>
      return %self : !zkir.struct<@emiteq_in_compute_in_deep_branches>
    }

    func @constrain(%self: !zkir.struct<@emiteq_in_compute_in_deep_branches>, %a: i1, %b: i1, %c: i1, %x: !zkir.felt, %y: !zkir.felt) { return }
  }
}
// -----
module attributes {veridise.lang = "zkir"} {
  zkir.struct @emitin_in_compute {
    func @compute(%a: !zkir.felt, %b: !zkir.array<5 x !zkir.felt>) -> !zkir.struct<@emitin_in_compute> {
      // expected-error@+1 {{'zkir.emit_in' op only valid within a 'zkir.func' named "@constrain" within a 'zkir.struct' definition}}
      zkir.emit_in %a, %b : !zkir.array<5 x !zkir.felt>
      %self = new_struct : !zkir.struct<@emitin_in_compute>
      return %self : !zkir.struct<@emitin_in_compute>
    }

    func @constrain(%self: !zkir.struct<@emitin_in_compute>, %a: !zkir.felt, %b: !zkir.array<5 x !zkir.felt>) { return }
  }
}
// -----
module attributes {veridise.lang = "zkir"} {
  zkir.struct @emitin_in_compute_in_loop {
    func @compute(%a: !zkir.felt, %b: !zkir.array<5 x !zkir.felt>) -> !zkir.struct<@emitin_in_compute_in_loop> {
      %lb = index.constant 0
      %up = index.constant 4
      %step = index.constant 1
      scf.for %iv = %lb to %up step %step {
        // expected-error@+1 {{'zkir.emit_in' op only valid within a 'zkir.func' named "@constrain" within a 'zkir.struct' definition}}
        zkir.emit_in %a, %b : !zkir.array<5 x !zkir.felt>
      }
      %self = new_struct : !zkir.struct<@emitin_in_compute_in_loop>
      return %self : !zkir.struct<@emitin_in_compute_in_loop>
    }

    func @constrain(%self: !zkir.struct<@emitin_in_compute_in_loop>, %a: !zkir.felt, %b: !zkir.array<5 x !zkir.felt>) { return }
  }
}
// -----
module attributes {veridise.lang = "zkir"} {
  zkir.struct @emitin_in_compute_in_deep_branches {
    func @compute(%a: i1, %b: i1, %c: i1, %x: index, %y: !zkir.array<5 x index>) -> !zkir.struct<@emitin_in_compute_in_deep_branches> {
      scf.if %a {
        scf.if %b {
          scf.if %c {
            // expected-error@+1 {{'zkir.emit_in' op only valid within a 'zkir.func' named "@constrain" within a 'zkir.struct' definition}}
            zkir.emit_in %x, %y : !zkir.array<5 x index>
          }
        }
      }
      %self = new_struct : !zkir.struct<@emitin_in_compute_in_deep_branches>
      return %self : !zkir.struct<@emitin_in_compute_in_deep_branches>
    }

    func @constrain(%self: !zkir.struct<@emitin_in_compute_in_deep_branches>, %a: i1, %b: i1, %c: i1, %x: index, %y: !zkir.array<5 x index>) { return }
  }
}
// -----
zkir.func @constrain(%a: !zkir.felt, %b: !zkir.felt) {
  // expected-error@+1 {{'zkir.emit_eq' op only valid within a 'zkir.func' named "@constrain" within a 'zkir.struct' definition}}
  zkir.emit_eq %a, %b : !zkir.felt
  return
}
// -----
zkir.func @constrain(%x: index, %y: !zkir.array<5 x index>) {
  // expected-error@+1 {{'zkir.emit_in' op only valid within a 'zkir.func' named "@constrain" within a 'zkir.struct' definition}}
  zkir.emit_in %x, %y : !zkir.array<5 x index>
  return
}
// -----
module attributes {veridise.lang = "zkir"} {
  zkir.struct @constrain_calls_compute {
    func @compute() -> !zkir.struct<@constrain_calls_compute> {
      %self = new_struct : !zkir.struct<@constrain_calls_compute>
      return %self : !zkir.struct<@constrain_calls_compute>
    }

    func @constrain(%self: !zkir.struct<@constrain_calls_compute>) {
      // expected-error@+1 {{'zkir.call' op targeting "compute" only valid within a 'zkir.func' named "@compute" within a 'zkir.struct' definition}}
      call @constrain_calls_compute::@compute() : () -> !zkir.struct<@constrain_calls_compute>
      return
    }
  }
}
// -----
module attributes {veridise.lang = "zkir"} {
  zkir.struct @compute_calls_constrain {
    func @compute() -> !zkir.struct<@compute_calls_constrain> {
      %self = new_struct : !zkir.struct<@compute_calls_constrain>
      // expected-error@+1 {{'zkir.call' op targeting "constrain" only valid within a 'zkir.func' named "@constrain" within a 'zkir.struct' definition}}
      call @compute_calls_constrain::@constrain(%self) : (!zkir.struct<@compute_calls_constrain>) -> ()
      return %self : !zkir.struct<@compute_calls_constrain>
    }

    func @constrain(%self: !zkir.struct<@compute_calls_constrain>) {
      return
    }
  }
}
// -----
module attributes {veridise.lang = "zkir"} {
  zkir.func @globalFunc() {
    // expected-error@+1 {{'zkir.call' op targeting "compute" only valid within a 'zkir.func' named "@compute" within a 'zkir.struct' definition}}
    call @global_calls_compute::@compute() : () -> !zkir.struct<@global_calls_compute>
    return
  }
  zkir.struct @global_calls_compute {
    func @compute() -> !zkir.struct<@global_calls_compute> {
      %self = new_struct : !zkir.struct<@global_calls_compute>
      return %self : !zkir.struct<@global_calls_compute>
    }

    func @constrain(%self: !zkir.struct<@global_calls_compute>) {
      return
    }
  }
}
// -----
module attributes {veridise.lang = "zkir"} {
  zkir.func @globalFunc(%0: !zkir.struct<@global_calls_constrain>) {
    // expected-error@+1 {{'zkir.call' op targeting "constrain" only valid within a 'zkir.func' named "@constrain" within a 'zkir.struct' definition}}
    call @global_calls_constrain::@constrain(%0) : (!zkir.struct<@global_calls_constrain>) -> ()
    return
  }
  zkir.struct @global_calls_constrain {
    func @compute() -> !zkir.struct<@global_calls_constrain> {
      %self = new_struct : !zkir.struct<@global_calls_constrain>
      return %self : !zkir.struct<@global_calls_constrain>
    }

    func @constrain(%self: !zkir.struct<@global_calls_constrain>) {
      return
    }
  }
}
// -----
zkir.struct @inv_in_constrain {
  func @compute(%a: !zkir.felt) -> !zkir.struct<@inv_in_constrain> {
    %self = new_struct : !zkir.struct<@inv_in_constrain>
    return %self : !zkir.struct<@inv_in_constrain>
  }

  func @constrain(%self: !zkir.struct<@inv_in_constrain>, %a: !zkir.felt) {
    // expected-error@+1 {{'zkir.inv' op is ComputeOnly so it cannot be used within a 'zkir.func' named "@constrain" within a 'zkir.struct' definition}}
    %c = zkir.inv %a
    return
  }
}
// -----
zkir.struct @inv_in_constrain {
  func @compute(%a: !zkir.felt) -> !zkir.struct<@inv_in_constrain> {
    %self = new_struct : !zkir.struct<@inv_in_constrain>
    return %self : !zkir.struct<@inv_in_constrain>
  }

  func @constrain(%self: !zkir.struct<@inv_in_constrain>, %a: !zkir.felt) {
    // expected-error@+1 {{'zkir.inv' op is ComputeOnly so it cannot be used within a 'zkir.func' named "@constrain" within a 'zkir.struct' definition}}
    %c = zkir.inv %a
    return
  }
}
// -----
module attributes {veridise.lang = "zkir"} {
  zkir.struct @compute_no_ret {
    // expected-error@+1 {{'zkir.func' op "compute" must have exactly one return type}}
    func @compute() {
      return
    }

    func @constrain(%self: !zkir.struct<@compute_no_ret>) {
      return
    }
  }
}
// -----
module attributes {veridise.lang = "zkir"} {
  zkir.struct @compute_multiple_ret {
    // expected-error@+1 {{'zkir.func' op "compute" must have exactly one return type}}
    func @compute(%a: i1) -> (!zkir.struct<@compute_multiple_ret>, i1) {
      %self = new_struct : !zkir.struct<@compute_multiple_ret>
      return %self, %a : !zkir.struct<@compute_multiple_ret>, i1
    }

    func @constrain(%self: !zkir.struct<@compute_multiple_ret>, %a: i1) {
      return
    }
  }
}
// -----
module attributes {veridise.lang = "zkir"} {
  zkir.struct @constrain_with_ret {
    func @compute() -> !zkir.struct<@constrain_with_ret> {
      %self = new_struct : !zkir.struct<@constrain_with_ret>
      return %self : !zkir.struct<@constrain_with_ret>
    }

    // expected-error@+1 {{'zkir.func' op "constrain" must have no return type}}
    func @constrain(%self: !zkir.struct<@constrain_with_ret>, %a: i1) -> i1 {
      return %a : i1
    }
  }
}
// -----
module attributes {veridise.lang = "zkir"} {
  zkir.struct @compute_with_wrong_ret {
    // expected-error@+1 {{'zkir.func' op "@compute" must use type of its parent 'zkir.struct' "@compute_with_wrong_ret" as return type}}
    func @compute() -> index {
      %b = index.constant 2
      return %b : index
    }

    func @constrain(%self: !zkir.struct<@compute_with_wrong_ret>) {
      return
    }
  }
}
// -----
module attributes {veridise.lang = "zkir"} {
  zkir.struct @good { // expected-note {{uses this type instead}}
    func @compute() -> !zkir.struct<@good> {
      %self = new_struct : !zkir.struct<@good>
      return %self : !zkir.struct<@good>
    }
    func @constrain(%self: !zkir.struct<@good>) {
      return
    }
  }

  zkir.struct @compute_with_wrong_ret {
    // expected-error@+1 {{'zkir.func' op "@compute" must use type of its parent 'zkir.struct' "@compute_with_wrong_ret" as return type}}
    func @compute() -> !zkir.struct<@good> {
      %self = new_struct : !zkir.struct<@good>
      return %self : !zkir.struct<@good>
    }

    func @constrain(%self: !zkir.struct<@compute_with_wrong_ret>) {
      return
    }
  }
}
// -----
module attributes {veridise.lang = "zkir"} {
  module @one {
    zkir.struct @good { // expected-note {{uses this type instead}}
      func @compute() -> !zkir.struct<@one::@good> {
        %self = new_struct : !zkir.struct<@one::@good>
        return %self : !zkir.struct<@one::@good>
      }
      func @constrain(%self: !zkir.struct<@one::@good>) {
        return
      }
    }
  }
  module @two {
    zkir.struct @good {
      // expected-error@+1 {{'zkir.func' op "@compute" must use type of its parent 'zkir.struct' "@two::@good" as return type}}
      func @compute() -> !zkir.struct<@one::@good> {
        %self = new_struct : !zkir.struct<@one::@good>
        return %self : !zkir.struct<@one::@good>
      }
      func @constrain(%self: !zkir.struct<@one::@good>) {
        return
      }
    }
  }
}
// -----
module attributes {veridise.lang = "zkir"} {
  module { // expected-note {{unnamed 'builtin.module' here}}
    module @one {
      zkir.struct @good {
        // expected-error@+2 {{'zkir.func' op has ancestor 'builtin.module' without "veridise.lang" attribute or a name}}
        // expected-error@+1 {{could not find 'zkir.struct' named "@one::@good"}}
        func @compute() -> !zkir.struct<@one::@good> {
          %self = new_struct : !zkir.struct<@one::@good>
          return %self : !zkir.struct<@one::@good>
        }
        func @constrain(%self: !zkir.struct<@one::@good>) {
          return
        }
      }
    }
  }
}
// -----
module { // expected-note {{unnamed 'builtin.module' here}}
  // expected-error@+1 {{'zkir.struct' op has ancestor 'builtin.module' without "veridise.lang" attribute or a name}}
  zkir.struct @compute_with_wrong_ret {
    // expected-error@+1 {{'zkir.func' op "@compute" must use type of its parent 'zkir.struct' "@compute_with_wrong_ret" as return type}}
    func @compute() -> index {
      %b = index.constant 2
      return %b : index
    }

    func @constrain(%self: !zkir.struct<@compute_with_wrong_ret>) {
      return
    }
  }
}
// -----
module attributes {veridise.lang = "zkir"} {
  zkir.struct @constrain_without_args {
    func @compute() -> !zkir.struct<@constrain_without_args> {
      %self = new_struct : !zkir.struct<@constrain_without_args>
      return %self : !zkir.struct<@constrain_without_args>
    }
    // expected-error@+1 {{'zkir.func' op "@constrain" must have at least one input type}}
    func @constrain() { return }
  }
}
