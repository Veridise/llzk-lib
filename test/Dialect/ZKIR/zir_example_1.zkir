// RUN: zkir-opt -split-input-file %s 2>&1 | FileCheck %s

module attributes {veridise.lang = "zkir"} {

  /////////////////////////////////////////////////////////////////////////////////////////////
  // BEGIN: This section should be removed once implemented properly. It is tested elsewhere.
  // Pre-defined structs to import in all files generated by zirgen frontend
  module @risc0 {
    zkir.struct @ValU32 {
      field @low : !zkir.felt
      field @high : !zkir.felt
      func @compute(%low: !zkir.felt, %high: !zkir.felt) -> !zkir.struct<@risc0::@ValU32> {
        %self = new_struct : !zkir.struct<@risc0::@ValU32>
        writef %self[@low] = %low : !zkir.struct<@risc0::@ValU32>, !zkir.felt
        writef %self[@high] = %high : !zkir.struct<@risc0::@ValU32>, !zkir.felt
        return %self : !zkir.struct<@risc0::@ValU32>
      }
      func @constrain(%self: !zkir.struct<@risc0::@ValU32>, %low: !zkir.felt, %high: !zkir.felt) {
        return
      }
    }
    zkir.struct @Reg {
      field @reg : !zkir.felt {zkir.pub}
      func @compute(%v: !zkir.felt) -> !zkir.struct<@risc0::@Reg> {
        %self = new_struct : !zkir.struct<@risc0::@Reg>
        writef %self[@reg] = %v : !zkir.struct<@risc0::@Reg>, !zkir.felt
        return %self : !zkir.struct<@risc0::@Reg>
      }
      func @constrain(%self: !zkir.struct<@risc0::@Reg>, %v: !zkir.felt) {
        %0 = readf %self[@reg] : !zkir.struct<@risc0::@Reg>, !zkir.felt
        emit_eq %v, %0 : !zkir.felt
        return
      }
    }
  }
  // END: This section should be removed once implemented properly. It is tested elsewhere.
  /////////////////////////////////////////////////////////////////////////////////////////////

  zkir.struct @C1 {
    field @z : !zkir.struct<@risc0::@Reg> {zkir.pub}

    func @compute(%x: !zkir.felt, %y: !zkir.felt) -> !zkir.struct<@C1> {
      %self = new_struct : !zkir.struct<@C1>
      %add_0 = add %x, %y
      %reg_0 = call @risc0::@Reg::@compute(%add_0) : (!zkir.felt) -> (!zkir.struct<@risc0::@Reg>)
      writef %self[@z] = %reg_0 : !zkir.struct<@C1>, !zkir.struct<@risc0::@Reg>
      return %self: !zkir.struct<@C1>
    }

    func @constrain(%self: !zkir.struct<@C1>, %x: !zkir.felt, %y: !zkir.felt) {
      %reg_0 = readf %self[@z] : !zkir.struct<@C1>, !zkir.struct<@risc0::@Reg>
      %add_0 = add %x, %y
      call @risc0::@Reg::@constrain(%reg_0, %add_0) : (!zkir.struct<@risc0::@Reg>, !zkir.felt) -> ()
      return
    }
  }

  zkir.struct @C2 {
    field @fc1 : !zkir.struct<@C1>

    func @compute(%x: !zkir.struct<@risc0::@ValU32>) -> !zkir.struct<@C2> {
      %self = new_struct : !zkir.struct<@C2>
      %t1 = readf %x[@low] : !zkir.struct<@risc0::@ValU32>, !zkir.felt
      %t2 = readf %x[@high] : !zkir.struct<@risc0::@ValU32>, !zkir.felt
      %t0 = call @C1::@compute(%t1, %t2) : (!zkir.felt, !zkir.felt) -> (!zkir.struct<@C1>)
      writef %self[@fc1] = %t0 : !zkir.struct<@C2>, !zkir.struct<@C1>
      //
      return %self: !zkir.struct<@C2>
    }

    func @constrain(%self: !zkir.struct<@C2>, %x: !zkir.struct<@risc0::@ValU32>) {
      // c1.constrain(x.low, x.high)
      %t0 = readf %self[@fc1] : !zkir.struct<@C2>, !zkir.struct<@C1>
      %t1 = readf %x[@low] : !zkir.struct<@risc0::@ValU32>, !zkir.felt
      %t2 = readf %x[@high] : !zkir.struct<@risc0::@ValU32>, !zkir.felt
      call @C1::@constrain(%t0, %t1, %t2) : (!zkir.struct<@C1>, !zkir.felt, !zkir.felt) -> ()
      // emit c1.z.reg = 0
      %t3 = readf %t0[@z] : !zkir.struct<@C1>, !zkir.struct<@risc0::@Reg>
      %t4 = readf %t3[@reg] : !zkir.struct<@risc0::@Reg>, !zkir.felt
      %zero = constfelt 0
      emit_eq %t4, %zero : !zkir.felt
      //
      return
    }
  }
}

//CHECK-LABEL: module attributes {veridise.lang = "zkir"} {
//CHECK-NEXT:    module @risc0 {
//CHECK-NEXT:      zkir.struct @ValU32 {
//CHECK-NEXT:        field @low : !zkir.felt
//CHECK-NEXT:        field @high : !zkir.felt
//CHECK-NEXT:        func @compute(%[[A0:[0-9a-zA-Z_\.]+]]: !zkir.felt, %[[A1:[0-9a-zA-Z_\.]+]]: !zkir.felt) -> !zkir.struct<@risc0::@ValU32> {
//CHECK-NEXT:          %[[SELF:[0-9a-zA-Z_\.]+]] = new_struct : <@risc0::@ValU32>
//CHECK-NEXT:          writef %[[SELF]][@low] = %[[A0]] : <@risc0::@ValU32>, !zkir.felt
//CHECK-NEXT:          writef %[[SELF]][@high] = %[[A1]] : <@risc0::@ValU32>, !zkir.felt
//CHECK-NEXT:          return %[[SELF]] : !zkir.struct<@risc0::@ValU32>
//CHECK-NEXT:        }
//CHECK-NEXT:        func @constrain(%[[SELF:[0-9a-zA-Z_\.]+]]: !zkir.struct<@risc0::@ValU32>,
//CHECK-SAME:        %[[A1:[0-9a-zA-Z_\.]+]]: !zkir.felt, %[[A2:[0-9a-zA-Z_\.]+]]: !zkir.felt) {
//CHECK-NEXT:          return
//CHECK-NEXT:        }
//CHECK-NEXT:      }
//CHECK-NEXT:      zkir.struct @Reg {
//CHECK-NEXT:        field @reg : !zkir.felt {zkir.pub}
//CHECK-NEXT:        func @compute(%[[A0:[0-9a-zA-Z_\.]+]]: !zkir.felt) -> !zkir.struct<@risc0::@Reg> {
//CHECK-NEXT:          %[[SELF:[0-9a-zA-Z_\.]+]] = new_struct : <@risc0::@Reg>
//CHECK-NEXT:          writef %[[SELF]][@reg] = %[[A0]] : <@risc0::@Reg>, !zkir.felt
//CHECK-NEXT:          return %[[SELF]] : !zkir.struct<@risc0::@Reg>
//CHECK-NEXT:        }
//CHECK-NEXT:        func @constrain(%[[SELF:[0-9a-zA-Z_\.]+]]: !zkir.struct<@risc0::@Reg>, %[[A1:[0-9a-zA-Z_\.]+]]: !zkir.felt) {
//CHECK-NEXT:          %[[T0:[0-9a-zA-Z_\.]+]] = readf %[[SELF]][@reg] : <@risc0::@Reg>, !zkir.felt
//CHECK-NEXT:          emit_eq %[[A1]], %[[T0]] : !zkir.felt
//CHECK-NEXT:          return
//CHECK-NEXT:        }
//CHECK-NEXT:      }
//CHECK-NEXT:    }
//CHECK-NEXT:    zkir.struct @C1 {
//CHECK-NEXT:      field @z : !zkir.struct<@risc0::@Reg> {zkir.pub}
//CHECK-NEXT:      func @compute(%arg0: !zkir.felt, %arg1: !zkir.felt) -> !zkir.struct<@C1> {
//CHECK-NEXT:        %[[SELF:[0-9a-zA-Z_\.]+]] = new_struct : <@C1>
//CHECK-NEXT:        %[[T0:[0-9a-zA-Z_\.]+]] = add %arg0, %arg1
//CHECK-NEXT:        %[[T1:[0-9a-zA-Z_\.]+]] = call @risc0::@Reg::@compute(%[[T0]]) : (!zkir.felt) -> !zkir.struct<@risc0::@Reg>
//CHECK-NEXT:        writef %[[SELF]][@z] = %[[T1]] : <@C1>, !zkir.struct<@risc0::@Reg>
//CHECK-NEXT:        return %[[SELF]] : !zkir.struct<@C1>
//CHECK-NEXT:      }
//CHECK-NEXT:      func @constrain(%[[SELF:[0-9a-zA-Z_\.]+]]: !zkir.struct<@C1>, %arg1: !zkir.felt, %arg2: !zkir.felt) {
//CHECK-NEXT:        %[[T0:[0-9a-zA-Z_\.]+]] = readf %[[SELF]][@z] : <@C1>, !zkir.struct<@risc0::@Reg>
//CHECK-NEXT:        %[[T1:[0-9a-zA-Z_\.]+]] = add %arg1, %arg2
//CHECK-NEXT:        call @risc0::@Reg::@constrain(%[[T0]], %[[T1]]) : (!zkir.struct<@risc0::@Reg>, !zkir.felt) -> ()
//CHECK-NEXT:        return
//CHECK-NEXT:      }
//CHECK-NEXT:    }
//CHECK-NEXT:    zkir.struct @C2 {
//CHECK-NEXT:      field @fc1 : !zkir.struct<@C1>
//CHECK-NEXT:      func @compute(%arg0: !zkir.struct<@risc0::@ValU32>) -> !zkir.struct<@C2> {
//CHECK-NEXT:        %[[SELF:[0-9a-zA-Z_\.]+]] = new_struct : <@C2>
//CHECK-NEXT:        %[[T0:[0-9a-zA-Z_\.]+]] = readf %arg0[@low] : <@risc0::@ValU32>, !zkir.felt
//CHECK-NEXT:        %[[T1:[0-9a-zA-Z_\.]+]] = readf %arg0[@high] : <@risc0::@ValU32>, !zkir.felt
//CHECK-NEXT:        %[[T2:[0-9a-zA-Z_\.]+]] = call @C1::@compute(%[[T0]], %[[T1]]) : (!zkir.felt, !zkir.felt) -> !zkir.struct<@C1>
//CHECK-NEXT:        writef %[[SELF]][@fc1] = %[[T2]] : <@C2>, !zkir.struct<@C1>
//CHECK-NEXT:        return %[[SELF]] : !zkir.struct<@C2>
//CHECK-NEXT:      }
//CHECK-NEXT:      func @constrain(%[[SELF:[0-9a-zA-Z_\.]+]]: !zkir.struct<@C2>, %arg1: !zkir.struct<@risc0::@ValU32>) {
//CHECK-NEXT:        %[[T0:[0-9a-zA-Z_\.]+]] = readf %[[SELF]][@fc1] : <@C2>, !zkir.struct<@C1>
//CHECK-NEXT:        %[[T1:[0-9a-zA-Z_\.]+]] = readf %arg1[@low] : <@risc0::@ValU32>, !zkir.felt
//CHECK-NEXT:        %[[T2:[0-9a-zA-Z_\.]+]] = readf %arg1[@high] : <@risc0::@ValU32>, !zkir.felt
//CHECK-NEXT:        call @C1::@constrain(%[[T0]], %[[T1]], %[[T2]]) : (!zkir.struct<@C1>, !zkir.felt, !zkir.felt) -> ()
//CHECK-NEXT:        %[[T3:[0-9a-zA-Z_\.]+]] = readf %[[T0]][@z] : <@C1>, !zkir.struct<@risc0::@Reg>
//CHECK-NEXT:        %[[T4:[0-9a-zA-Z_\.]+]] = readf %[[T3]][@reg] : <@risc0::@Reg>, !zkir.felt
//CHECK-NEXT:        %felt_const_0 = constfelt  0
//CHECK-NEXT:        emit_eq %[[T4]], %felt_const_0 : !zkir.felt
//CHECK-NEXT:        return
//CHECK-NEXT:      }
//CHECK-NEXT:    }
//CHECK-NEXT:  }
