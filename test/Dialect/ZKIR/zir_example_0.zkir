// RUN: zkir-opt -split-input-file %s 2>&1 | FileCheck %s

// Pre-defined structs to import in all files generated by zirgen frontend
module attributes {veridise.lang = "zkir"} {
  module @risc0 {
    zkir.struct @ValU32 {
      field @low : !zkir.felt
      field @high : !zkir.felt

      func @compute(%low: !zkir.felt, %high: !zkir.felt) -> !zkir.struct<@risc0::@ValU32> {
        %self = new_struct : !zkir.struct<@risc0::@ValU32>
        writef %self[@low] = %low : !zkir.struct<@risc0::@ValU32>, !zkir.felt
        writef %self[@high] = %high : !zkir.struct<@risc0::@ValU32>, !zkir.felt
        return %self : !zkir.struct<@risc0::@ValU32>
      }

      func @constrain(%self: !zkir.struct<@risc0::@ValU32>, %low: !zkir.felt, %high: !zkir.felt) {
        return
      }
    }

    zkir.struct @Reg {
      // ZIR frontend should mark return value with `pub`
      field @reg : !zkir.felt {zkir.pub}

      func @compute(%v: !zkir.felt) -> !zkir.struct<@risc0::@Reg> {
        %self = new_struct : !zkir.struct<@risc0::@Reg>
        writef %self[@reg] = %v : !zkir.struct<@risc0::@Reg>, !zkir.felt
        return %self : !zkir.struct<@risc0::@Reg>
      }

      func @constrain(%self: !zkir.struct<@risc0::@Reg>, %v: !zkir.felt) {
        %0 = readf %self[@reg] : !zkir.struct<@risc0::@Reg>, !zkir.felt
        emit_eq %v, %0 : !zkir.felt
        return
      }
    }

    zkir.struct @Div {
      field @reciprocal : !zkir.felt
      // ZIR frontend should mark return value with `pub`
      field @synthetic_return : !zkir.felt {zkir.pub}

      func @compute(%lhs: !zkir.felt, %rhs: !zkir.felt) -> !zkir.struct<@risc0::@Div> {
        %self = new_struct : !zkir.struct<@risc0::@Div>
        // res_inv := inv(rhs);
        %res_inv = inv %rhs
        writef %self[@reciprocal] = %res_inv : !zkir.struct<@risc0::@Div>, !zkir.felt
        // self.synthetic_return := res_inv * lhs;
        %res_mul = mul %res_inv, %lhs
        writef %self[@synthetic_return] = %res_mul : !zkir.struct<@risc0::@Div>, !zkir.felt
        //
        return %self : !zkir.struct<@risc0::@Div>
      }

      func @constrain(%self: !zkir.struct<@risc0::@Div>, %lhs: !zkir.felt, %rhs: !zkir.felt) {
        // emit self.reciprocal * rhs = 1;
        %res_inv = readf %self[@reciprocal] : !zkir.struct<@risc0::@Div>, !zkir.felt
        %res_mul_1 = mul %res_inv, %rhs
        %const_1 = constfelt 1
        emit_eq %res_mul_1, %const_1 : !zkir.felt
        // emit self.synthetic_return = self.reciprocal * lhs;
        %res_self = readf %self[@synthetic_return] : !zkir.struct<@risc0::@Div>, !zkir.felt
        %res_mul_2 = mul %res_inv, %lhs
        emit_eq %res_self, %res_mul_2 : !zkir.felt
        //
        return
      }
    }
  }
}

//CHECK-LABEL: module attributes {veridise.lang = "zkir"} {
//CHECK-NEXT:    module @risc0 {
//CHECK-NEXT:      zkir.struct @ValU32 {
//CHECK-NEXT:        field @low : !zkir.felt
//CHECK-NEXT:        field @high : !zkir.felt
//CHECK-NEXT:        func @compute(%arg0: !zkir.felt, %arg1: !zkir.felt) -> !zkir.struct<@risc0::@ValU32> {
//CHECK-NEXT:          %self = new_struct : <@risc0::@ValU32>
//CHECK-NEXT:          writef %self[@low] = %arg0 : <@risc0::@ValU32>, !zkir.felt
//CHECK-NEXT:          writef %self[@high] = %arg1 : <@risc0::@ValU32>, !zkir.felt
//CHECK-NEXT:          return %self : !zkir.struct<@risc0::@ValU32>
//CHECK-NEXT:        }
//CHECK-NEXT:        func @constrain(%arg0: !zkir.struct<@risc0::@ValU32>, %arg1: !zkir.felt, %arg2: !zkir.felt) {
//CHECK-NEXT:          return
//CHECK-NEXT:        }
//CHECK-NEXT:      }
//CHECK-NEXT:      zkir.struct @Reg {
//CHECK-NEXT:        field @reg : !zkir.felt {zkir.pub}
//CHECK-NEXT:        func @compute(%arg0: !zkir.felt) -> !zkir.struct<@risc0::@Reg> {
//CHECK-NEXT:          %self = new_struct : <@risc0::@Reg>
//CHECK-NEXT:          writef %self[@reg] = %arg0 : <@risc0::@Reg>, !zkir.felt
//CHECK-NEXT:          return %self : !zkir.struct<@risc0::@Reg>
//CHECK-NEXT:        }
//CHECK-NEXT:        func @constrain(%arg0: !zkir.struct<@risc0::@Reg>, %arg1: !zkir.felt) {
//CHECK-NEXT:          %0 = readf %arg0[@reg] : <@risc0::@Reg>, !zkir.felt
//CHECK-NEXT:          emit_eq %arg1, %0 : !zkir.felt
//CHECK-NEXT:          return
//CHECK-NEXT:        }
//CHECK-NEXT:      }
//CHECK-NEXT:      zkir.struct @Div {
//CHECK-NEXT:        field @reciprocal : !zkir.felt
//CHECK-NEXT:        field @synthetic_return : !zkir.felt {zkir.pub}
//CHECK-NEXT:        func @compute(%arg0: !zkir.felt, %arg1: !zkir.felt) -> !zkir.struct<@risc0::@Div> {
//CHECK-NEXT:          %self = new_struct : <@risc0::@Div>
//CHECK-NEXT:          %0 = inv %arg1
//CHECK-NEXT:          writef %self[@reciprocal] = %0 : <@risc0::@Div>, !zkir.felt
//CHECK-NEXT:          %1 = mul %0, %arg0
//CHECK-NEXT:          writef %self[@synthetic_return] = %1 : <@risc0::@Div>, !zkir.felt
//CHECK-NEXT:          return %self : !zkir.struct<@risc0::@Div>
//CHECK-NEXT:        }
//CHECK-NEXT:        func @constrain(%arg0: !zkir.struct<@risc0::@Div>, %arg1: !zkir.felt, %arg2: !zkir.felt) {
//CHECK-NEXT:          %0 = readf %arg0[@reciprocal] : <@risc0::@Div>, !zkir.felt
//CHECK-NEXT:          %1 = mul %0, %arg2
//CHECK-NEXT:          %felt_const_1 = constfelt  1
//CHECK-NEXT:          emit_eq %1, %felt_const_1 : !zkir.felt
//CHECK-NEXT:          %2 = readf %arg0[@synthetic_return] : <@risc0::@Div>, !zkir.felt
//CHECK-NEXT:          %3 = mul %0, %arg1
//CHECK-NEXT:          emit_eq %2, %3 : !zkir.felt
//CHECK-NEXT:          return
//CHECK-NEXT:        }
//CHECK-NEXT:      }
//CHECK-NEXT:    }
//CHECK-NEXT:  }
