// RUN: zkir-opt -split-input-file %s 2>&1 | FileCheck %s

module attributes {veridise.lang = "zkir"} {
  /////////////////////////////////////////////////////////////////////////////////////////////
  // BEGIN: This section should be removed once implemented properly. It is tested elsewhere.
  // Pre-defined structs to import in all files generated by zirgen frontend
  module @risc0 {
    zkir.struct @ValU32 {
      field @low : !zkir.felt
      field @high : !zkir.felt

      func @compute(%low: !zkir.felt, %high: !zkir.felt) -> !zkir.struct<@risc0::@ValU32> {
        %self = new_struct : !zkir.struct<@risc0::@ValU32>
        writef %self[@low] = %low : !zkir.struct<@risc0::@ValU32>, !zkir.felt
        writef %self[@high] = %high : !zkir.struct<@risc0::@ValU32>, !zkir.felt
        return %self : !zkir.struct<@risc0::@ValU32>
      }

      func @constrain(%self: !zkir.struct<@risc0::@ValU32>, %low: !zkir.felt, %high: !zkir.felt) {
        return
      }
    }

    zkir.struct @Reg {
      // ZIR frontend should mark return value with `pub`
      field @reg : !zkir.felt {zkir.pub}

      func @compute(%v: !zkir.felt) -> !zkir.struct<@risc0::@Reg> {
        %self = new_struct : !zkir.struct<@risc0::@Reg>
        writef %self[@reg] = %v : !zkir.struct<@risc0::@Reg>, !zkir.felt
        return %self : !zkir.struct<@risc0::@Reg>
      }

      func @constrain(%self: !zkir.struct<@risc0::@Reg>, %v: !zkir.felt) {
        %0 = readf %self[@reg] : !zkir.struct<@risc0::@Reg>, !zkir.felt
        emit_eq %v, %0 : !zkir.felt
        return
      }
    }

    zkir.struct @Div {
      field @reciprocal : !zkir.felt
      // ZIR frontend should mark return value with `pub`
      field @synthetic_return : !zkir.felt {zkir.pub}

      func @compute(%lhs: !zkir.felt, %rhs: !zkir.felt) -> !zkir.struct<@risc0::@Div> {
        %self = new_struct : !zkir.struct<@risc0::@Div>
        // res_inv := inv(rhs);
        %res_inv = inv %rhs
        writef %self[@reciprocal] = %res_inv : !zkir.struct<@risc0::@Div>, !zkir.felt
        // self.synthetic_return := res_inv * lhs;
        %res_mul = mul %res_inv, %lhs
        writef %self[@synthetic_return] = %res_mul : !zkir.struct<@risc0::@Div>, !zkir.felt
        //
        return %self : !zkir.struct<@risc0::@Div>
      }

      func @constrain(%self: !zkir.struct<@risc0::@Div>, %lhs: !zkir.felt, %rhs: !zkir.felt) {
        // emit self.reciprocal * rhs = 1;
        %res_inv = readf %self[@reciprocal] : !zkir.struct<@risc0::@Div>, !zkir.felt
        %res_mul_1 = mul %res_inv, %rhs
        %const_1 = constfelt 1
        emit_eq %res_mul_1, %const_1 : !zkir.felt
        // emit self.synthetic_return = self.reciprocal * lhs;
        %res_self = readf %self[@synthetic_return] : !zkir.struct<@risc0::@Div>, !zkir.felt
        %res_mul_2 = mul %res_inv, %lhs
        emit_eq %res_self, %res_mul_2 : !zkir.felt
        //
        return
      }
    }
  }
  // END: This section should be removed once implemented properly. It is tested elsewhere.
  /////////////////////////////////////////////////////////////////////////////////////////////

  zkir.func private @LookupDelta(%table: !zkir.felt, %index: !zkir.felt, %count: !zkir.felt)

  // Since Zir functions can generate constraints but ZKIR functions cannot,
  //  the AssertBit function must be translated as a struct.
  zkir.struct @AssertBit {
    func @compute(%val: !zkir.felt) -> !zkir.struct<@AssertBit> {
      %self = new_struct : !zkir.struct<@AssertBit>
      return %self: !zkir.struct<@AssertBit>
    }

    func @constrain(%self: !zkir.struct<@AssertBit>, %val: !zkir.felt) {
      %const_1 = constfelt 1
      %t02 = sub %const_1, %val
      %t03 = mul %t02, %val
      %const_0 = constfelt 0
      emit_eq %t03, %const_0 : !zkir.felt
      return
    }
  }

  zkir.struct @NondetBitReg {
    field @ab: !zkir.struct<@AssertBit>
    field @reg: !zkir.felt
    // The `synthetic_return` is added here for clarity and a more strictly one-to-one
    // translation but it would also be valid to just put the `pub` modifier on `addr`.
    // ZIR frontend should mark return value with `pub`
    field @synthetic_return: !zkir.felt {zkir.pub}
    
    func @compute(%val: !zkir.felt) -> !zkir.struct<@NondetBitReg> {
      %self = new_struct : !zkir.struct<@NondetBitReg>
      writef %self[@reg] = %val : !zkir.struct<@NondetBitReg>, !zkir.felt
      %t02 = call @AssertBit::@compute(%val) : (!zkir.felt) -> (!zkir.struct<@AssertBit>)
      writef %self[@ab] = %t02 : !zkir.struct<@NondetBitReg>, !zkir.struct<@AssertBit>
      writef %self[@synthetic_return] = %val : !zkir.struct<@NondetBitReg>, !zkir.felt
      return %self: !zkir.struct<@NondetBitReg>
    }

    func @constrain(%self: !zkir.struct<@NondetBitReg>, %val: !zkir.felt) {
      %t02 = readf %self[@ab] : !zkir.struct<@NondetBitReg>, !zkir.struct<@AssertBit>
      %t03 = readf %self[@reg] : !zkir.struct<@NondetBitReg>, !zkir.felt
      call @AssertBit::@constrain(%t02, %t03) : (!zkir.struct<@AssertBit>, !zkir.felt) -> ()
      // Must always constrain the synthetic return value in case
      // it's used in a constraint by an outer component.
      %t04 = readf %self[@synthetic_return] : !zkir.struct<@NondetBitReg>, !zkir.felt
      emit_eq %t04, %t03 : !zkir.felt
      return
    }
  }

  zkir.struct @ArgU16 {
    field @count: !zkir.felt
    field @val: !zkir.felt
    
    func @compute(%count: !zkir.felt, %val: !zkir.felt) -> !zkir.struct<@ArgU16> {
      %self = new_struct : !zkir.struct<@ArgU16>
      writef %self[@count] = %count : !zkir.struct<@ArgU16>, !zkir.felt
      writef %self[@val] = %val : !zkir.struct<@ArgU16>, !zkir.felt
      %const_16 = constfelt 16
      call @LookupDelta(%const_16, %val, %count) : (!zkir.felt, !zkir.felt, !zkir.felt) -> ()
      return %self: !zkir.struct<@ArgU16>
    }

    func @constrain(%self: !zkir.struct<@ArgU16>, %count: !zkir.felt, %val: !zkir.felt) {
      return
    }
  }

  zkir.struct @NondetU16Reg {
    field @arg: !zkir.struct<@ArgU16>
    // ZIR frontend should mark return value with `pub`
    field @synthetic_return : !zkir.felt {zkir.pub}
    
    func @compute(%val: !zkir.felt) -> !zkir.struct<@NondetU16Reg> {
      %self = new_struct : !zkir.struct<@NondetU16Reg>
      %const_1 = constfelt 1
      %t02 = call @ArgU16::@compute(%const_1, %val) : (!zkir.felt, !zkir.felt) ->(!zkir.struct<@ArgU16>)
      writef %self[@arg] = %t02 : !zkir.struct<@NondetU16Reg>, !zkir.struct<@ArgU16>
      %t03 = readf %t02[@val] : !zkir.struct<@ArgU16>, !zkir.felt
      writef %self[@synthetic_return] = %t03 : !zkir.struct<@NondetU16Reg>, !zkir.felt
      return %self: !zkir.struct<@NondetU16Reg>
    }

    func @constrain(%self: !zkir.struct<@NondetU16Reg>, %val: !zkir.felt) {
      %const_1 = constfelt 1
      %t02 = readf %self[@arg] : !zkir.struct<@NondetU16Reg>, !zkir.struct<@ArgU16>
      call @ArgU16::@constrain(%t02, %const_1, %val) : (!zkir.struct<@ArgU16>, !zkir.felt, !zkir.felt) ->()
      %t03 = readf %t02[@count] : !zkir.struct<@ArgU16>, !zkir.felt
      emit_eq %const_1, %t03 : !zkir.felt
      // Must always constrain the synthetic return value in case
      // it's used in a constraint by an outer component.
      %t04 = readf %t02[@val] : !zkir.struct<@ArgU16>, !zkir.felt
      %t05 = readf %self[@synthetic_return] : !zkir.struct<@NondetU16Reg>, !zkir.felt
      emit_eq %t05, %t04 : !zkir.felt
      return
    }
  }

  zkir.struct @U16Reg {
    field @ret: !zkir.struct<@NondetU16Reg>
    // ZIR frontend should mark return value with `pub`
    field @synthetic_return : !zkir.felt {zkir.pub}
    
    func @compute(%val: !zkir.felt) -> !zkir.struct<@U16Reg> {
      %self = new_struct : !zkir.struct<@U16Reg>
      %ret = call @NondetU16Reg::@compute(%val) : (!zkir.felt) -> (!zkir.struct<@NondetU16Reg>)
      writef %self[@ret] = %ret : !zkir.struct<@U16Reg>, !zkir.struct<@NondetU16Reg>
      writef %self[@synthetic_return] = %val : !zkir.struct<@U16Reg>, !zkir.felt
      return %self: !zkir.struct<@U16Reg>
    }

    func @constrain(%self: !zkir.struct<@U16Reg>, %val: !zkir.felt) {
      %ret = readf %self[@ret] : !zkir.struct<@U16Reg>, !zkir.struct<@NondetU16Reg>
      call @NondetU16Reg::@constrain(%ret, %val) : (!zkir.struct<@NondetU16Reg>, !zkir.felt) -> ()
      %t02 = readf %ret[@synthetic_return] : !zkir.struct<@NondetU16Reg>, !zkir.felt
      emit_eq %t02, %val : !zkir.felt
      // Must always constrain the synthetic return value in case
      // it's used in a constraint by an outer component.
      %t03 = readf %self[@synthetic_return] : !zkir.struct<@U16Reg>, !zkir.felt
      emit_eq %t03, %val : !zkir.felt
      return
    }
  }

  zkir.struct @AddrDecomposeBits {
    field @low0: !zkir.struct<@NondetBitReg>
    field @low1: !zkir.struct<@NondetBitReg>
    field @low2: !zkir.felt
    field @upperDiff: !zkir.struct<@U16Reg>
    field @med14: !zkir.struct<@NondetU16Reg>
    field @addr: !zkir.felt
    // The `synthetic_return` is added here for clarity and a more strictly one-to-one
    // translation but it would also be valid to just put the `pub` modifier on `addr`.
    // ZIR frontend should mark return value with `pub`
    field @synthetic_return: !zkir.felt {zkir.pub}

    func @compute(%x: !zkir.struct<@risc0::@ValU32>, %mode: !zkir.felt) -> !zkir.struct<@AddrDecomposeBits> {
      %self = new_struct : !zkir.struct<@AddrDecomposeBits>
      // low0 := NondetBitReg.compute(x.low & 0x1);
      %t01 = readf %x[@low] : !zkir.struct<@risc0::@ValU32>, !zkir.felt
      %const_0x1 = constfelt 0x1
      %t02 = and %t01, %const_0x1
      %low0 = call @NondetBitReg::@compute(%t02) : (!zkir.felt) -> !zkir.struct<@NondetBitReg>
      writef %self[@low0] = %low0 : !zkir.struct<@AddrDecomposeBits>, !zkir.struct<@NondetBitReg>
      // low1 := NondetBitReg.compute((x.low & 0x2) / 2);
      %t03 = readf %x[@low] : !zkir.struct<@risc0::@ValU32>, !zkir.felt
      %const_0x2 = constfelt 0x2
      %t04 = and %t03, %const_0x2
      %const_2 = constfelt 2
      %t05 = div %t04, %const_2
      %low1 = call @NondetBitReg::@compute(%t05) : (!zkir.felt) -> !zkir.struct<@NondetBitReg>
      writef %self[@low1] = %low1 : !zkir.struct<@AddrDecomposeBits>, !zkir.struct<@NondetBitReg>
      // low2 := low1.synthetic_return * 2 + low0.synthetic_return;
      %t06 = readf %low1[@synthetic_return] : !zkir.struct<@NondetBitReg>, !zkir.felt
      %t07 = mul %t06, %const_2
      %t08 = readf %low0[@synthetic_return] : !zkir.struct<@NondetBitReg>, !zkir.felt
      %low2 = add %t07, %t08
      writef %self[@low2] = %low2 : !zkir.struct<@AddrDecomposeBits>, !zkir.felt
      // upperDiff := U16Reg.compute(mode * 0xffff + (1 - mode) * 0xbfff - x.high);
      %const_0xffff = constfelt 0xffff
      %t09 = mul %mode, %const_0xffff   // mode * 0xffff
      %const_1 = constfelt 1
      %t10 = sub %const_1, %mode        // (1 - mode)
      %const_0xbfff = constfelt 0xbfff
      %t11 = mul %t10, %const_0xbfff    // (1 - mode) * 0xbfff
      %t12 = add %t11, %t09             // mode * 0xffff + (1 - mode) * 0xbfff
      %t13 = readf %x[@high] : !zkir.struct<@risc0::@ValU32>, !zkir.felt
      %t14 = sub %t12, %t13             // mode * 0xffff + (1 - mode) * 0xbfff - x.high
      %upperDiff = call @U16Reg::@compute(%t14) : (!zkir.felt) -> !zkir.struct<@U16Reg>
      writef %self[@upperDiff] = %upperDiff : !zkir.struct<@AddrDecomposeBits>, !zkir.struct<@U16Reg>
      // med14 := NondetU16Reg.compute((x.low - low2) / 4);
      %t15 = readf %x[@low] : !zkir.struct<@risc0::@ValU32>, !zkir.felt
      %t16 = sub %t15, %low2            // (x.low - low2)
      %const_4 = constfelt 4
      %t17 = div %t16, %const_4         // (x.low - low2) / 4
      %med14 = call @NondetU16Reg::@compute(%t17) : (!zkir.felt) -> !zkir.struct<@NondetU16Reg>
      writef %self[@med14] = %med14 : !zkir.struct<@AddrDecomposeBits>, !zkir.struct<@NondetU16Reg>
      // addr := 0x4000 * x.high + med14.synthetic_return;
      %const_0x4000 = constfelt 0x4000
      %t18 = readf %x[@high] : !zkir.struct<@risc0::@ValU32>, !zkir.felt
      %t19 = mul %const_0x4000, %t18    // 0x4000 * x.high
      %t20 = readf %med14[@synthetic_return] : !zkir.struct<@NondetU16Reg>, !zkir.felt
      %addr = add %t19, %t20            // 0x4000 * x.high + med14.synthetic_return
      writef %self[@addr] = %addr : !zkir.struct<@AddrDecomposeBits>, !zkir.felt
      // synthetic_return := addr;
      writef %self[@synthetic_return] = %addr : !zkir.struct<@AddrDecomposeBits>, !zkir.felt
      //
      return %self: !zkir.struct<@AddrDecomposeBits>
    }

    func @constrain(%self: !zkir.struct<@AddrDecomposeBits>, %x: !zkir.struct<@risc0::@ValU32>, %mode: !zkir.felt) {
      // low0.constrain(nondetFelt());
      %t01 = zkir.nondetfelt
      %low0 = readf %self[@low0] : !zkir.struct<@AddrDecomposeBits>, !zkir.struct<@NondetBitReg>
      call @NondetBitReg::@constrain(%low0, %t01) : (!zkir.struct<@NondetBitReg>, !zkir.felt) -> ()
      // low1.constrain(nondetFelt());
      %t03 = zkir.nondetfelt
      %low1 = readf %self[@low1] : !zkir.struct<@AddrDecomposeBits>, !zkir.struct<@NondetBitReg>
      call @NondetBitReg::@constrain(%low1, %t03) : (!zkir.struct<@NondetBitReg>, !zkir.felt) -> ()
      // emit low2 = low1.synthetic_return * 2 + low0.synthetic_return;
      %t05 = readf %self[@low2] : !zkir.struct<@AddrDecomposeBits>, !zkir.felt
      %t06 = readf %low1[@synthetic_return] : !zkir.struct<@NondetBitReg>, !zkir.felt
      %const_2 = constfelt 2
      %t07 = mul %t06, %const_2         // low1.synthetic_return * 2
      %t08 = readf %low0[@synthetic_return] : !zkir.struct<@NondetBitReg>, !zkir.felt
      %t04 = add %t07, %t08             // low1.synthetic_return * 2 + low0.synthetic_return
      emit_eq %t05, %t04 : !zkir.felt
      // upperDiff.constrain(mode * 0xffff + (1 - mode) * 0xbfff - x.high);
      %const_0xffff = constfelt 0xffff
      %t09 = mul %mode, %const_0xffff   // mode * 0xffff
      %const_1 = constfelt 1
      %t10 = sub %const_1, %mode        // (1 - mode)
      %const_0xbfff = constfelt 0xbfff
      %t11 = mul %t10, %const_0xbfff    // (1 - mode) * 0xbfff
      %t12 = add %t11, %t09             // mode * 0xffff + (1 - mode) * 0xbfff
      %t13 = readf %x[@high] : !zkir.struct<@risc0::@ValU32>, !zkir.felt
      %t14 = sub %t12, %t13             // mode * 0xffff + (1 - mode) * 0xbfff - x.high
      %upperDiff = readf %self[@upperDiff] : !zkir.struct<@AddrDecomposeBits>, !zkir.struct<@U16Reg>
      call @U16Reg::@constrain(%upperDiff, %t14) : (!zkir.struct<@U16Reg>, !zkir.felt) -> ()
      // med14.constrain((x.low - low2) / 4);
      %t15 = readf %x[@low] : !zkir.struct<@risc0::@ValU32>, !zkir.felt
      %t18 = readf %self[@low2] : !zkir.struct<@AddrDecomposeBits>, !zkir.felt
      %t16 = sub %t15, %t18             // (x.low - low2)
      %const_4 = constfelt 4
      %t17 = div %t16, %const_4         // (x.low - low2) / 4
      %med14 = readf %self[@med14] : !zkir.struct<@AddrDecomposeBits>, !zkir.struct<@NondetU16Reg>
      call @NondetU16Reg::@constrain(%med14, %t17) : (!zkir.struct<@NondetU16Reg>, !zkir.felt) -> ()
      // emit med14.synthetic_return * 4 + low2 = x.low;
      %t19 = readf %med14[@synthetic_return] : !zkir.struct<@NondetU16Reg>, !zkir.felt
      %t20 = mul %t19, %const_4         // med14.synthetic_return * 4
      %t21 = readf %self[@low2] : !zkir.struct<@AddrDecomposeBits>, !zkir.felt
      %t22 = add %t20, %t21             // med14.synthetic_return * 4 + low2
      %t23 = readf %x[@low] : !zkir.struct<@risc0::@ValU32>, !zkir.felt
      emit_eq %t22, %t23 : !zkir.felt
      // emit addr = 0x4000 * x.high + med14.synthetic_return;
      %t24 = readf %self[@addr] : !zkir.struct<@AddrDecomposeBits>, !zkir.felt
      %const_0x4000 = constfelt 0x4000
      %t25 = readf %x[@high] : !zkir.struct<@risc0::@ValU32>, !zkir.felt
      %t26 = mul %const_0x4000, %t25    // 0x4000 * x.high
      %t27 = readf %med14[@synthetic_return] : !zkir.struct<@NondetU16Reg>, !zkir.felt
      %t28 = add %t26, %t27             // 0x4000 * x.high + med14.synthetic_return
      emit_eq %t24, %t28 : !zkir.felt
      // Must always constrain the synthetic return value in case
      // it's used in a constraint by an outer component.
      // emit synthetic_return = addr;
      %t30 = readf %self[@synthetic_return] : !zkir.struct<@AddrDecomposeBits>, !zkir.felt
      %t31 = readf %self[@addr] : !zkir.struct<@AddrDecomposeBits>, !zkir.felt
      emit_eq %t30, %t31 : !zkir.felt
      return
    }
  }
}

//CHECK-LABEL: module attributes {veridise.lang = "zkir"} {
//CHECK-NEXT:    module @risc0 {
//CHECK-NEXT:      zkir.struct @ValU32 {
//CHECK-NEXT:        field @low : !zkir.felt
//CHECK-NEXT:        field @high : !zkir.felt
//CHECK-NEXT:        func @compute(%[[A0:[0-9a-zA-Z_\.]+]]: !zkir.felt, %[[A1:[0-9a-zA-Z_\.]+]]: !zkir.felt) -> !zkir.struct<@risc0::@ValU32> {
//CHECK-NEXT:          %[[SELF:[0-9a-zA-Z_\.]+]] = new_struct : <@risc0::@ValU32>
//CHECK-NEXT:          writef %[[SELF]][@low] = %[[A0]] : <@risc0::@ValU32>, !zkir.felt
//CHECK-NEXT:          writef %[[SELF]][@high] = %[[A1]] : <@risc0::@ValU32>, !zkir.felt
//CHECK-NEXT:          return %[[SELF]] : !zkir.struct<@risc0::@ValU32>
//CHECK-NEXT:        }
//CHECK-NEXT:        func @constrain(%[[SELF:[0-9a-zA-Z_\.]+]]: !zkir.struct<@risc0::@ValU32>,
//CHECK-SAME:        %[[A1:[0-9a-zA-Z_\.]+]]: !zkir.felt, %[[A2:[0-9a-zA-Z_\.]+]]: !zkir.felt) {
//CHECK-NEXT:          return
//CHECK-NEXT:        }
//CHECK-NEXT:      }
//CHECK-NEXT:      zkir.struct @Reg {
//CHECK-NEXT:        field @reg : !zkir.felt {zkir.pub}
//CHECK-NEXT:        func @compute(%[[A0:[0-9a-zA-Z_\.]+]]: !zkir.felt) -> !zkir.struct<@risc0::@Reg> {
//CHECK-NEXT:          %[[SELF:[0-9a-zA-Z_\.]+]] = new_struct : <@risc0::@Reg>
//CHECK-NEXT:          writef %[[SELF]][@reg] = %[[A0]] : <@risc0::@Reg>, !zkir.felt
//CHECK-NEXT:          return %[[SELF]] : !zkir.struct<@risc0::@Reg>
//CHECK-NEXT:        }
//CHECK-NEXT:        func @constrain(%[[SELF:[0-9a-zA-Z_\.]+]]: !zkir.struct<@risc0::@Reg>, %[[A1:[0-9a-zA-Z_\.]+]]: !zkir.felt) {
//CHECK-NEXT:          %[[T0:[0-9a-zA-Z_\.]+]] = readf %[[SELF]][@reg] : <@risc0::@Reg>, !zkir.felt
//CHECK-NEXT:          emit_eq %[[A1]], %[[T0]] : !zkir.felt
//CHECK-NEXT:          return
//CHECK-NEXT:        }
//CHECK-NEXT:      }
//CHECK-NEXT:      zkir.struct @Div {
//CHECK-NEXT:        field @reciprocal : !zkir.felt
//CHECK-NEXT:        field @synthetic_return : !zkir.felt {zkir.pub}
//CHECK-NEXT:        func @compute(%[[A0:[0-9a-zA-Z_\.]+]]: !zkir.felt, %[[A1:[0-9a-zA-Z_\.]+]]: !zkir.felt) -> !zkir.struct<@risc0::@Div> {
//CHECK-NEXT:          %[[SELF:[0-9a-zA-Z_\.]+]] = new_struct : <@risc0::@Div>
//CHECK-NEXT:          %[[T00:[0-9a-zA-Z_\.]+]] = inv %[[A1]]
//CHECK-NEXT:          writef %[[SELF]][@reciprocal] = %[[T00]] : <@risc0::@Div>, !zkir.felt
//CHECK-NEXT:          %[[T01:[0-9a-zA-Z_\.]+]] = mul %[[T00]], %[[A0]]
//CHECK-NEXT:          writef %[[SELF]][@synthetic_return] = %[[T01]] : <@risc0::@Div>, !zkir.felt
//CHECK-NEXT:          return %[[SELF]] : !zkir.struct<@risc0::@Div>
//CHECK-NEXT:        }
//CHECK-NEXT:        func @constrain(%[[SELF:[0-9a-zA-Z_\.]+]]: !zkir.struct<@risc0::@Div>,
//CHECK-SAME:        %[[A1:[0-9a-zA-Z_\.]+]]: !zkir.felt, %[[A2:[0-9a-zA-Z_\.]+]]: !zkir.felt) {
//CHECK-NEXT:          %[[T00:[0-9a-zA-Z_\.]+]] = readf %[[SELF]][@reciprocal] : <@risc0::@Div>, !zkir.felt
//CHECK-NEXT:          %[[T01:[0-9a-zA-Z_\.]+]] = mul %[[T00]], %[[A2]]
//CHECK-NEXT:          %[[C1:[0-9a-zA-Z_\.]+]] = constfelt  1
//CHECK-NEXT:          emit_eq %[[T01]], %[[C1]] : !zkir.felt
//CHECK-NEXT:          %[[T02:[0-9a-zA-Z_\.]+]] = readf %[[SELF]][@synthetic_return] : <@risc0::@Div>, !zkir.felt
//CHECK-NEXT:          %[[T03:[0-9a-zA-Z_\.]+]] = mul %[[T00]], %[[A1]]
//CHECK-NEXT:          emit_eq %[[T02]], %[[T03]] : !zkir.felt
//CHECK-NEXT:          return
//CHECK-NEXT:        }
//CHECK-NEXT:      }
//CHECK-NEXT:    }
//CHECK-NEXT:    zkir.func private @LookupDelta(!zkir.felt, !zkir.felt, !zkir.felt)
//CHECK-NEXT:    zkir.struct @AssertBit {
//CHECK-NEXT:      func @compute(%[[A0:[0-9a-zA-Z_\.]+]]: !zkir.felt) -> !zkir.struct<@AssertBit> {
//CHECK-NEXT:        %[[SELF:[0-9a-zA-Z_\.]+]] = new_struct : <@AssertBit>
//CHECK-NEXT:        return %[[SELF]] : !zkir.struct<@AssertBit>
//CHECK-NEXT:      }
//CHECK-NEXT:      func @constrain(%[[SELF:[0-9a-zA-Z_\.]+]]: !zkir.struct<@AssertBit>, %[[A1:[0-9a-zA-Z_\.]+]]: !zkir.felt) {
//CHECK-NEXT:        %[[C1:[0-9a-zA-Z_\.]+]] = constfelt  1
//CHECK-NEXT:        %[[T00:[0-9a-zA-Z_\.]+]] = sub %[[C1]], %[[A1]]
//CHECK-NEXT:        %[[T01:[0-9a-zA-Z_\.]+]] = mul %[[T00]], %[[A1]]
//CHECK-NEXT:        %[[C0:[0-9a-zA-Z_\.]+]] = constfelt  0
//CHECK-NEXT:        emit_eq %[[T01]], %[[C0]] : !zkir.felt
//CHECK-NEXT:        return
//CHECK-NEXT:      }
//CHECK-NEXT:    }
//CHECK-NEXT:    zkir.struct @NondetBitReg {
//CHECK-NEXT:      field @ab : !zkir.struct<@AssertBit>
//CHECK-NEXT:      field @reg : !zkir.felt
//CHECK-NEXT:      field @synthetic_return : !zkir.felt {zkir.pub}
//CHECK-NEXT:      func @compute(%[[A0:[0-9a-zA-Z_\.]+]]: !zkir.felt) -> !zkir.struct<@NondetBitReg> {
//CHECK-NEXT:        %[[SELF:[0-9a-zA-Z_\.]+]] = new_struct : <@NondetBitReg>
//CHECK-NEXT:        writef %[[SELF]][@reg] = %[[A0]] : <@NondetBitReg>, !zkir.felt
//CHECK-NEXT:        %[[T00:[0-9a-zA-Z_\.]+]] = call @AssertBit::@compute(%[[A0:[0-9a-zA-Z_\.]+]]) : (!zkir.felt) -> !zkir.struct<@AssertBit>
//CHECK-NEXT:        writef %[[SELF]][@ab] = %[[T00]] : <@NondetBitReg>, !zkir.struct<@AssertBit>
//CHECK-NEXT:        writef %[[SELF]][@synthetic_return] = %[[A0]] : <@NondetBitReg>, !zkir.felt
//CHECK-NEXT:        return %[[SELF]] : !zkir.struct<@NondetBitReg>
//CHECK-NEXT:      }
//CHECK-NEXT:      func @constrain(%[[SELF:[0-9a-zA-Z_\.]+]]: !zkir.struct<@NondetBitReg>, %[[A1:[0-9a-zA-Z_\.]+]]: !zkir.felt) {
//CHECK-NEXT:        %[[T00:[0-9a-zA-Z_\.]+]] = readf %[[SELF]][@ab] : <@NondetBitReg>, !zkir.struct<@AssertBit>
//CHECK-NEXT:        %[[T01:[0-9a-zA-Z_\.]+]] = readf %[[SELF]][@reg] : <@NondetBitReg>, !zkir.felt
//CHECK-NEXT:        call @AssertBit::@constrain(%[[T00]], %[[T01]]) : (!zkir.struct<@AssertBit>, !zkir.felt) -> ()
//CHECK-NEXT:        %[[T02:[0-9a-zA-Z_\.]+]] = readf %[[SELF]][@synthetic_return] : <@NondetBitReg>, !zkir.felt
//CHECK-NEXT:        emit_eq %[[T02]], %[[T01]] : !zkir.felt
//CHECK-NEXT:        return
//CHECK-NEXT:      }
//CHECK-NEXT:    }
//CHECK-NEXT:    zkir.struct @ArgU16 {
//CHECK-NEXT:      field @count : !zkir.felt
//CHECK-NEXT:      field @val : !zkir.felt
//CHECK-NEXT:      func @compute(%[[A0:[0-9a-zA-Z_\.]+]]: !zkir.felt, %[[A1:[0-9a-zA-Z_\.]+]]: !zkir.felt) -> !zkir.struct<@ArgU16> {
//CHECK-NEXT:        %[[SELF:[0-9a-zA-Z_\.]+]] = new_struct : <@ArgU16>
//CHECK-NEXT:        writef %[[SELF]][@count] = %[[A0]] : <@ArgU16>, !zkir.felt
//CHECK-NEXT:        writef %[[SELF]][@val] = %[[A1]] : <@ArgU16>, !zkir.felt
//CHECK-NEXT:        %[[C16:[0-9a-zA-Z_\.]+]] = constfelt  16
//CHECK-NEXT:        call @LookupDelta(%[[C16]], %[[A1]], %[[A0]]) : (!zkir.felt, !zkir.felt, !zkir.felt) -> ()
//CHECK-NEXT:        return %[[SELF]] : !zkir.struct<@ArgU16>
//CHECK-NEXT:      }
//CHECK-NEXT:      func @constrain(%[[SELF:[0-9a-zA-Z_\.]+]]: !zkir.struct<@ArgU16>,
//CHECK-SAME:      %[[A1:[0-9a-zA-Z_\.]+]]: !zkir.felt, %[[A2:[0-9a-zA-Z_\.]+]]: !zkir.felt) {
//CHECK-NEXT:        return
//CHECK-NEXT:      }
//CHECK-NEXT:    }
//CHECK-NEXT:    zkir.struct @NondetU16Reg {
//CHECK-NEXT:      field @arg : !zkir.struct<@ArgU16>
//CHECK-NEXT:      field @synthetic_return : !zkir.felt {zkir.pub}
//CHECK-NEXT:      func @compute(%[[A0:[0-9a-zA-Z_\.]+]]: !zkir.felt) -> !zkir.struct<@NondetU16Reg> {
//CHECK-NEXT:        %[[SELF:[0-9a-zA-Z_\.]+]] = new_struct : <@NondetU16Reg>
//CHECK-NEXT:        %[[C1:[0-9a-zA-Z_\.]+]] = constfelt  1
//CHECK-NEXT:        %[[T00:[0-9a-zA-Z_\.]+]] = call @ArgU16::@compute(%[[C1]], %[[A0]]) : (!zkir.felt, !zkir.felt) -> !zkir.struct<@ArgU16>
//CHECK-NEXT:        writef %[[SELF]][@arg] = %[[T00]] : <@NondetU16Reg>, !zkir.struct<@ArgU16>
//CHECK-NEXT:        %[[T01:[0-9a-zA-Z_\.]+]] = readf %[[T00]][@val] : <@ArgU16>, !zkir.felt
//CHECK-NEXT:        writef %[[SELF]][@synthetic_return] = %[[T01]] : <@NondetU16Reg>, !zkir.felt
//CHECK-NEXT:        return %[[SELF]] : !zkir.struct<@NondetU16Reg>
//CHECK-NEXT:      }
//CHECK-NEXT:      func @constrain(%[[SELF:[0-9a-zA-Z_\.]+]]: !zkir.struct<@NondetU16Reg>, %[[A1:[0-9a-zA-Z_\.]+]]: !zkir.felt) {
//CHECK-NEXT:        %[[C1:[0-9a-zA-Z_\.]+]] = constfelt  1
//CHECK-NEXT:        %[[T00:[0-9a-zA-Z_\.]+]] = readf %[[SELF]][@arg] : <@NondetU16Reg>, !zkir.struct<@ArgU16>
//CHECK-NEXT:        call @ArgU16::@constrain(%[[T00]], %[[C1]], %[[A1]]) : (!zkir.struct<@ArgU16>, !zkir.felt, !zkir.felt) -> ()
//CHECK-NEXT:        %[[T01:[0-9a-zA-Z_\.]+]] = readf %[[T00]][@count] : <@ArgU16>, !zkir.felt
//CHECK-NEXT:        emit_eq %[[C1]], %[[T01]] : !zkir.felt
//CHECK-NEXT:        %[[T02:[0-9a-zA-Z_\.]+]] = readf %[[T00]][@val] : <@ArgU16>, !zkir.felt
//CHECK-NEXT:        %[[T03:[0-9a-zA-Z_\.]+]] = readf %[[SELF]][@synthetic_return] : <@NondetU16Reg>, !zkir.felt
//CHECK-NEXT:        emit_eq %[[T03]], %[[T02]] : !zkir.felt
//CHECK-NEXT:        return
//CHECK-NEXT:      }
//CHECK-NEXT:    }
//CHECK-NEXT:    zkir.struct @U16Reg {
//CHECK-NEXT:      field @ret : !zkir.struct<@NondetU16Reg>
//CHECK-NEXT:      field @synthetic_return : !zkir.felt {zkir.pub}
//CHECK-NEXT:      func @compute(%[[A0:[0-9a-zA-Z_\.]+]]: !zkir.felt) -> !zkir.struct<@U16Reg> {
//CHECK-NEXT:        %[[SELF:[0-9a-zA-Z_\.]+]] = new_struct : <@U16Reg>
//CHECK-NEXT:        %[[T00:[0-9a-zA-Z_\.]+]] = call @NondetU16Reg::@compute(%[[A0:[0-9a-zA-Z_\.]+]]) : (!zkir.felt) -> !zkir.struct<@NondetU16Reg>
//CHECK-NEXT:        writef %[[SELF]][@ret] = %[[T00]] : <@U16Reg>, !zkir.struct<@NondetU16Reg>
//CHECK-NEXT:        writef %[[SELF]][@synthetic_return] = %[[A0]] : <@U16Reg>, !zkir.felt
//CHECK-NEXT:        return %[[SELF]] : !zkir.struct<@U16Reg>
//CHECK-NEXT:      }
//CHECK-NEXT:      func @constrain(%[[SELF:[0-9a-zA-Z_\.]+]]: !zkir.struct<@U16Reg>, %[[A1:[0-9a-zA-Z_\.]+]]: !zkir.felt) {
//CHECK-NEXT:        %[[T00:[0-9a-zA-Z_\.]+]] = readf %[[SELF]][@ret] : <@U16Reg>, !zkir.struct<@NondetU16Reg>
//CHECK-NEXT:        call @NondetU16Reg::@constrain(%[[T00]], %[[A1]]) : (!zkir.struct<@NondetU16Reg>, !zkir.felt) -> ()
//CHECK-NEXT:        %[[T01:[0-9a-zA-Z_\.]+]] = readf %[[T00]][@synthetic_return] : <@NondetU16Reg>, !zkir.felt
//CHECK-NEXT:        emit_eq %[[T01]], %[[A1]] : !zkir.felt
//CHECK-NEXT:        %[[T02:[0-9a-zA-Z_\.]+]] = readf %[[SELF]][@synthetic_return] : <@U16Reg>, !zkir.felt
//CHECK-NEXT:        emit_eq %[[T02]], %[[A1]] : !zkir.felt
//CHECK-NEXT:        return
//CHECK-NEXT:      }
//CHECK-NEXT:    }
//CHECK-NEXT:    zkir.struct @AddrDecomposeBits {
//CHECK-NEXT:      field @low0 : !zkir.struct<@NondetBitReg>
//CHECK-NEXT:      field @low1 : !zkir.struct<@NondetBitReg>
//CHECK-NEXT:      field @low2 : !zkir.felt
//CHECK-NEXT:      field @upperDiff : !zkir.struct<@U16Reg>
//CHECK-NEXT:      field @med14 : !zkir.struct<@NondetU16Reg>
//CHECK-NEXT:      field @addr : !zkir.felt
//CHECK-NEXT:      field @synthetic_return : !zkir.felt {zkir.pub}
//CHECK-NEXT:      func @compute(%[[A0:[0-9a-zA-Z_\.]+]]: !zkir.struct<@risc0::@ValU32>,
//CHECK-SAME:      %[[A1:[0-9a-zA-Z_\.]+]]: !zkir.felt) -> !zkir.struct<@AddrDecomposeBits> {
//CHECK-NEXT:        %[[SELF:[0-9a-zA-Z_\.]+]] = new_struct : <@AddrDecomposeBits>
//CHECK-NEXT:        %[[T00:[0-9a-zA-Z_\.]+]] = readf %[[A0]][@low] : <@risc0::@ValU32>, !zkir.felt
//CHECK-NEXT:        %[[C1:[0-9a-zA-Z_\.]+]] = constfelt  1
//CHECK-NEXT:        %[[T01:[0-9a-zA-Z_\.]+]] = and %[[T00]], %[[C1]]
//CHECK-NEXT:        %[[T02:[0-9a-zA-Z_\.]+]] = call @NondetBitReg::@compute(%[[T01]]) : (!zkir.felt) -> !zkir.struct<@NondetBitReg>
//CHECK-NEXT:        writef %[[SELF]][@low0] = %[[T02]] : <@AddrDecomposeBits>, !zkir.struct<@NondetBitReg>
//CHECK-NEXT:        %[[T03:[0-9a-zA-Z_\.]+]] = readf %[[A0]][@low] : <@risc0::@ValU32>, !zkir.felt
//CHECK-NEXT:        %[[C2:[0-9a-zA-Z_\.]+]] = constfelt  2
//CHECK-NEXT:        %[[T04:[0-9a-zA-Z_\.]+]] = and %[[T03]], %[[C2]]
//CHECK-NEXT:        %[[C2_0:[0-9a-zA-Z_\.]+]] = constfelt  2
//CHECK-NEXT:        %[[T05:[0-9a-zA-Z_\.]+]] = div %[[T04]], %[[C2_0]]
//CHECK-NEXT:        %[[T06:[0-9a-zA-Z_\.]+]] = call @NondetBitReg::@compute(%[[T05]]) : (!zkir.felt) -> !zkir.struct<@NondetBitReg>
//CHECK-NEXT:        writef %[[SELF]][@low1] = %[[T06]] : <@AddrDecomposeBits>, !zkir.struct<@NondetBitReg>
//CHECK-NEXT:        %[[T07:[0-9a-zA-Z_\.]+]] = readf %[[T06]][@synthetic_return] : <@NondetBitReg>, !zkir.felt
//CHECK-NEXT:        %[[T08:[0-9a-zA-Z_\.]+]] = mul %[[T07]], %[[C2_0]]
//CHECK-NEXT:        %[[T09:[0-9a-zA-Z_\.]+]] = readf %[[T02]][@synthetic_return] : <@NondetBitReg>, !zkir.felt
//CHECK-NEXT:        %[[T10:[0-9a-zA-Z_\.]+]] = add %[[T08]], %[[T09]]
//CHECK-NEXT:        writef %[[SELF]][@low2] = %[[T10]] : <@AddrDecomposeBits>, !zkir.felt
//CHECK-NEXT:        %[[C65535:[0-9a-zA-Z_\.]+]] = constfelt  65535
//CHECK-NEXT:        %[[T11:[0-9a-zA-Z_\.]+]] = mul %[[A1]], %[[C65535]]
//CHECK-NEXT:        %[[C1_1:[0-9a-zA-Z_\.]+]] = constfelt  1
//CHECK-NEXT:        %[[T12:[0-9a-zA-Z_\.]+]] = sub %[[C1_1]], %[[A1]]
//CHECK-NEXT:        %[[C49151:[0-9a-zA-Z_\.]+]] = constfelt  49151
//CHECK-NEXT:        %[[T13:[0-9a-zA-Z_\.]+]] = mul %[[T12]], %[[C49151]]
//CHECK-NEXT:        %[[T14:[0-9a-zA-Z_\.]+]] = add %[[T13]], %[[T11]]
//CHECK-NEXT:        %[[T15:[0-9a-zA-Z_\.]+]] = readf %[[A0]][@high] : <@risc0::@ValU32>, !zkir.felt
//CHECK-NEXT:        %[[T16:[0-9a-zA-Z_\.]+]] = sub %[[T14]], %[[T15]]
//CHECK-NEXT:        %[[T17:[0-9a-zA-Z_\.]+]] = call @U16Reg::@compute(%[[T16]]) : (!zkir.felt) -> !zkir.struct<@U16Reg>
//CHECK-NEXT:        writef %[[SELF]][@upperDiff] = %[[T17]] : <@AddrDecomposeBits>, !zkir.struct<@U16Reg>
//CHECK-NEXT:        %[[T18:[0-9a-zA-Z_\.]+]] = readf %[[A0]][@low] : <@risc0::@ValU32>, !zkir.felt
//CHECK-NEXT:        %[[T19:[0-9a-zA-Z_\.]+]] = sub %[[T18]], %[[T10]]
//CHECK-NEXT:        %[[C4:[0-9a-zA-Z_\.]+]] = constfelt  4
//CHECK-NEXT:        %[[T20:[0-9a-zA-Z_\.]+]] = div %[[T19]], %[[C4]]
//CHECK-NEXT:        %[[T21:[0-9a-zA-Z_\.]+]] = call @NondetU16Reg::@compute(%[[T20]]) : (!zkir.felt) -> !zkir.struct<@NondetU16Reg>
//CHECK-NEXT:        writef %[[SELF]][@med14] = %[[T21]] : <@AddrDecomposeBits>, !zkir.struct<@NondetU16Reg>
//CHECK-NEXT:        %[[C16384:[0-9a-zA-Z_\.]+]] = constfelt  16384
//CHECK-NEXT:        %[[T22:[0-9a-zA-Z_\.]+]] = readf %[[A0]][@high] : <@risc0::@ValU32>, !zkir.felt
//CHECK-NEXT:        %[[T23:[0-9a-zA-Z_\.]+]] = mul %[[C16384]], %[[T22]]
//CHECK-NEXT:        %[[T24:[0-9a-zA-Z_\.]+]] = readf %[[T21]][@synthetic_return] : <@NondetU16Reg>, !zkir.felt
//CHECK-NEXT:        %[[T25:[0-9a-zA-Z_\.]+]] = add %[[T23]], %[[T24]]
//CHECK-NEXT:        writef %[[SELF]][@addr] = %[[T25]] : <@AddrDecomposeBits>, !zkir.felt
//CHECK-NEXT:        writef %[[SELF]][@synthetic_return] = %[[T25]] : <@AddrDecomposeBits>, !zkir.felt
//CHECK-NEXT:        return %[[SELF]] : !zkir.struct<@AddrDecomposeBits>
//CHECK-NEXT:      }
//CHECK-NEXT:      func @constrain(%[[SELF:[0-9a-zA-Z_\.]+]]: !zkir.struct<@AddrDecomposeBits>,
//CHECK-SAME:      %[[A1:[0-9a-zA-Z_\.]+]]: !zkir.struct<@risc0::@ValU32>, %[[A2:[0-9a-zA-Z_\.]+]]: !zkir.felt) {
//CHECK-NEXT:        %[[TN0:[0-9a-zA-Z_\.]+]] = nondetfelt
//CHECK-NEXT:        %[[T00:[0-9a-zA-Z_\.]+]] = readf %[[SELF]][@low0] : <@AddrDecomposeBits>, !zkir.struct<@NondetBitReg>
//CHECK-NEXT:        call @NondetBitReg::@constrain(%[[T00]], %[[TN0]]) : (!zkir.struct<@NondetBitReg>, !zkir.felt) -> ()
//CHECK-NEXT:        %[[TN1:[0-9a-zA-Z_\.]+]] = nondetfelt
//CHECK-NEXT:        %[[T01:[0-9a-zA-Z_\.]+]] = readf %[[SELF]][@low1] : <@AddrDecomposeBits>, !zkir.struct<@NondetBitReg>
//CHECK-NEXT:        call @NondetBitReg::@constrain(%[[T01]], %[[TN1]]) : (!zkir.struct<@NondetBitReg>, !zkir.felt) -> ()
//CHECK-NEXT:        %[[T02:[0-9a-zA-Z_\.]+]] = readf %[[SELF]][@low2] : <@AddrDecomposeBits>, !zkir.felt
//CHECK-NEXT:        %[[T03:[0-9a-zA-Z_\.]+]] = readf %[[T01]][@synthetic_return] : <@NondetBitReg>, !zkir.felt
//CHECK-NEXT:        %[[C2:[0-9a-zA-Z_\.]+]] = constfelt  2
//CHECK-NEXT:        %[[T04:[0-9a-zA-Z_\.]+]] = mul %[[T03]], %[[C2]]
//CHECK-NEXT:        %[[T05:[0-9a-zA-Z_\.]+]] = readf %[[T00]][@synthetic_return] : <@NondetBitReg>, !zkir.felt
//CHECK-NEXT:        %[[T06:[0-9a-zA-Z_\.]+]] = add %[[T04]], %[[T05]]
//CHECK-NEXT:        emit_eq %[[T02]], %[[T06]] : !zkir.felt
//CHECK-NEXT:        %[[C65535:[0-9a-zA-Z_\.]+]] = constfelt  65535
//CHECK-NEXT:        %[[T07:[0-9a-zA-Z_\.]+]] = mul %[[A2]], %[[C65535]]
//CHECK-NEXT:        %[[C1:[0-9a-zA-Z_\.]+]] = constfelt  1
//CHECK-NEXT:        %[[T08:[0-9a-zA-Z_\.]+]] = sub %[[C1]], %[[A2]]
//CHECK-NEXT:        %[[C49151:[0-9a-zA-Z_\.]+]] = constfelt  49151
//CHECK-NEXT:        %[[T09:[0-9a-zA-Z_\.]+]] = mul %[[T08]], %[[C49151]]
//CHECK-NEXT:        %[[T10:[0-9a-zA-Z_\.]+]] = add %[[T09]], %[[T07]]
//CHECK-NEXT:        %[[T11:[0-9a-zA-Z_\.]+]] = readf %[[A1]][@high] : <@risc0::@ValU32>, !zkir.felt
//CHECK-NEXT:        %[[T12:[0-9a-zA-Z_\.]+]] = sub %[[T10]], %[[T11]]
//CHECK-NEXT:        %[[T13:[0-9a-zA-Z_\.]+]] = readf %[[SELF]][@upperDiff] : <@AddrDecomposeBits>, !zkir.struct<@U16Reg>
//CHECK-NEXT:        call @U16Reg::@constrain(%[[T13]], %[[T12]]) : (!zkir.struct<@U16Reg>, !zkir.felt) -> ()
//CHECK-NEXT:        %[[T14:[0-9a-zA-Z_\.]+]] = readf %[[A1]][@low] : <@risc0::@ValU32>, !zkir.felt
//CHECK-NEXT:        %[[T15:[0-9a-zA-Z_\.]+]] = readf %[[SELF]][@low2] : <@AddrDecomposeBits>, !zkir.felt
//CHECK-NEXT:        %[[T16:[0-9a-zA-Z_\.]+]] = sub %[[T14]], %[[T15]]
//CHECK-NEXT:        %[[C4:[0-9a-zA-Z_\.]+]] = constfelt  4
//CHECK-NEXT:        %[[T17:[0-9a-zA-Z_\.]+]] = div %[[T16]], %[[C4]]
//CHECK-NEXT:        %[[T18:[0-9a-zA-Z_\.]+]] = readf %[[SELF]][@med14] : <@AddrDecomposeBits>, !zkir.struct<@NondetU16Reg>
//CHECK-NEXT:        call @NondetU16Reg::@constrain(%[[T18]], %[[T17]]) : (!zkir.struct<@NondetU16Reg>, !zkir.felt) -> ()
//CHECK-NEXT:        %[[T19:[0-9a-zA-Z_\.]+]] = readf %[[T18]][@synthetic_return] : <@NondetU16Reg>, !zkir.felt
//CHECK-NEXT:        %[[T20:[0-9a-zA-Z_\.]+]] = mul %[[T19]], %[[C4]]
//CHECK-NEXT:        %[[T21:[0-9a-zA-Z_\.]+]] = readf %[[SELF]][@low2] : <@AddrDecomposeBits>, !zkir.felt
//CHECK-NEXT:        %[[T22:[0-9a-zA-Z_\.]+]] = add %[[T20]], %[[T21]]
//CHECK-NEXT:        %[[T23:[0-9a-zA-Z_\.]+]] = readf %[[A1]][@low] : <@risc0::@ValU32>, !zkir.felt
//CHECK-NEXT:        emit_eq %[[T22]], %[[T23]] : !zkir.felt
//CHECK-NEXT:        %[[T24:[0-9a-zA-Z_\.]+]] = readf %[[SELF]][@addr] : <@AddrDecomposeBits>, !zkir.felt
//CHECK-NEXT:        %[[C16384:[0-9a-zA-Z_\.]+]] = constfelt  16384
//CHECK-NEXT:        %[[T25:[0-9a-zA-Z_\.]+]] = readf %[[A1]][@high] : <@risc0::@ValU32>, !zkir.felt
//CHECK-NEXT:        %[[T26:[0-9a-zA-Z_\.]+]] = mul %[[C16384]], %[[T25]]
//CHECK-NEXT:        %[[T27:[0-9a-zA-Z_\.]+]] = readf %[[T18]][@synthetic_return] : <@NondetU16Reg>, !zkir.felt
//CHECK-NEXT:        %[[T28:[0-9a-zA-Z_\.]+]] = add %[[T26]], %[[T27]]
//CHECK-NEXT:        emit_eq %[[T24]], %[[T28]] : !zkir.felt
//CHECK-NEXT:        %[[T29:[0-9a-zA-Z_\.]+]] = readf %[[SELF]][@synthetic_return] : <@AddrDecomposeBits>, !zkir.felt
//CHECK-NEXT:        %[[T30:[0-9a-zA-Z_\.]+]] = readf %[[SELF]][@addr] : <@AddrDecomposeBits>, !zkir.felt
//CHECK-NEXT:        emit_eq %[[T29]], %[[T30]] : !zkir.felt
//CHECK-NEXT:        return
//CHECK-NEXT:      }
//CHECK-NEXT:    }
//CHECK-NEXT:  }
