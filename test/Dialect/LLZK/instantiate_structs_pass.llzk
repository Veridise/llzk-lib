// RUN: llzk-opt -I %S -split-input-file -llzk-instantiate-structs %s 2>&1 | FileCheck %s

/// Test calling a global function named "compute"; should have no change
module attributes {veridise.lang = "llzk"} {
  llzk.func @compute(%x: i1) -> i1 {
    return %x : i1
  }
  llzk.func @global_caller(%a: i1, %b: i1) -> i1 {
    %1 = llzk.call @compute(%a) : (i1) -> i1
    return %1 : i1
  }
  llzk.struct @StructCaller {
    func @compute(%a: i1) -> !llzk.struct<@StructCaller> {
      %self = new_struct : !llzk.struct<@StructCaller>
      %1 = llzk.call @compute(%a) : (i1) -> i1
      return %self : !llzk.struct<@StructCaller>
    }
    func @constrain(%self: !llzk.struct<@StructCaller>, %a: i1) {
      return
    }
  }
}
// CHECK-LABEL: llzk.func @compute(
// CHECK-SAME:                     %[[VAL_0:[0-9a-zA-Z_\.]+]]: i1) -> i1 {
// CHECK-NEXT:    return %[[VAL_0]] : i1
// CHECK-NEXT:  }
//
// CHECK-LABEL: llzk.func @global_caller(
// CHECK-SAME:                           %[[VAL_0:[0-9a-zA-Z_\.]+]]: i1,
// CHECK-SAME:                           %[[VAL_1:[0-9a-zA-Z_\.]+]]: i1) -> i1 {
// CHECK-NEXT:    %[[VAL_2:[0-9a-zA-Z_\.]+]] = call @compute(%[[VAL_0]]) : (i1) -> i1
// CHECK-NEXT:    return %[[VAL_2]] : i1
// CHECK-NEXT:  }
// -----

/// Test calling a struct "compute" without params; should have no change
module attributes {veridise.lang = "llzk"} {
  llzk.struct @StructA {
    func @compute() -> !llzk.struct<@StructA> {
      %self = new_struct : !llzk.struct<@StructA>
      return %self : !llzk.struct<@StructA>
    }
    func @constrain(%self: !llzk.struct<@StructA>) {
      return
    }
  }
  llzk.struct @StructCaller {
    func @compute() -> !llzk.struct<@StructCaller> {
      %self = new_struct : !llzk.struct<@StructCaller>
      %1 = llzk.call @StructA::@compute() : () -> !llzk.struct<@StructA>
      return %self : !llzk.struct<@StructCaller>
    }
    func @constrain(%self: !llzk.struct<@StructCaller>) {
      return
    }
  }
}
// CHECK-LABEL: llzk.struct @StructCaller {
// CHECK-NEXT:    func @compute(%[[VAL_0:[0-9a-zA-Z_\.]+]]: i1) -> !llzk.struct<@StructCaller> {
// CHECK-NEXT:      %[[VAL_1:[0-9a-zA-Z_\.]+]] = new_struct : <@StructCaller>
// CHECK-NEXT:      %[[VAL_2:[0-9a-zA-Z_\.]+]] = call @compute(%[[VAL_0]]) : (i1) -> i1
// CHECK-NEXT:      return %[[VAL_1]] : !llzk.struct<@StructCaller>
// CHECK-NEXT:    }
// CHECK-NEXT:    func @constrain(%[[VAL_3:[0-9a-zA-Z_\.]+]]: !llzk.struct<@StructCaller>, %[[VAL_4:[0-9a-zA-Z_\.]+]]: i1) {
// CHECK-NEXT:      return
// CHECK-NEXT:    }
// CHECK-NEXT:  }
//
// CHECK-LABEL: llzk.struct @StructA {
// CHECK-NEXT:    func @compute() -> !llzk.struct<@StructA> {
// CHECK-NEXT:      %[[VAL_0:[0-9a-zA-Z_\.]+]] = new_struct : <@StructA>
// CHECK-NEXT:      return %[[VAL_0]] : !llzk.struct<@StructA>
// CHECK-NEXT:    }
// CHECK-NEXT:    func @constrain(%[[VAL_1:[0-9a-zA-Z_\.]+]]: !llzk.struct<@StructA>) {
// CHECK-NEXT:      return
// CHECK-NEXT:    }
// CHECK-NEXT:  }
//
// CHECK-LABEL: llzk.struct @StructCaller {
// CHECK-NEXT:    func @compute() -> !llzk.struct<@StructCaller> {
// CHECK-NEXT:      %[[VAL_0:[0-9a-zA-Z_\.]+]] = new_struct : <@StructCaller>
// CHECK-NEXT:      %[[VAL_1:[0-9a-zA-Z_\.]+]] = call @StructA::@compute() : () -> !llzk.struct<@StructA>
// CHECK-NEXT:      return %[[VAL_0]] : !llzk.struct<@StructCaller>
// CHECK-NEXT:    }
// CHECK-NEXT:    func @constrain(%[[VAL_2:[0-9a-zA-Z_\.]+]]: !llzk.struct<@StructCaller>) {
// CHECK-NEXT:      return
// CHECK-NEXT:    }
// CHECK-NEXT:  }
// -----

module attributes {veridise.lang = "llzk"} {
  llzk.struct @ComponentA1<[@A, @B]> {
    func @compute() -> !llzk.struct<@ComponentA1<[@A, @B]>> {
      %self = new_struct : !llzk.struct<@ComponentA1<[@A, @B]>>
      return %self : !llzk.struct<@ComponentA1<[@A, @B]>>
    }
    func @constrain(%self: !llzk.struct<@ComponentA1<[@A, @B]>>) { return }
  }

  llzk.struct @ComponentA2<[@C]> {
    field @f2 : !llzk.struct<@ComponentA1<[5, @C]>>

    func @compute() -> !llzk.struct<@ComponentA2<[@C]>> {
      %self = new_struct : !llzk.struct<@ComponentA2<[@C]>>
      %x = call @ComponentA1::@compute() : () -> (!llzk.struct<@ComponentA1<[5, @C]>>)
      writef %self[@f2] = %x : !llzk.struct<@ComponentA2<[@C]>>, !llzk.struct<@ComponentA1<[5, @C]>>
      return %self : !llzk.struct<@ComponentA2<[@C]>>
    }

    func @constrain(%self: !llzk.struct<@ComponentA2<[@C]>>) {
      %b = readf %self[@f2] : !llzk.struct<@ComponentA2<[@C]>>, !llzk.struct<@ComponentA1<[5, @C]>>
      call @ComponentA1::@constrain(%b) : (!llzk.struct<@ComponentA1<[5, @C]>>) -> ()
      return
    }
  }

  llzk.struct @ComponentA3 {
    field @f3 : !llzk.struct<@ComponentA2<[43]>>

    func @compute() -> !llzk.struct<@ComponentA3> {
      %self = new_struct : !llzk.struct<@ComponentA3>
      %x = call @ComponentA2::@compute() : () -> (!llzk.struct<@ComponentA2<[43]>>)
      writef %self[@f3] = %x : !llzk.struct<@ComponentA3>, !llzk.struct<@ComponentA2<[43]>>
      return %self : !llzk.struct<@ComponentA3>
    }

    func @constrain(%self: !llzk.struct<@ComponentA3>) {
      %b = readf %self[@f3] : !llzk.struct<@ComponentA3>, !llzk.struct<@ComponentA2<[43]>>
      call @ComponentA2::@constrain(%b) : (!llzk.struct<@ComponentA2<[43]>>) -> ()
      return
    }
  }
}
// CHECK-LABEL: llzk.struct @"ComponentA1_5,43" {
// CHECK-NEXT:    func @compute() -> !llzk.struct<@"ComponentA1_5,43"> {
// CHECK-NEXT:      %[[VAL_0:[0-9a-zA-Z_\.]+]] = new_struct : <@"ComponentA1_5,43">
// CHECK-NEXT:      return %[[VAL_0]] : !llzk.struct<@"ComponentA1_5,43">
// CHECK-NEXT:    }
// CHECK-NEXT:    func @constrain(%[[VAL_1:[0-9a-zA-Z_\.]+]]: !llzk.struct<@"ComponentA1_5,43">) {
// CHECK-NEXT:      return
// CHECK-NEXT:    }
// CHECK-NEXT:  }
//
// CHECK-LABEL: llzk.struct @ComponentA2_43 {
// CHECK-NEXT:    field @f2 : !llzk.struct<@"ComponentA1_5,43">
// CHECK-NEXT:    func @compute() -> !llzk.struct<@ComponentA2_43> {
// CHECK-NEXT:      %[[VAL_0:[0-9a-zA-Z_\.]+]] = new_struct : <@ComponentA2_43>
// CHECK-NEXT:      %[[VAL_1:[0-9a-zA-Z_\.]+]] = call @"ComponentA1_5,43"::@compute() : () -> !llzk.struct<@"ComponentA1_5,43">
// CHECK-NEXT:      writef %[[VAL_0]][@f2] = %[[VAL_1]] : <@ComponentA2_43>, !llzk.struct<@"ComponentA1_5,43">
// CHECK-NEXT:      return %[[VAL_0]] : !llzk.struct<@ComponentA2_43>
// CHECK-NEXT:    }
// CHECK-NEXT:    func @constrain(%[[VAL_2:[0-9a-zA-Z_\.]+]]: !llzk.struct<@ComponentA2_43>) {
// CHECK-NEXT:      %[[VAL_3:[0-9a-zA-Z_\.]+]] = readf %[[VAL_2]][@f2] : <@ComponentA2_43>, !llzk.struct<@"ComponentA1_5,43">
// CHECK-NEXT:      call @"ComponentA1_5,43"::@constrain(%[[VAL_3]]) : (!llzk.struct<@"ComponentA1_5,43">) -> ()
// CHECK-NEXT:      return
// CHECK-NEXT:    }
// CHECK-NEXT:  }
//
// CHECK-LABEL: llzk.struct @ComponentA3 {
// CHECK-NEXT:    field @f3 : !llzk.struct<@ComponentA2_43>
// CHECK-NEXT:    func @compute() -> !llzk.struct<@ComponentA3> {
// CHECK-NEXT:      %[[VAL_0:[0-9a-zA-Z_\.]+]] = new_struct : <@ComponentA3>
// CHECK-NEXT:      %[[VAL_1:[0-9a-zA-Z_\.]+]] = call @ComponentA2_43::@compute() : () -> !llzk.struct<@ComponentA2_43>
// CHECK-NEXT:      writef %[[VAL_0]][@f3] = %[[VAL_1]] : <@ComponentA3>, !llzk.struct<@ComponentA2_43>
// CHECK-NEXT:      return %[[VAL_0]] : !llzk.struct<@ComponentA3>
// CHECK-NEXT:    }
// CHECK-NEXT:    func @constrain(%[[VAL_2:[0-9a-zA-Z_\.]+]]: !llzk.struct<@ComponentA3>) {
// CHECK-NEXT:      %[[VAL_3:[0-9a-zA-Z_\.]+]] = readf %[[VAL_2]][@f3] : <@ComponentA3>, !llzk.struct<@ComponentA2_43>
// CHECK-NEXT:      call @ComponentA2_43::@constrain(%[[VAL_3]]) : (!llzk.struct<@ComponentA2_43>) -> ()
// CHECK-NEXT:      return
// CHECK-NEXT:    }
// CHECK-NEXT:  }
// -----

// No change because there is no compute call that instantiates all of the parameters
module attributes {veridise.lang = "llzk"} {
  llzk.struct @ComponentB1<[@A]> {
    func @compute(%0: !llzk.felt) -> !llzk.struct<@ComponentB1<[@A]>> {
      %self = new_struct : !llzk.struct<@ComponentB1<[@A]>>
      return %self : !llzk.struct<@ComponentB1<[@A]>>
    }
    func @constrain(%self: !llzk.struct<@ComponentB1<[@A]>>, %0: !llzk.felt) {
      %1 = read_const @A : !llzk.felt
      emit_eq %0, %1 : !llzk.felt
      return
    }
  }
}
//CHECK-LABEL: module attributes {veridise.lang = "llzk"} {
//CHECK-NEXT:    llzk.struct @ComponentB1<[@A]> {
//CHECK-NEXT:      func @compute(%arg0: !llzk.felt) -> !llzk.struct<@ComponentB1<[@A]>> {
//CHECK-NEXT:        %[[SELF:[0-9a-zA-Z_\.]+]] = new_struct : <@ComponentB1<[@A]>>
//CHECK-NEXT:        return %[[SELF]] : !llzk.struct<@ComponentB1<[@A]>>
//CHECK-NEXT:      }
//CHECK-NEXT:      func @constrain(%arg0: !llzk.struct<@ComponentB1<[@A]>>, %arg1: !llzk.felt) {
//CHECK-NEXT:        %[[T0:[0-9a-zA-Z_\.]+]] = read_const @A : !llzk.felt
//CHECK-NEXT:        emit_eq %arg1, %[[T0]] : !llzk.felt, !llzk.felt
//CHECK-NEXT:        return
//CHECK-NEXT:      }
//CHECK-NEXT:    }
//CHECK-NEXT:  }
// -----

module attributes {veridise.lang = "llzk"} {
  module @a {
    llzk.struct @ComponentC1<[@Z]> {
      func @compute() -> !llzk.struct<@a::@ComponentC1<[@Z]>> {
        %self = new_struct : !llzk.struct<@a::@ComponentC1<[@Z]>>
        return %self : !llzk.struct<@a::@ComponentC1<[@Z]>>
      }
      func @constrain(%self: !llzk.struct<@a::@ComponentC1<[@Z]>>)  { return }
    }
  }

  module @b {
    llzk.struct @ComponentC2 {
      func @compute() -> !llzk.struct<@b::@ComponentC2> {
        %self = new_struct : !llzk.struct<@b::@ComponentC2>
        return %self : !llzk.struct<@b::@ComponentC2>
      }
      func @constrain(%self: !llzk.struct<@b::@ComponentC2>)  { return }
    }
  }

  llzk.func @fun1(%0: !llzk.struct<@b::@ComponentC2>) -> !llzk.struct<@b::@ComponentC2> {
    return %0 : !llzk.struct<@b::@ComponentC2>
  }

  llzk.func @fun2(%0: !llzk.struct<@a::@ComponentC1<[4]>>) -> !llzk.struct<@a::@ComponentC1<[4]>> {
    return %0 : !llzk.struct<@a::@ComponentC1<[4]>>
  }
}
// CHECK-LABEL: module @a {
// CHECK-NEXT:    llzk.struct @ComponentC1_4 {
// CHECK-NEXT:      func @compute() -> !llzk.struct<@a::@ComponentC1_4> {
// CHECK-NEXT:        %[[VAL_0:[0-9a-zA-Z_\.]+]] = new_struct : <@a::@ComponentC1_4>
// CHECK-NEXT:        return %[[VAL_0]] : !llzk.struct<@a::@ComponentC1_4>
// CHECK-NEXT:      }
// CHECK-NEXT:      func @constrain(%[[VAL_1:[0-9a-zA-Z_\.]+]]: !llzk.struct<@a::@ComponentC1_4>) {
// CHECK-NEXT:        return
// CHECK-NEXT:      }
// CHECK-NEXT:    }
// CHECK-NEXT:  }
//
// CHECK-LABEL: module @b {
// CHECK-NEXT:    llzk.struct @ComponentC2 {
// CHECK-NEXT:      func @compute() -> !llzk.struct<@b::@ComponentC2> {
// CHECK-NEXT:        %[[VAL_0:[0-9a-zA-Z_\.]+]] = new_struct : <@b::@ComponentC2>
// CHECK-NEXT:        return %[[VAL_0]] : !llzk.struct<@b::@ComponentC2>
// CHECK-NEXT:      }
// CHECK-NEXT:      func @constrain(%[[VAL_1:[0-9a-zA-Z_\.]+]]: !llzk.struct<@b::@ComponentC2>) {
// CHECK-NEXT:        return
// CHECK-NEXT:      }
// CHECK-NEXT:    }
// CHECK-NEXT:  }
//
// CHECK-LABEL: llzk.func @fun1(
// CHECK-SAME:                  %[[VAL_0:[0-9a-zA-Z_\.]+]]: !llzk.struct<@b::@ComponentC2>) -> !llzk.struct<@b::@ComponentC2> {
// CHECK-NEXT:    return %[[VAL_0]] : !llzk.struct<@b::@ComponentC2>
// CHECK-NEXT:  }
//
// CHECK-LABEL: llzk.func @fun2(
// CHECK-SAME:                  %[[VAL_0:[0-9a-zA-Z_\.]+]]: !llzk.struct<@a::@ComponentC1_4>) -> !llzk.struct<@a::@ComponentC1_4> {
// CHECK-NEXT:    return %[[VAL_0]] : !llzk.struct<@a::@ComponentC1_4>
// CHECK-NEXT:  }
// -----

module attributes {veridise.lang = "llzk"} {
  llzk.struct @ComponentD1<[@A]> {
    field @f : !llzk.array<@A,@A x index>

    func @compute(%0: !llzk.array<@A,@A x index>) -> !llzk.struct<@ComponentD1<[@A]>> {
      %self = new_struct : !llzk.struct<@ComponentD1<[@A]>>
      writef %self[@f] = %0 : !llzk.struct<@ComponentD1<[@A]>>, !llzk.array<@A,@A x index>
      return %self : !llzk.struct<@ComponentD1<[@A]>>
    }
    func @constrain(%self: !llzk.struct<@ComponentD1<[@A]>>, %0: !llzk.array<@A,@A x index>) {
      %b = readf %self[@f] : !llzk.struct<@ComponentD1<[@A]>>, !llzk.array<@A,@A x index>
      return
    }
  }

  llzk.func @producer() -> !llzk.array<2,2 x index> {
    %1 = index.constant 11
    %2 = index.constant 22
    %3 = index.constant 33
    %4 = index.constant 44
    %r = llzk.new_array %1, %2, %3, %4 : !llzk.array<2,2 x index>
    return %r: !llzk.array<2,2 x index>
  }

  llzk.struct @ComponentD2 {
    field @g : !llzk.struct<@ComponentD1<[2]>>

    func @compute() -> !llzk.struct<@ComponentD2> {
      %self = new_struct : !llzk.struct<@ComponentD2>
      %0 = call @producer() : () -> !llzk.array<2,2 x index>
      %1 = call @ComponentD1::@compute(%0) : (!llzk.array<2,2 x index>) -> !llzk.struct<@ComponentD1<[2]>>
      writef %self[@g] = %1 : !llzk.struct<@ComponentD2>, !llzk.struct<@ComponentD1<[2]>>
      return %self : !llzk.struct<@ComponentD2>
    }
    func @constrain(%self: !llzk.struct<@ComponentD2>) {
      return
    }
  }
}
// CHECK-LABEL: llzk.struct @ComponentD1_2 {
// CHECK-NEXT:    field @f : !llzk.array<2,2 x index>
// CHECK-NEXT:    func @compute(%[[VAL_0:[0-9a-zA-Z_\.]+]]: !llzk.array<2,2 x index>) -> !llzk.struct<@ComponentD1_2> {
// CHECK-NEXT:      %[[VAL_1:[0-9a-zA-Z_\.]+]] = new_struct : <@ComponentD1_2>
// CHECK-NEXT:      writef %[[VAL_1]][@f] = %[[VAL_0]] : <@ComponentD1_2>, !llzk.array<2,2 x index>
// CHECK-NEXT:      return %[[VAL_1]] : !llzk.struct<@ComponentD1_2>
// CHECK-NEXT:    }
// CHECK-NEXT:    func @constrain(%[[VAL_2:[0-9a-zA-Z_\.]+]]: !llzk.struct<@ComponentD1_2>, %[[VAL_3:[0-9a-zA-Z_\.]+]]: !llzk.array<2,2 x index>) {
// CHECK-NEXT:      %[[VAL_4:[0-9a-zA-Z_\.]+]] = readf %[[VAL_2]][@f] : <@ComponentD1_2>, !llzk.array<2,2 x index>
// CHECK-NEXT:      return
// CHECK-NEXT:    }
// CHECK-NEXT:  }
//
// CHECK-LABEL: llzk.func @producer() -> !llzk.array<2,2 x index> {
// CHECK-NEXT:    %[[VAL_0:[0-9a-zA-Z_\.]+]] = index.constant 11
// CHECK-NEXT:    %[[VAL_1:[0-9a-zA-Z_\.]+]] = index.constant 22
// CHECK-NEXT:    %[[VAL_2:[0-9a-zA-Z_\.]+]] = index.constant 33
// CHECK-NEXT:    %[[VAL_3:[0-9a-zA-Z_\.]+]] = index.constant 44
// CHECK-NEXT:    %[[VAL_4:[0-9a-zA-Z_\.]+]] = new_array %[[VAL_0]], %[[VAL_1]], %[[VAL_2]], %[[VAL_3]] : <2,2 x index>
// CHECK-NEXT:    return %[[VAL_4]] : !llzk.array<2,2 x index>
// CHECK-NEXT:  }
//
// CHECK-LABEL: llzk.struct @ComponentD2 {
// CHECK-NEXT:    field @g : !llzk.struct<@ComponentD1_2>
// CHECK-NEXT:    func @compute() -> !llzk.struct<@ComponentD2> {
// CHECK-NEXT:      %[[VAL_0:[0-9a-zA-Z_\.]+]] = new_struct : <@ComponentD2>
// CHECK-NEXT:      %[[VAL_1:[0-9a-zA-Z_\.]+]] = call @producer() : () -> !llzk.array<2,2 x index>
// CHECK-NEXT:      %[[VAL_2:[0-9a-zA-Z_\.]+]] = call @ComponentD1_2::@compute(%[[VAL_1]]) : (!llzk.array<2,2 x index>) -> !llzk.struct<@ComponentD1_2>
// CHECK-NEXT:      writef %[[VAL_0]][@g] = %[[VAL_2]] : <@ComponentD2>, !llzk.struct<@ComponentD1_2>
// CHECK-NEXT:      return %[[VAL_0]] : !llzk.struct<@ComponentD2>
// CHECK-NEXT:    }
// CHECK-NEXT:    func @constrain(%[[VAL_3:[0-9a-zA-Z_\.]+]]: !llzk.struct<@ComponentD2>) {
// CHECK-NEXT:      return
// CHECK-NEXT:    }
// CHECK-NEXT:  }
// -----

module attributes {veridise.lang = "llzk"} {
  llzk.struct @ComponentG<[@S, @T]> {
    field @f : !llzk.array<@S x !llzk.tvar<@T>>

    func @compute() -> !llzk.struct<@ComponentG<[@S, @T]>> {
      %self = new_struct : !llzk.struct<@ComponentG<[@S, @T]>>
      %arr = new_array : !llzk.array<@S x !llzk.tvar<@T>>
      %lb = index.constant 0
      %up = llzk.read_const @S : index
      %step = index.constant 1
      scf.for %iv = %lb to %up step %step {
        // Although a type variable is used, this struct can only be instantiated
        //  with `@T = index` since an `index` value is assigned to the tvar array.
        llzk.writearr %arr[%iv] = %iv : !llzk.array<@S x !llzk.tvar<@T>>, index
      }
      writef %self[@f] = %arr : !llzk.struct<@ComponentG<[@S, @T]>>, !llzk.array<@S x !llzk.tvar<@T>>
      return %self : !llzk.struct<@ComponentG<[@S, @T]>>
    }

    func @constrain(%self: !llzk.struct<@ComponentG<[@S, @T]>>) {
      %arr = readf %self[@f] : !llzk.struct<@ComponentG<[@S, @T]>>, !llzk.array<@S x !llzk.tvar<@T>>
      %lb = index.constant 0
      %up = llzk.read_const @S : index
      %step = index.constant 1
      scf.for %iv = %lb to %up step %step {
        %temp = llzk.readarr %arr[%iv] : !llzk.array<@S x !llzk.tvar<@T>>, !llzk.tvar<@T>
        llzk.emit_eq %temp, %iv : !llzk.tvar<@T>, index // requires that @T==index
      }
      return
    }
  }
  llzk.struct @Main {
    field @sub : !llzk.struct<@ComponentG<[5, index]>>

    func @compute() -> !llzk.struct<@Main> {
      %self = new_struct : !llzk.struct<@Main>
      %1 = call @ComponentG::@compute() : () -> !llzk.struct<@ComponentG<[5, index]>>
      writef %self[@sub] = %1 : !llzk.struct<@Main>, !llzk.struct<@ComponentG<[5, index]>>
      return %self : !llzk.struct<@Main>
    }
    func @constrain(%self: !llzk.struct<@Main>) {
      %1 = readf %self[@sub] : !llzk.struct<@Main>, !llzk.struct<@ComponentG<[5, index]>>
      call @ComponentG::@constrain(%1) : (!llzk.struct<@ComponentG<[5, index]>>) -> ()
      return
    }
  }
}
// CHECK-LABEL: llzk.struct @"ComponentG_5,i" {
// CHECK-NEXT:    field @f : !llzk.array<5 x index>
// CHECK-NEXT:    func @compute() -> !llzk.struct<@"ComponentG_5,i"> {
// CHECK-NEXT:      %[[VAL_0:[0-9a-zA-Z_\.]+]] = new_struct : <@"ComponentG_5,i">
// CHECK-NEXT:      %[[VAL_1:[0-9a-zA-Z_\.]+]] = new_array  : <5 x index>
// CHECK-NEXT:      %[[VAL_2:[0-9a-zA-Z_\.]+]] = index.constant 0
// CHECK-NEXT:      %[[VAL_3:[0-9a-zA-Z_\.]+]] = index.constant 5
// CHECK-NEXT:      %[[VAL_4:[0-9a-zA-Z_\.]+]] = index.constant 1
// CHECK-NEXT:      scf.for %[[VAL_5:[0-9a-zA-Z_\.]+]] = %[[VAL_2]] to %[[VAL_3]] step %[[VAL_4]] {
// CHECK-NEXT:        llzk.writearr %[[VAL_1]]{{\[}}%[[VAL_5]]] = %[[VAL_5]] : <5 x index>, index
// CHECK-NEXT:      }
// CHECK-NEXT:      writef %[[VAL_0]][@f] = %[[VAL_1]] : <@"ComponentG_5,i">, !llzk.array<5 x index>
// CHECK-NEXT:      return %[[VAL_0]] : !llzk.struct<@"ComponentG_5,i">
// CHECK-NEXT:    }
// CHECK-NEXT:    func @constrain(%[[VAL_6:[0-9a-zA-Z_\.]+]]: !llzk.struct<@"ComponentG_5,i">) {
// CHECK-NEXT:      %[[VAL_7:[0-9a-zA-Z_\.]+]] = readf %[[VAL_6]][@f] : <@"ComponentG_5,i">, !llzk.array<5 x index>
// CHECK-NEXT:      %[[VAL_8:[0-9a-zA-Z_\.]+]] = index.constant 0
// CHECK-NEXT:      %[[VAL_9:[0-9a-zA-Z_\.]+]] = index.constant 5
// CHECK-NEXT:      %[[VAL_10:[0-9a-zA-Z_\.]+]] = index.constant 1
// CHECK-NEXT:      scf.for %[[VAL_11:[0-9a-zA-Z_\.]+]] = %[[VAL_8]] to %[[VAL_9]] step %[[VAL_10]] {
// CHECK-NEXT:        %[[VAL_12:[0-9a-zA-Z_\.]+]] = llzk.readarr %[[VAL_7]]{{\[}}%[[VAL_11]]] : <5 x index>, index
// CHECK-NEXT:        llzk.emit_eq %[[VAL_12]], %[[VAL_11]] : index, index
// CHECK-NEXT:      }
// CHECK-NEXT:      return
// CHECK-NEXT:    }
// CHECK-NEXT:  }
//
// CHECK-LABEL: llzk.struct @Main {
// CHECK-NEXT:    field @sub : !llzk.struct<@"ComponentG_5,i">
// CHECK-NEXT:    func @compute() -> !llzk.struct<@Main> {
// CHECK-NEXT:      %[[VAL_0:[0-9a-zA-Z_\.]+]] = new_struct : <@Main>
// CHECK-NEXT:      %[[VAL_1:[0-9a-zA-Z_\.]+]] = call @"ComponentG_5,i"::@compute() : () -> !llzk.struct<@"ComponentG_5,i">
// CHECK-NEXT:      writef %[[VAL_0]][@sub] = %[[VAL_1]] : <@Main>, !llzk.struct<@"ComponentG_5,i">
// CHECK-NEXT:      return %[[VAL_0]] : !llzk.struct<@Main>
// CHECK-NEXT:    }
// CHECK-NEXT:    func @constrain(%[[VAL_2:[0-9a-zA-Z_\.]+]]: !llzk.struct<@Main>) {
// CHECK-NEXT:      %[[VAL_3:[0-9a-zA-Z_\.]+]] = readf %[[VAL_2]][@sub] : <@Main>, !llzk.struct<@"ComponentG_5,i">
// CHECK-NEXT:      call @"ComponentG_5,i"::@constrain(%[[VAL_3]]) : (!llzk.struct<@"ComponentG_5,i">) -> ()
// CHECK-NEXT:      return
// CHECK-NEXT:    }
// CHECK-NEXT:  }
