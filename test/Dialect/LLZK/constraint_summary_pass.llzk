// RUN: llzk -split-input-file -llzk-inline-includes -llzk-print-constraint-summaries %s 2>&1 | FileCheck %s

module attributes {veridise.lang = "llzk"} {

  llzk.func @global_add(%a: !llzk.felt, %b: !llzk.felt) -> !llzk.felt {
    %c = add %a, %b
    return %c : !llzk.felt
  }

  llzk.struct @Adder {
    field @sum : !llzk.felt {llzk.pub}

    func @compute(%a: !llzk.felt, %b: !llzk.felt) -> !llzk.struct<@Adder> {
      %self = new_struct : !llzk.struct<@Adder>
      %sum = call @global_add(%a, %b) : (!llzk.felt, !llzk.felt) -> (!llzk.felt)
      writef %self[@sum] = %sum : !llzk.struct<@Adder>, !llzk.felt
      return %self : !llzk.struct<@Adder>
    }

    func @constrain(%self: !llzk.struct<@Adder>, %a: !llzk.felt, %b: !llzk.felt) {
      %sum = readf %self[@sum] : !llzk.struct<@Adder>, !llzk.felt
      %c = call @global_add(%a, %b) : (!llzk.felt, !llzk.felt) -> (!llzk.felt)
      emit_eq %sum, %c : !llzk.felt
      return
    }
  }
}

// CHECK-LABEL: Adder ConstraintSummary {
// CHECK-NEXT:     { %arg0[@sum], %arg1, %arg2 }
// CHECK-NEXT: }

// -----

// NOTE: using inline includes pass here to remove test file redundancy
// and to avoid polluting the original ZIR example file with the expected
// outputs of this pass.
module attributes {veridise.lang = "llzk"} {
  llzk.include "zir_example_1.llzk" as @zir
}

// CHECK-LABEL: ValU32 ConstraintSummary {
// CHECK-NEXT:     { %arg0[@low] }
// CHECK-NEXT:     { %arg0[@high] }
// CHECK-NEXT:     { %arg1 }
// CHECK-NEXT:     { %arg2 }
// CHECK-NEXT: }
// CHECK-NEXT: Reg ConstraintSummary {
// CHECK-NEXT:     { %arg1, %arg0[@reg] }
// CHECK-NEXT: }
// CHECK-NEXT: C1 ConstraintSummary {
// CHECK-NEXT:     { %arg1, %arg2, %arg0[@z][@reg] }
// CHECK-NEXT: }
// CHECK-NEXT: C2 ConstraintSummary {
// CHECK-NEXT:     { %arg1[@low], %arg1[@high], %arg0[@fc1][@z][@reg], <constfelt: 0> }
// CHECK-NEXT: }

// -----

module attributes {veridise.lang = "llzk"} {
  llzk.struct @ComponentB {
    func @constrain(%self: !llzk.struct<@ComponentB>, %a: !llzk.felt, %b: !llzk.array<5 x !llzk.felt>) {
      llzk.emit_in %a, %b : !llzk.array<5 x !llzk.felt>
      return
    }

    func @compute() -> !llzk.struct<@ComponentB> {
      %self = new_struct : !llzk.struct<@ComponentB>
      return %self : !llzk.struct<@ComponentB>
    }
  }
}

// CHECK: ComponentB ConstraintSummary {
// CHECK-NEXT:     { %arg1, %arg2 }
// CHECK-NEXT: }
