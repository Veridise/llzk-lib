// RUN: llzk-opt -split-input-file %s 2>&1 | FileCheck --enable-var-scope %s

// This IR mimics an idiom that could be generated by the zirgen frontend
#map = affine_map<()[s0, s1] -> (s0 + s1)>
module attributes { veridise.lang = "llzk" } {
  llzk.struct @A<[@X, @Y, @N]> {
    func @compute(%0: !llzk.array<@N x !llzk.felt>) -> !llzk.struct<@A<[@X, @Y, @N]>> {
      %self = new_struct : <@A<[@X, @Y, @N]>>
      return %self : !llzk.struct<@A<[@X, @Y, @N]>>
    }
    func @constrain(%self: !llzk.struct<@A<[@X, @Y, @N]>>, %0: !llzk.array<@N x !llzk.felt>) {
      return
    }
  }
  llzk.struct @B<[@X, @Y, @N]> {
    field @a : !llzk.struct<@A<[@X, @Y, #map]>>
    func @compute(%a0: !llzk.array<@N x !llzk.felt>) -> !llzk.struct<@B<[@X, @Y, @N]>> {
      %self = new_struct : <@B<[@X, @Y, @N]>>
      %0 = read_const @X : index
      %1 = read_const @Y : index
      %2 = unifiable_cast %a0 : (!llzk.array<@N x !llzk.felt>) -> !llzk.array<#map x !llzk.felt>
      %3 = call @A::@compute(%2){()[%0, %1]} : (!llzk.array<#map x !llzk.felt>) -> !llzk.struct<@A<[@X, @Y, #map]>>
      writef %self[@a] = %3 : !llzk.struct<@B<[@X, @Y, @N]>>, !llzk.struct<@A<[@X, @Y, #map]>>
      return %self : !llzk.struct<@B<[@X, @Y, @N]>>
    }
    func @constrain(%self: !llzk.struct<@B<[@X, @Y, @N]>>, %a0: !llzk.array<@N x !llzk.felt>) {
      %2 = unifiable_cast %a0 : (!llzk.array<@N x !llzk.felt>) -> !llzk.array<#map x !llzk.felt>
      %a = readf %self[@a] : !llzk.struct<@B<[@X, @Y, @N]>>, !llzk.struct<@A<[@X, @Y, #map]>>
      call @A::@constrain(%a, %2) : (!llzk.struct<@A<[@X, @Y, #map]>>, !llzk.array<#map x !llzk.felt>) -> ()
      return
    }
  }
}
//       CHECK: #map = affine_map<()[s0, s1] -> (s0 + s1)>
//       CHECK: module attributes {veridise.lang = "llzk"} {
// CHECK-LABEL:   llzk.struct @A<[@X, @Y, @N]> {
// CHECK-LABEL:     func @compute
//  CHECK-SAME:                  (%[[A0:[0-9a-zA-Z_\.]+]]: !llzk.array<@N x !llzk.felt>) -> !llzk.struct<@A<[@X, @Y, @N]>> {
//  CHECK-NEXT:       %[[SELF:[0-9a-zA-Z_\.]+]] = new_struct : <@A<[@X, @Y, @N]>>
//  CHECK-NEXT:       return %[[SELF]] : !llzk.struct<@A<[@X, @Y, @N]>>
//  CHECK-NEXT:     }
// CHECK-LABEL:     func @constrain
//  CHECK-SAME:                   (%[[SELF:[0-9a-zA-Z_\.]+]]: !llzk.struct<@A<[@X, @Y, @N]>>, %[[A0:[0-9a-zA-Z_\.]+]]: !llzk.array<@N x !llzk.felt>) {
//  CHECK-NEXT:       return
//  CHECK-NEXT:     }
//  CHECK-NEXT:   }
// CHECK-LABEL:   llzk.struct @B<[@X, @Y, @N]> {
//  CHECK-NEXT:     field @a : !llzk.struct<@A<[@X, @Y, #map]>>
// CHECK-LABEL:     func @compute
//  CHECK-SAME:                  (%[[A0:[0-9a-zA-Z_\.]+]]: !llzk.array<@N x !llzk.felt>) -> !llzk.struct<@B<[@X, @Y, @N]>> {
//  CHECK-NEXT:       %[[SELF:[0-9a-zA-Z_\.]+]] = new_struct : <@B<[@X, @Y, @N]>>
//  CHECK-NEXT:       %[[T0:[0-9a-zA-Z_\.]+]] = read_const @X : index
//  CHECK-NEXT:       %[[T1:[0-9a-zA-Z_\.]+]] = read_const @Y : index
//  CHECK-NEXT:       %[[T2:[0-9a-zA-Z_\.]+]] = unifiable_cast %[[A0]] : (!llzk.array<@N x !llzk.felt>) -> !llzk.array<#map x !llzk.felt>
//  CHECK-NEXT:       %[[T3:[0-9a-zA-Z_\.]+]] = call @A::@compute(%[[T2]]) {()[%[[T0]], %[[T1]]]} : (!llzk.array<#map x !llzk.felt>) -> !llzk.struct<@A<[@X, @Y, #map]>>
//  CHECK-NEXT:       writef %[[SELF]][@a] = %[[T3]] : <@B<[@X, @Y, @N]>>, !llzk.struct<@A<[@X, @Y, #map]>>
//  CHECK-NEXT:       return %[[SELF]] : !llzk.struct<@B<[@X, @Y, @N]>>
//  CHECK-NEXT:     }
// CHECK-LABEL:     func @constrain
//  CHECK-SAME:                    (%[[SELF:[0-9a-zA-Z_\.]+]]: !llzk.struct<@B<[@X, @Y, @N]>>, %[[A0:[0-9a-zA-Z_\.]+]]: !llzk.array<@N x !llzk.felt>) {
//  CHECK-NEXT:       %[[T0:[0-9a-zA-Z_\.]+]] = unifiable_cast %[[A0]] : (!llzk.array<@N x !llzk.felt>) -> !llzk.array<#map x !llzk.felt>
//  CHECK-NEXT:       %[[T1:[0-9a-zA-Z_\.]+]] = readf %[[SELF]][@a] : <@B<[@X, @Y, @N]>>, !llzk.struct<@A<[@X, @Y, #map]>>
//  CHECK-NEXT:       call @A::@constrain(%[[T1]], %[[T0]]) : (!llzk.struct<@A<[@X, @Y, #map]>>, !llzk.array<#map x !llzk.felt>) -> ()
//  CHECK-NEXT:       return
//  CHECK-NEXT:     }
//  CHECK-NEXT:   }
//  CHECK-NEXT: }
