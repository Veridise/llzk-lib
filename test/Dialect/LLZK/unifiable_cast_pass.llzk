// RUN: llzk-opt -split-input-file %s 2>&1 | FileCheck --enable-var-scope %s

// This IR mimics an idiom that could be generated by the zirgen frontend
#map = affine_map<()[s0, s1] -> (s0 + s1)>
module attributes { veridise.lang = "llzk" } {
  llzk.struct @A<[@X, @Y, @N]> {
    func @compute(%0: !llzk.array<@N x !llzk.felt>) -> !llzk.struct<@A<[@X, @Y, @N]>> {
      %self = new_struct : <@A<[@X, @Y, @N]>>
      return %self : !llzk.struct<@A<[@X, @Y, @N]>>
    }
    func @constrain(%self: !llzk.struct<@A<[@X, @Y, @N]>>, %0: !llzk.array<@N x !llzk.felt>) {
      return
    }
  }
  llzk.struct @B<[@X, @Y, @N]> {
    field @a : !llzk.struct<@A<[@X, @Y, #map]>>
    func @compute(%a0: !llzk.array<@N x !llzk.felt>) -> !llzk.struct<@B<[@X, @Y, @N]>> {
      %self = new_struct : <@B<[@X, @Y, @N]>>
      %0 = read_const @X : index
      %1 = read_const @Y : index
      %2 = unifiable_cast %a0 : (!llzk.array<@N x !llzk.felt>) -> !llzk.array<#map x !llzk.felt>
      %3 = call @A::@compute(%2){()[%0, %1]} : (!llzk.array<#map x !llzk.felt>) -> !llzk.struct<@A<[@X, @Y, #map]>>
      writef %self[@a] = %3 : !llzk.struct<@B<[@X, @Y, @N]>>, !llzk.struct<@A<[@X, @Y, #map]>>
      return %self : !llzk.struct<@B<[@X, @Y, @N]>>
    }
    func @constrain(%self: !llzk.struct<@B<[@X, @Y, @N]>>, %a0: !llzk.array<@N x !llzk.felt>) {
      %2 = unifiable_cast %a0 : (!llzk.array<@N x !llzk.felt>) -> !llzk.array<#map x !llzk.felt>
      %a = readf %self[@a] : !llzk.struct<@B<[@X, @Y, @N]>>, !llzk.struct<@A<[@X, @Y, #map]>>
      call @A::@constrain(%a, %2) : (!llzk.struct<@A<[@X, @Y, #map]>>, !llzk.array<#map x !llzk.felt>) -> ()
      return
    }
  }
}
//       CHECK: #map = affine_map<()[s0, s1] -> (s0 + s1)>
//  CHECK-NEXT: module attributes {veridise.lang = "llzk"} {
// CHECK-LABEL:   llzk.struct @A<[@X, @Y, @N]> {
// CHECK-LABEL:     func @compute
//  CHECK-SAME:                  (%[[A0:[0-9a-zA-Z_\.]+]]: !llzk.array<@N x !llzk.felt>) -> !llzk.struct<@A<[@X, @Y, @N]>> {
//  CHECK-NEXT:       %[[SELF:[0-9a-zA-Z_\.]+]] = new_struct : <@A<[@X, @Y, @N]>>
//  CHECK-NEXT:       return %[[SELF]] : !llzk.struct<@A<[@X, @Y, @N]>>
//  CHECK-NEXT:     }
// CHECK-NEXT:     func @constrain
//  CHECK-SAME:                   (%[[SELF:[0-9a-zA-Z_\.]+]]: !llzk.struct<@A<[@X, @Y, @N]>>, %[[A0:[0-9a-zA-Z_\.]+]]: !llzk.array<@N x !llzk.felt>) {
//  CHECK-NEXT:       return
//  CHECK-NEXT:     }
//  CHECK-NEXT:   }
// CHECK-LABEL:   llzk.struct @B<[@X, @Y, @N]> {
//  CHECK-NEXT:     field @a : !llzk.struct<@A<[@X, @Y, #map]>>
// CHECK-LABEL:     func @compute
//  CHECK-SAME:                  (%[[A0:[0-9a-zA-Z_\.]+]]: !llzk.array<@N x !llzk.felt>) -> !llzk.struct<@B<[@X, @Y, @N]>> {
//  CHECK-NEXT:       %[[SELF:[0-9a-zA-Z_\.]+]] = new_struct : <@B<[@X, @Y, @N]>>
//  CHECK-NEXT:       %[[T0:[0-9a-zA-Z_\.]+]] = read_const @X : index
//  CHECK-NEXT:       %[[T1:[0-9a-zA-Z_\.]+]] = read_const @Y : index
//  CHECK-NEXT:       %[[T2:[0-9a-zA-Z_\.]+]] = unifiable_cast %[[A0]] : (!llzk.array<@N x !llzk.felt>) -> !llzk.array<#map x !llzk.felt>
//  CHECK-NEXT:       %[[T3:[0-9a-zA-Z_\.]+]] = call @A::@compute(%[[T2]]) {()[%[[T0]], %[[T1]]]} : (!llzk.array<#map x !llzk.felt>) -> !llzk.struct<@A<[@X, @Y, #map]>>
//  CHECK-NEXT:       writef %[[SELF]][@a] = %[[T3]] : <@B<[@X, @Y, @N]>>, !llzk.struct<@A<[@X, @Y, #map]>>
//  CHECK-NEXT:       return %[[SELF]] : !llzk.struct<@B<[@X, @Y, @N]>>
//  CHECK-NEXT:     }
// CHECK-LABEL:     func @constrain
//  CHECK-SAME:                    (%[[SELF:[0-9a-zA-Z_\.]+]]: !llzk.struct<@B<[@X, @Y, @N]>>, %[[A0:[0-9a-zA-Z_\.]+]]: !llzk.array<@N x !llzk.felt>) {
//  CHECK-NEXT:       %[[T0:[0-9a-zA-Z_\.]+]] = unifiable_cast %[[A0]] : (!llzk.array<@N x !llzk.felt>) -> !llzk.array<#map x !llzk.felt>
//  CHECK-NEXT:       %[[T1:[0-9a-zA-Z_\.]+]] = readf %[[SELF]][@a] : <@B<[@X, @Y, @N]>>, !llzk.struct<@A<[@X, @Y, #map]>>
//  CHECK-NEXT:       call @A::@constrain(%[[T1]], %[[T0]]) : (!llzk.struct<@A<[@X, @Y, #map]>>, !llzk.array<#map x !llzk.felt>) -> ()
//  CHECK-NEXT:       return
//  CHECK-NEXT:     }
//  CHECK-NEXT:   }
//  CHECK-NEXT: }

// -----
// Skeleton for creating tests
module attributes {veridise.lang = "llzk"} {
  llzk.struct @A<[]> {
    func @compute(%0: <input-type>) -> !llzk.struct<@A<[]>> {
      %self = new_struct : <@A<[]>>
      %1 = unifiable_cast %0 : (<input-type>) -> <output-type>
      return %self : !llzk.struct<@A<[]>>
    }
    func @constrain(%self: !llzk.struct<@A<[]>>, %0: <input-type>) {
      return
    }
  }
}

//       CHECK: module attributes {veridise.lang = "llzk"} {
// CHECK-LABEL:  llzk.struct @A<[]> {
// CHECK-LABEL:    func @compute
//  CHECK-SAME:                 (%0: <input-type>) -> !llzk.struct<@A<[]>> {
//  CHECK-NEXT:      %self = new_struct : <@A<[]>>
//  CHECK-NEXT:      %1 = unifiable_cast %0 : (<input-type>) -> <output-type>
//  CHECK-NEXT:      return %self : !llzk.struct<@A<[]>>
//  CHECK-NEXT:    }
// CHECK-LABEL:    func @constrain
//  CHECK-SAME:                   (%self: !llzk.struct<@A<[]>>, %0: <input-type>) {
//  CHECK-NEXT:      return
//  CHECK-NEXT:    }
//  CHECK-NEXT:  }
//  CHECK-NEXT: }

// -----

// TODO:
//  - Same type for input and output
//  - Type var type in either left or right
//  - Both structs
//   - They unify if they are the same struct (by name) and they params unify 
//  - Both arrays
//   - They unify if the inner type unifies and if the params unify 
//   - Params unify if they are (affine attr ~ integer attr || integer attr ~ affine attr || either side is a symbol || they are both type attrs and their inner types unify)

// - Negative test cases for all the above
