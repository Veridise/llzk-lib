// RUN: llzk-opt -split-input-file %s 2>&1 | FileCheck --enable-var-scope %s

// This IR mimics an idiom that could be generated by the zirgen frontend
#map = affine_map<()[s0, s1] -> (s0 + s1)>
module attributes { veridise.lang = "llzk" } {
  struct.def @A<[@X, @Y, @N]> {
    function.def @compute(%0: !array.array<@N x !felt.felt>) -> !struct.struct<@A<[@X, @Y, @N]>> {
      %self = struct.new : <@A<[@X, @Y, @N]>>
      function.return %self : !struct.struct<@A<[@X, @Y, @N]>>
    }
    function.def @constrain(%self: !struct.struct<@A<[@X, @Y, @N]>>, %0: !array.array<@N x !felt.felt>) {
      function.return
    }
  }
  struct.def @B<[@X, @Y, @N]> {
    struct.field @a : !struct.struct<@A<[@X, @Y, #map]>>
    function.def @compute(%a0: !array.array<@N x !felt.felt>) -> !struct.struct<@B<[@X, @Y, @N]>> {
      %self = struct.new : <@B<[@X, @Y, @N]>>
      %0 = llzk.read_const @X : index
      %1 = llzk.read_const @Y : index
      %2 = llzk.unifiable_cast %a0 : (!array.array<@N x !felt.felt>) -> !array.array<#map x !felt.felt>
      %3 = function.call @A::@compute(%2){()[%0, %1]} : (!array.array<#map x !felt.felt>) -> !struct.struct<@A<[@X, @Y, #map]>>
      struct.writef %self[@a] = %3 : !struct.struct<@B<[@X, @Y, @N]>>, !struct.struct<@A<[@X, @Y, #map]>>
      function.return %self : !struct.struct<@B<[@X, @Y, @N]>>
    }
    function.def @constrain(%self: !struct.struct<@B<[@X, @Y, @N]>>, %a0: !array.array<@N x !felt.felt>) {
      %2 = llzk.unifiable_cast %a0 : (!array.array<@N x !felt.felt>) -> !array.array<#map x !felt.felt>
      %a = struct.readf %self[@a] : !struct.struct<@B<[@X, @Y, @N]>>, !struct.struct<@A<[@X, @Y, #map]>>
      function.call @A::@constrain(%a, %2) : (!struct.struct<@A<[@X, @Y, #map]>>, !array.array<#map x !felt.felt>) -> ()
      function.return
    }
  }
}
//       CHECK: #map = affine_map<()[s0, s1] -> (s0 + s1)>
//       CHECK: module attributes {veridise.lang = "llzk"} {
// CHECK-LABEL:   struct.def @A<[@X, @Y, @N]> {
// CHECK-LABEL:     function.def @compute
//  CHECK-SAME:                  (%[[A0:[0-9a-zA-Z_\.]+]]: !array.array<@N x !felt.felt>) -> !struct.struct<@A<[@X, @Y, @N]>> attributes {function.allow_witness} {
//  CHECK-NEXT:       %[[SELF:[0-9a-zA-Z_\.]+]] = struct.new : <@A<[@X, @Y, @N]>>
//  CHECK-NEXT:       function.return %[[SELF]] : !struct.struct<@A<[@X, @Y, @N]>>
//  CHECK-NEXT:     }
// CHECK-LABEL:     function.def @constrain
//  CHECK-SAME:                   (%[[SELF:[0-9a-zA-Z_\.]+]]: !struct.struct<@A<[@X, @Y, @N]>>, %[[A0:[0-9a-zA-Z_\.]+]]: !array.array<@N x !felt.felt>) attributes {function.allow_constraint} {
//  CHECK-NEXT:       function.return
//  CHECK-NEXT:     }
//  CHECK-NEXT:   }
// CHECK-LABEL:   struct.def @B<[@X, @Y, @N]> {
//  CHECK-NEXT:     struct.field @a : !struct.struct<@A<[@X, @Y, #map]>>
// CHECK-LABEL:     function.def @compute
//  CHECK-SAME:                  (%[[A0:[0-9a-zA-Z_\.]+]]: !array.array<@N x !felt.felt>) -> !struct.struct<@B<[@X, @Y, @N]>> attributes {function.allow_witness} {
//  CHECK-NEXT:       %[[SELF:[0-9a-zA-Z_\.]+]] = struct.new : <@B<[@X, @Y, @N]>>
//  CHECK-NEXT:       %[[T0:[0-9a-zA-Z_\.]+]] = llzk.read_const @X : index
//  CHECK-NEXT:       %[[T1:[0-9a-zA-Z_\.]+]] = llzk.read_const @Y : index
//  CHECK-NEXT:       %[[T2:[0-9a-zA-Z_\.]+]] = llzk.unifiable_cast %[[A0]] : (!array.array<@N x !felt.felt>) -> !array.array<#map x !felt.felt>
//  CHECK-NEXT:       %[[T3:[0-9a-zA-Z_\.]+]] = function.call @A::@compute(%[[T2]]) {()[%[[T0]], %[[T1]]]} : (!array.array<#map x !felt.felt>) -> !struct.struct<@A<[@X, @Y, #map]>>
//  CHECK-NEXT:       struct.writef %[[SELF]][@a] = %[[T3]] : <@B<[@X, @Y, @N]>>, !struct.struct<@A<[@X, @Y, #map]>>
//  CHECK-NEXT:       function.return %[[SELF]] : !struct.struct<@B<[@X, @Y, @N]>>
//  CHECK-NEXT:     }
// CHECK-LABEL:     function.def @constrain
//  CHECK-SAME:                    (%[[SELF:[0-9a-zA-Z_\.]+]]: !struct.struct<@B<[@X, @Y, @N]>>, %[[A0:[0-9a-zA-Z_\.]+]]: !array.array<@N x !felt.felt>) attributes {function.allow_constraint} {
//  CHECK-NEXT:       %[[T0:[0-9a-zA-Z_\.]+]] = llzk.unifiable_cast %[[A0]] : (!array.array<@N x !felt.felt>) -> !array.array<#map x !felt.felt>
//  CHECK-NEXT:       %[[T1:[0-9a-zA-Z_\.]+]] = struct.readf %[[SELF]][@a] : <@B<[@X, @Y, @N]>>, !struct.struct<@A<[@X, @Y, #map]>>
//  CHECK-NEXT:       function.call @A::@constrain(%[[T1]], %[[T0]]) : (!struct.struct<@A<[@X, @Y, #map]>>, !array.array<#map x !felt.felt>) -> ()
//  CHECK-NEXT:       function.return
//  CHECK-NEXT:     }
//  CHECK-NEXT:   }
//  CHECK-NEXT: }

// -----

#map1 = affine_map<()[s0, s1] -> (s0 + s1)>
#map2 = affine_map<()[s0, s1, s2] -> (s0 + s1 + s2)>
module attributes {veridise.lang = "llzk"} {
  struct.def @T1<[]> {
    function.def @compute() -> !struct.struct<@T1<[]>> {
      %self = struct.new : <@T1<[]>>
      function.return %self : !struct.struct<@T1<[]>>
    }
    function.def @constrain(%self : !struct.struct<@T1<[]>>) {
      function.return
    }
  }
  struct.def @T2<[@N]> {
    function.def @compute() -> !struct.struct<@T2<[@N]>> {
      %self = struct.new : <@T2<[@N]>>
      function.return %self : !struct.struct<@T2<[@N]>>
    }
    function.def @constrain(%self : !struct.struct<@T2<[@N]>>) {
      function.return
    }
  }
  struct.def @T3<[@A, @B, @C, @D, @E]> {
    function.def @compute() -> !struct.struct<@T3<[@A, @B, @C, @D, @E]>> {
      %self = struct.new : <@T3<[@A, @B, @C, @D, @E]>>
      function.return %self : !struct.struct<@T3<[@A, @B, @C, @D, @E]>>
    }
    function.def @constrain(%self : !struct.struct<@T3<[@A, @B, @C, @D, @E]>>) {
      function.return
    }
  }
  struct.def @Tester<[@S0, @S1]> {
    function.def @compute(%0: index, %1: i1, %2: !felt.felt, %3: !struct.struct<@T1<[]>>,
                  %4: !struct.struct<@T2<[1]>>, %5: !struct.struct<@T2<[@S0]>>,
                  %6: !struct.struct<@T2<[7]>>, %7: !struct.struct<@T2<[!felt.felt]>>,
                  %8: !array.array<2,2 x !felt.felt>, %9: !array.array<2,@S0 x !felt.felt>,
                  %10: !array.array<2,7 x !felt.felt>, %11: !string.string, %12: !llzk.tvar<@S1>,
                  %18: !struct.struct<@T3<[1, 7, @S0, 1, !struct.struct<@T2<[1]>>]>>,
                  %20: !array.array<1, 7, @S0, 1 x !struct.struct<@T2<[1]>>>) -> !struct.struct<@Tester<[@S0, @S1]>> {
      %self = struct.new : <@Tester<[@S0, @S1]>>
      // Tests for equality
      %r0 = llzk.unifiable_cast %0 : (index) -> index
      %r1 = llzk.unifiable_cast %1 : (i1) -> i1
      %r2 = llzk.unifiable_cast %2 : (!felt.felt) -> !felt.felt
      %r3 = llzk.unifiable_cast %3 : (!struct.struct<@T1<[]>>) -> !struct.struct<@T1<[]>>
      %r4 = llzk.unifiable_cast %4 : (!struct.struct<@T2<[1]>>) -> !struct.struct<@T2<[1]>>
      %r5 = llzk.unifiable_cast %5 : (!struct.struct<@T2<[@S0]>>) -> !struct.struct<@T2<[@S0]>>
      %r6 = llzk.unifiable_cast %6 : (!struct.struct<@T2<[7]>>) -> !struct.struct<@T2<[#map1]>>
      %r7 = llzk.unifiable_cast %7 : (!struct.struct<@T2<[!felt.felt]>>) -> !struct.struct<@T2<[!felt.felt]>>
      %r8 = llzk.unifiable_cast %8 : (!array.array<2,2 x !felt.felt>) -> !array.array<2,2 x !felt.felt>
      %r9 = llzk.unifiable_cast %9 : (!array.array<2,@S0 x !felt.felt>) -> !array.array<2,@S0 x !felt.felt>
      %r10 = llzk.unifiable_cast %10 : (!array.array<2,7 x !felt.felt>) -> !array.array<2,#map1 x !felt.felt>
      %r11 = llzk.unifiable_cast %11 : (!string.string) -> !string.string
      // Test that a type variable unifies with any type
      %r12 = llzk.unifiable_cast %12 : (!llzk.tvar<@S1>) -> index
      %13 = llzk.unifiable_cast %2 : (!felt.felt) -> !llzk.tvar<@S1>
      // Test that if structs have the same name they unify if their params unify
      %19 = llzk.unifiable_cast %18 : (!struct.struct<@T3<[1, 7, @S0, 1, !struct.struct<@T2<[1]>>]>>) -> !struct.struct<@T3<[#map1, #map1, 1, @S0, !struct.struct<@T2<[#map2]>>]>>
      %21 = llzk.unifiable_cast %20 : (!array.array<1, 7, @S0, 1 x !struct.struct<@T2<[1]>>>) -> !array.array<#map1, #map1, 1, @S0 x !struct.struct<@T2<[#map2]>>>
      function.return %self : !struct.struct<@Tester<[@S0, @S1]>>
    }
    function.def @constrain(%self: !struct.struct<@Tester<[@S0, @S1]>>, %0: index, %1: i1, %2: !felt.felt, %3: !struct.struct<@T1<[]>>,
                  %4: !struct.struct<@T2<[1]>>, %5: !struct.struct<@T2<[@S0]>>,
                  %6: !struct.struct<@T2<[7]>>, %7: !struct.struct<@T2<[!felt.felt]>>,
                  %8: !array.array<2,2 x !felt.felt>, %9: !array.array<2,@S0 x !felt.felt>,
                  %10: !array.array<2,7 x !felt.felt>, %11: !string.string, %12: !llzk.tvar<@S1>,
                  %18: !struct.struct<@T3<[1, 7, @S0, 1, !struct.struct<@T2<[1]>>]>>,
                  %20: !array.array<1, 7, @S0, 1 x !struct.struct<@T2<[1]>>>) {
      function.return
    }
  }
}

//       CHECK: module attributes {veridise.lang = "llzk"} {
// CHECK-LABEL:  struct.def @Tester<[@S0, @S1]> {
// CHECK-LABEL:    function.def @compute(
//  CHECK-SAME:                  %[[A0:[0-9a-zA-Z_\.]+]]: index,
//  CHECK-SAME:                  %[[A1:[0-9a-zA-Z_\.]+]]: i1,
//  CHECK-SAME:                  %[[A2:[0-9a-zA-Z_\.]+]]: !felt.felt,
//  CHECK-SAME:                  %[[A3:[0-9a-zA-Z_\.]+]]: !struct.struct<@T1<[]>>,
//  CHECK-SAME:                  %[[A4:[0-9a-zA-Z_\.]+]]: !struct.struct<@T2<[1]>>,
//  CHECK-SAME:                  %[[A5:[0-9a-zA-Z_\.]+]]: !struct.struct<@T2<[@S0]>>,
//  CHECK-SAME:                  %[[A6:[0-9a-zA-Z_\.]+]]: !struct.struct<@T2<[7]>>,
//  CHECK-SAME:                  %[[A7:[0-9a-zA-Z_\.]+]]: !struct.struct<@T2<[!felt.felt]>>,
//  CHECK-SAME:                  %[[A8:[0-9a-zA-Z_\.]+]]: !array.array<2,2 x !felt.felt>,
//  CHECK-SAME:                  %[[A9:[0-9a-zA-Z_\.]+]]: !array.array<2,@S0 x !felt.felt>,
//  CHECK-SAME:                  %[[A10:[0-9a-zA-Z_\.]+]]: !array.array<2,7 x !felt.felt>,
//  CHECK-SAME:                  %[[A11:[0-9a-zA-Z_\.]+]]: !string.string,
//  CHECK-SAME:                  %[[A12:[0-9a-zA-Z_\.]+]]: !llzk.tvar<@S1>,
//  CHECK-SAME:                  %[[A13:[0-9a-zA-Z_\.]+]]: !struct.struct<@T3<[1, 7, @S0, 1, !struct.struct<@T2<[1]>>]>>,
//  CHECK-SAME:                  %[[A14:[0-9a-zA-Z_\.]+]]: !array.array<1,7,@S0,1 x !struct.struct<@T2<[1]>>>
//  CHECK-SAME:    ) -> !struct.struct<@Tester<[@S0, @S1]>> attributes {function.allow_witness} {
//  CHECK-NEXT:      %[[SELF:[0-9a-zA-Z_\.]+]] = struct.new : <@Tester<[@S0, @S1]>>
//  CHECK-NEXT:      %[[T0:[0-9a-zA-Z_\.]+]] = llzk.unifiable_cast %[[A0]] : (index) -> index
//  CHECK-NEXT:      %[[T1:[0-9a-zA-Z_\.]+]] = llzk.unifiable_cast %[[A1]] : (i1) -> i1
//  CHECK-NEXT:      %[[T2:[0-9a-zA-Z_\.]+]] = llzk.unifiable_cast %[[A2]] : (!felt.felt) -> !felt.felt
//  CHECK-NEXT:      %[[T3:[0-9a-zA-Z_\.]+]] = llzk.unifiable_cast %[[A3]] : (!struct.struct<@T1<[]>>) -> !struct.struct<@T1<[]>>
//  CHECK-NEXT:      %[[T4:[0-9a-zA-Z_\.]+]] = llzk.unifiable_cast %[[A4]] : (!struct.struct<@T2<[1]>>) -> !struct.struct<@T2<[1]>>
//  CHECK-NEXT:      %[[T5:[0-9a-zA-Z_\.]+]] = llzk.unifiable_cast %[[A5]] : (!struct.struct<@T2<[@S0]>>) -> !struct.struct<@T2<[@S0]>>
//  CHECK-NEXT:      %[[T6:[0-9a-zA-Z_\.]+]] = llzk.unifiable_cast %[[A6]] : (!struct.struct<@T2<[7]>>) -> !struct.struct<@T2<[#map]>>
//  CHECK-NEXT:      %[[T7:[0-9a-zA-Z_\.]+]] = llzk.unifiable_cast %[[A7]] : (!struct.struct<@T2<[!felt.felt]>>) -> !struct.struct<@T2<[!felt.felt]>>
//  CHECK-NEXT:      %[[T8:[0-9a-zA-Z_\.]+]] = llzk.unifiable_cast %[[A8]] : (!array.array<2,2 x !felt.felt>) -> !array.array<2,2 x !felt.felt>
//  CHECK-NEXT:      %[[T9:[0-9a-zA-Z_\.]+]] = llzk.unifiable_cast %[[A9]] : (!array.array<2,@S0 x !felt.felt>) -> !array.array<2,@S0 x !felt.felt>
//  CHECK-NEXT:      %[[T10:[0-9a-zA-Z_\.]+]] = llzk.unifiable_cast %[[A10]] : (!array.array<2,7 x !felt.felt>) -> !array.array<2,#map x !felt.felt>
//  CHECK-NEXT:      %[[T11:[0-9a-zA-Z_\.]+]] = llzk.unifiable_cast %[[A11]] : (!string.string) -> !string.string
//  CHECK-NEXT:      %[[T12:[0-9a-zA-Z_\.]+]] = llzk.unifiable_cast %[[A12]] : (!llzk.tvar<@S1>) -> index
//  CHECK-NEXT:      %[[T13:[0-9a-zA-Z_\.]+]] = llzk.unifiable_cast %[[A2]] : (!felt.felt) -> !llzk.tvar<@S1>
//  CHECK-NEXT:      %[[T14:[0-9a-zA-Z_\.]+]] = llzk.unifiable_cast %[[A13]] : (!struct.struct<@T3<[1, 7, @S0, 1, !struct.struct<@T2<[1]>>]>>) -> !struct.struct<@T3<[#map, #map, 1, @S0, !struct.struct<@T2<[#map1]>>]>>
//  CHECK-NEXT:      %[[T15:[0-9a-zA-Z_\.]+]] = llzk.unifiable_cast %[[A14]] : (!array.array<1,7,@S0,1 x !struct.struct<@T2<[1]>>>) -> !array.array<#map,#map,1,@S0 x !struct.struct<@T2<[#map1]>>>
//  CHECK-NEXT:      function.return %[[SELF]] : !struct.struct<@Tester<[@S0, @S1]>>
//  CHECK-NEXT:    }
// CHECK-LABEL:    function.def @constrain(
//  CHECK-SAME:                    %[[SELF:[0-9a-zA-Z_\.]+]]: !struct.struct<@Tester<[@S0, @S1]>>,
//  CHECK-SAME:                    %[[A0:[0-9a-zA-Z_\.]+]]: index,
//  CHECK-SAME:                    %[[A1:[0-9a-zA-Z_\.]+]]: i1,
//  CHECK-SAME:                    %[[A2:[0-9a-zA-Z_\.]+]]: !felt.felt,
//  CHECK-SAME:                    %[[A3:[0-9a-zA-Z_\.]+]]: !struct.struct<@T1<[]>>,
//  CHECK-SAME:                    %[[A4:[0-9a-zA-Z_\.]+]]: !struct.struct<@T2<[1]>>,
//  CHECK-SAME:                    %[[A5:[0-9a-zA-Z_\.]+]]: !struct.struct<@T2<[@S0]>>,
//  CHECK-SAME:                    %[[A6:[0-9a-zA-Z_\.]+]]: !struct.struct<@T2<[7]>>,
//  CHECK-SAME:                    %[[A7:[0-9a-zA-Z_\.]+]]: !struct.struct<@T2<[!felt.felt]>>,
//  CHECK-SAME:                    %[[A8:[0-9a-zA-Z_\.]+]]: !array.array<2,2 x !felt.felt>,
//  CHECK-SAME:                    %[[A9:[0-9a-zA-Z_\.]+]]: !array.array<2,@S0 x !felt.felt>,
//  CHECK-SAME:                    %[[A10:[0-9a-zA-Z_\.]+]]: !array.array<2,7 x !felt.felt>,
//  CHECK-SAME:                    %[[A11:[0-9a-zA-Z_\.]+]]: !string.string,
//  CHECK-SAME:                    %[[A12:[0-9a-zA-Z_\.]+]]: !llzk.tvar<@S1>,
//  CHECK-SAME:                    %[[A13:[0-9a-zA-Z_\.]+]]: !struct.struct<@T3<[1, 7, @S0, 1, !struct.struct<@T2<[1]>>]>>,
//  CHECK-SAME:                    %[[A14:[0-9a-zA-Z_\.]+]]: !array.array<1,7,@S0,1 x !struct.struct<@T2<[1]>>>
//  CHECK-SAME:    ) attributes {function.allow_constraint} {
//  CHECK-NEXT:      function.return
//  CHECK-NEXT:    }
//  CHECK-NEXT:  }
//  CHECK-NEXT: }



