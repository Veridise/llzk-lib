// RUN: llzk-opt -split-input-file %s 2>&1 | FileCheck --enable-var-scope %s

module attributes {veridise.lang = "llzk"} {
  struct.def @ComponentA1<[@A, @B]> {
    function.def @compute() -> !struct.type<@ComponentA1<[@A, @B]>> {
      %self = struct.new : !struct.type<@ComponentA1<[@A, @B]>>
      function.return %self : !struct.type<@ComponentA1<[@A, @B]>>
    }
    function.def @constrain(%self: !struct.type<@ComponentA1<[@A, @B]>>) { function.return }
  }

  struct.def @ComponentA2<[@C]> {
    struct.field @f2 : !struct.type<@ComponentA1<[5, @C]>>

    function.def @compute() -> !struct.type<@ComponentA2<[@C]>> {
      %self = struct.new : !struct.type<@ComponentA2<[@C]>>
      %x = function.call @ComponentA1::@compute() : () -> (!struct.type<@ComponentA1<[5, @C]>>)
      struct.writef %self[@f2] = %x : !struct.type<@ComponentA2<[@C]>>, !struct.type<@ComponentA1<[5, @C]>>
      function.return %self : !struct.type<@ComponentA2<[@C]>>
    }

    function.def @constrain(%self: !struct.type<@ComponentA2<[@C]>>) {
      %b = struct.readf %self[@f2] : !struct.type<@ComponentA2<[@C]>>, !struct.type<@ComponentA1<[5, @C]>>
      function.call @ComponentA1::@constrain(%b) : (!struct.type<@ComponentA1<[5, @C]>>) -> ()
      function.return
    }
  }

  struct.def @ComponentA3 {
    struct.field @f3 : !struct.type<@ComponentA2<[43]>>

    function.def @compute() -> !struct.type<@ComponentA3> {
      %self = struct.new : !struct.type<@ComponentA3>
      %x = function.call @ComponentA2::@compute() : () -> (!struct.type<@ComponentA2<[43]>>)
      struct.writef %self[@f3] = %x : !struct.type<@ComponentA3>, !struct.type<@ComponentA2<[43]>>
      function.return %self : !struct.type<@ComponentA3>
    }

    function.def @constrain(%self: !struct.type<@ComponentA3>) {
      %b = struct.readf %self[@f3] : !struct.type<@ComponentA3>, !struct.type<@ComponentA2<[43]>>
      function.call @ComponentA2::@constrain(%b) : (!struct.type<@ComponentA2<[43]>>) -> ()
      function.return
    }
  }
}
//CHECK-LABEL: module attributes {veridise.lang = "llzk"} {
//CHECK-NEXT:    struct.def @ComponentA1<[@A, @B]> {
//CHECK-NEXT:      function.def @compute() -> !struct.type<@ComponentA1<[@A, @B]>> attributes {function.allow_witness} {
//CHECK-NEXT:        %[[SELF:[0-9a-zA-Z_\.]+]] = struct.new : <@ComponentA1<[@A, @B]>>
//CHECK-NEXT:        function.return %[[SELF]] : !struct.type<@ComponentA1<[@A, @B]>>
//CHECK-NEXT:      }
//CHECK-NEXT:      function.def @constrain(%arg0: !struct.type<@ComponentA1<[@A, @B]>>) attributes {function.allow_constraint} {
//CHECK-NEXT:        function.return
//CHECK-NEXT:      }
//CHECK-NEXT:    }
//CHECK-NEXT:    struct.def @ComponentA2<[@C]> {
//CHECK-NEXT:      struct.field @f2 : !struct.type<@ComponentA1<[5, @C]>>
//CHECK-NEXT:      function.def @compute() -> !struct.type<@ComponentA2<[@C]>> attributes {function.allow_witness} {
//CHECK-NEXT:        %[[SELF:[0-9a-zA-Z_\.]+]] = struct.new : <@ComponentA2<[@C]>>
//CHECK-NEXT:        %[[T0:[0-9a-zA-Z_\.]+]] = function.call @ComponentA1::@compute() : () -> !struct.type<@ComponentA1<[5, @C]>>
//CHECK-NEXT:        struct.writef %[[SELF]][@f2] = %[[T0]] : <@ComponentA2<[@C]>>, !struct.type<@ComponentA1<[5, @C]>>
//CHECK-NEXT:        function.return %[[SELF]] : !struct.type<@ComponentA2<[@C]>>
//CHECK-NEXT:      }
//CHECK-NEXT:      function.def @constrain(%arg0: !struct.type<@ComponentA2<[@C]>>) attributes {function.allow_constraint} {
//CHECK-NEXT:        %[[T0:[0-9a-zA-Z_\.]+]] = struct.readf %arg0[@f2] : <@ComponentA2<[@C]>>, !struct.type<@ComponentA1<[5, @C]>>
//CHECK-NEXT:        function.call @ComponentA1::@constrain(%[[T0]]) : (!struct.type<@ComponentA1<[5, @C]>>) -> ()
//CHECK-NEXT:        function.return
//CHECK-NEXT:      }
//CHECK-NEXT:    }
//CHECK-NEXT:    struct.def @ComponentA3 {
//CHECK-NEXT:      struct.field @f3 : !struct.type<@ComponentA2<[43]>>
//CHECK-NEXT:      function.def @compute() -> !struct.type<@ComponentA3> attributes {function.allow_witness} {
//CHECK-NEXT:        %[[SELF:[0-9a-zA-Z_\.]+]] = struct.new : <@ComponentA3>
//CHECK-NEXT:        %[[T0:[0-9a-zA-Z_\.]+]] = function.call @ComponentA2::@compute() : () -> !struct.type<@ComponentA2<[43]>>
//CHECK-NEXT:        struct.writef %[[SELF]][@f3] = %[[T0]] : <@ComponentA3>, !struct.type<@ComponentA2<[43]>>
//CHECK-NEXT:        function.return %[[SELF]] : !struct.type<@ComponentA3>
//CHECK-NEXT:      }
//CHECK-NEXT:      function.def @constrain(%arg0: !struct.type<@ComponentA3>) attributes {function.allow_constraint} {
//CHECK-NEXT:        %[[T0:[0-9a-zA-Z_\.]+]] = struct.readf %arg0[@f3] : <@ComponentA3>, !struct.type<@ComponentA2<[43]>>
//CHECK-NEXT:        function.call @ComponentA2::@constrain(%[[T0]]) : (!struct.type<@ComponentA2<[43]>>) -> ()
//CHECK-NEXT:        function.return
//CHECK-NEXT:      }
//CHECK-NEXT:    }
//CHECK-NEXT:  }

// -----
module attributes {veridise.lang = "llzk"} {
  struct.def @ComponentB1<[@A]> {
    struct.field @f1 : !felt.type {llzk.pub}

    function.def @compute() -> !struct.type<@ComponentB1<[@A]>> {
      %self = struct.new : !struct.type<@ComponentB1<[@A]>>
      function.return %self : !struct.type<@ComponentB1<[@A]>>
    }
    function.def @constrain(%self: !struct.type<@ComponentB1<[@A]>>) { function.return }
  }

  struct.def @ComponentB2<[@C]> {
    struct.field @f2 : !felt.type

    function.def @compute(%0: !struct.type<@ComponentB1<[@C]>>) -> !struct.type<@ComponentB2<[@C]>> {
      %self = struct.new : !struct.type<@ComponentB2<[@C]>>
      %a = struct.readf %0[@f1] : !struct.type<@ComponentB1<[@C]>>, !felt.type
      struct.writef %self[@f2] = %a : !struct.type<@ComponentB2<[@C]>>, !felt.type
      function.return %self : !struct.type<@ComponentB2<[@C]>>
    }

    function.def @constrain(%self: !struct.type<@ComponentB2<[@C]>>, %0: !struct.type<@ComponentB1<[@C]>>) {
      function.return
    }
  }
}
//CHECK-LABEL: module attributes {veridise.lang = "llzk"} {
//CHECK-NEXT:    struct.def @ComponentB1<[@A]> {
//CHECK-NEXT:      struct.field @f1 : !felt.type {llzk.pub}
//CHECK-NEXT:      function.def @compute() -> !struct.type<@ComponentB1<[@A]>> attributes {function.allow_witness} {
//CHECK-NEXT:        %[[SELF:[0-9a-zA-Z_\.]+]] = struct.new : <@ComponentB1<[@A]>>
//CHECK-NEXT:        function.return %[[SELF]] : !struct.type<@ComponentB1<[@A]>>
//CHECK-NEXT:      }
//CHECK-NEXT:      function.def @constrain(%arg0: !struct.type<@ComponentB1<[@A]>>) attributes {function.allow_constraint} {
//CHECK-NEXT:        function.return
//CHECK-NEXT:      }
//CHECK-NEXT:    }
//CHECK-NEXT:    struct.def @ComponentB2<[@C]> {
//CHECK-NEXT:      struct.field @f2 : !felt.type
//CHECK-NEXT:      function.def @compute(%arg0: !struct.type<@ComponentB1<[@C]>>) -> !struct.type<@ComponentB2<[@C]>> attributes {function.allow_witness} {
//CHECK-NEXT:        %[[SELF:[0-9a-zA-Z_\.]+]] = struct.new : <@ComponentB2<[@C]>>
//CHECK-NEXT:        %[[T0:[0-9a-zA-Z_\.]+]] = struct.readf %arg0[@f1] : <@ComponentB1<[@C]>>, !felt.type
//CHECK-NEXT:        struct.writef %[[SELF]][@f2] = %[[T0]] : <@ComponentB2<[@C]>>, !felt.type
//CHECK-NEXT:        function.return %[[SELF]] : !struct.type<@ComponentB2<[@C]>>
//CHECK-NEXT:      }
//CHECK-NEXT:      function.def @constrain(%arg0: !struct.type<@ComponentB2<[@C]>>, %arg1: !struct.type<@ComponentB1<[@C]>>) attributes {function.allow_constraint} {
//CHECK-NEXT:        function.return
//CHECK-NEXT:      }
//CHECK-NEXT:    }
//CHECK-NEXT:  }

// -----
module attributes {veridise.lang = "llzk"} {
  struct.def @ComponentC1<[@A, @B]> {
    function.def @compute() -> !struct.type<@ComponentC1<[@A, @B]>> {
      %self = struct.new : !struct.type<@ComponentC1<[@A, @B]>>
      function.return %self : !struct.type<@ComponentC1<[@A, @B]>>
    }
    function.def @constrain(%self: !struct.type<@ComponentC1<[@A, @B]>>) { function.return }
  }

  struct.def @ComponentC2 {
    struct.field @f3 : !struct.type<@ComponentC1<[4, 5]>>

    function.def @compute(%a: !struct.type<@ComponentC1<[4, 5]>>) -> !struct.type<@ComponentC2> {
      %self = struct.new : !struct.type<@ComponentC2>
      struct.writef %self[@f3] = %a : !struct.type<@ComponentC2>, !struct.type<@ComponentC1<[4, 5]>>
      function.return %self : !struct.type<@ComponentC2>
    }

    function.def @constrain(%self: !struct.type<@ComponentC2>, %a: !struct.type<@ComponentC1<[4, 5]>>) {
      %b = struct.readf %self[@f3] : !struct.type<@ComponentC2>, !struct.type<@ComponentC1<[4, 5]>>
      function.call @ComponentC1::@constrain(%b) : (!struct.type<@ComponentC1<[4, 5]>>) -> ()
      function.return
    }
  }
}
//CHECK-LABEL: module attributes {veridise.lang = "llzk"} {
//CHECK-NEXT:    struct.def @ComponentC1<[@A, @B]> {
//CHECK-NEXT:      function.def @compute() -> !struct.type<@ComponentC1<[@A, @B]>> attributes {function.allow_witness} {
//CHECK-NEXT:        %[[SELF:[0-9a-zA-Z_\.]+]] = struct.new : <@ComponentC1<[@A, @B]>>
//CHECK-NEXT:        function.return %[[SELF]] : !struct.type<@ComponentC1<[@A, @B]>>
//CHECK-NEXT:      }
//CHECK-NEXT:      function.def @constrain(%arg0: !struct.type<@ComponentC1<[@A, @B]>>) attributes {function.allow_constraint} {
//CHECK-NEXT:        function.return
//CHECK-NEXT:      }
//CHECK-NEXT:    }
//CHECK-NEXT:    struct.def @ComponentC2 {
//CHECK-NEXT:      struct.field @f3 : !struct.type<@ComponentC1<[4, 5]>>
//CHECK-NEXT:      function.def @compute(%arg0: !struct.type<@ComponentC1<[4, 5]>>) -> !struct.type<@ComponentC2> attributes {function.allow_witness} {
//CHECK-NEXT:        %[[SELF:[0-9a-zA-Z_\.]+]] = struct.new : <@ComponentC2>
//CHECK-NEXT:        struct.writef %[[SELF]][@f3] = %arg0 : <@ComponentC2>, !struct.type<@ComponentC1<[4, 5]>>
//CHECK-NEXT:        function.return %[[SELF]] : !struct.type<@ComponentC2>
//CHECK-NEXT:      }
//CHECK-NEXT:      function.def @constrain(%arg0: !struct.type<@ComponentC2>, %arg1: !struct.type<@ComponentC1<[4, 5]>>) attributes {function.allow_constraint} {
//CHECK-NEXT:        %[[T0:[0-9a-zA-Z_\.]+]] = struct.readf %arg0[@f3] : <@ComponentC2>, !struct.type<@ComponentC1<[4, 5]>>
//CHECK-NEXT:        function.call @ComponentC1::@constrain(%[[T0]]) : (!struct.type<@ComponentC1<[4, 5]>>) -> ()
//CHECK-NEXT:        function.return
//CHECK-NEXT:      }
//CHECK-NEXT:    }
//CHECK-NEXT:  }

// -----
module attributes {veridise.lang = "llzk"} {
  module @a {
    struct.def @ComponentD1<[@Z]> {
      function.def @compute() -> !struct.type<@a::@ComponentD1<[@Z]>> {
        %self = struct.new : !struct.type<@a::@ComponentD1<[@Z]>>
        function.return %self : !struct.type<@a::@ComponentD1<[@Z]>>
      }
      function.def @constrain(%self: !struct.type<@a::@ComponentD1<[@Z]>>)  { function.return }
    }
  }

  module @b {
    struct.def @ComponentD2 {
      function.def @compute() -> !struct.type<@b::@ComponentD2> {
        %self = struct.new : !struct.type<@b::@ComponentD2>
        function.return %self : !struct.type<@b::@ComponentD2>
      }
      function.def @constrain(%self: !struct.type<@b::@ComponentD2>)  { function.return }
    }
  }

  function.def @fun1(%0: !struct.type<@b::@ComponentD2>) -> !struct.type<@b::@ComponentD2> {
    function.return %0 : !struct.type<@b::@ComponentD2>
  }

  function.def @fun2(%0: !struct.type<@a::@ComponentD1<[4]>>) -> !struct.type<@a::@ComponentD1<[4]>> {
    function.return %0 : !struct.type<@a::@ComponentD1<[4]>>
  }
}
//CHECK-LABEL: module attributes {veridise.lang = "llzk"} {
//CHECK-NEXT:    module @a {
//CHECK-NEXT:      struct.def @ComponentD1<[@Z]> {
//CHECK-NEXT:        function.def @compute() -> !struct.type<@a::@ComponentD1<[@Z]>> attributes {function.allow_witness} {
//CHECK-NEXT:          %[[SELF:[0-9a-zA-Z_\.]+]] = struct.new : <@a::@ComponentD1<[@Z]>>
//CHECK-NEXT:          function.return %[[SELF]] : !struct.type<@a::@ComponentD1<[@Z]>>
//CHECK-NEXT:        }
//CHECK-NEXT:        function.def @constrain(%arg0: !struct.type<@a::@ComponentD1<[@Z]>>) attributes {function.allow_constraint} {
//CHECK-NEXT:          function.return
//CHECK-NEXT:        }
//CHECK-NEXT:      }
//CHECK-NEXT:    }
//CHECK-NEXT:    module @b {
//CHECK-NEXT:      struct.def @ComponentD2 {
//CHECK-NEXT:        function.def @compute() -> !struct.type<@b::@ComponentD2> attributes {function.allow_witness} {
//CHECK-NEXT:          %[[SELF:[0-9a-zA-Z_\.]+]] = struct.new : <@b::@ComponentD2>
//CHECK-NEXT:          function.return %[[SELF]] : !struct.type<@b::@ComponentD2>
//CHECK-NEXT:        }
//CHECK-NEXT:        function.def @constrain(%arg0: !struct.type<@b::@ComponentD2>) attributes {function.allow_constraint} {
//CHECK-NEXT:          function.return
//CHECK-NEXT:        }
//CHECK-NEXT:      }
//CHECK-NEXT:    }
//CHECK-NEXT:    function.def @fun1(%arg0: !struct.type<@b::@ComponentD2>) -> !struct.type<@b::@ComponentD2> {
//CHECK-NEXT:      function.return %arg0 : !struct.type<@b::@ComponentD2>
//CHECK-NEXT:    }
//CHECK-NEXT:    function.def @fun2(%arg0: !struct.type<@a::@ComponentD1<[4]>>) -> !struct.type<@a::@ComponentD1<[4]>> {
//CHECK-NEXT:      function.return %arg0 : !struct.type<@a::@ComponentD1<[4]>>
//CHECK-NEXT:    }
//CHECK-NEXT:  }

// -----
module attributes {veridise.lang = "llzk"} {
  struct.def @ComponentE1<[@A]> {
    function.def @compute(%0: !felt.type) -> !struct.type<@ComponentE1<[@A]>> {
      %self = struct.new : !struct.type<@ComponentE1<[@A]>>
      function.return %self : !struct.type<@ComponentE1<[@A]>>
    }
    function.def @constrain(%self: !struct.type<@ComponentE1<[@A]>>, %0: !felt.type) {
      %1 = poly.read_const @A : !felt.type
      constrain.eq %0, %1 : !felt.type
      function.return
    }
  }
}
//CHECK-LABEL: module attributes {veridise.lang = "llzk"} {
//CHECK-NEXT:    struct.def @ComponentE1<[@A]> {
//CHECK-NEXT:      function.def @compute(%arg0: !felt.type) -> !struct.type<@ComponentE1<[@A]>> attributes {function.allow_witness} {
//CHECK-NEXT:        %[[SELF:[0-9a-zA-Z_\.]+]] = struct.new : <@ComponentE1<[@A]>>
//CHECK-NEXT:        function.return %[[SELF]] : !struct.type<@ComponentE1<[@A]>>
//CHECK-NEXT:      }
//CHECK-NEXT:      function.def @constrain(%arg0: !struct.type<@ComponentE1<[@A]>>, %arg1: !felt.type) attributes {function.allow_constraint} {
//CHECK-NEXT:        %[[T0:[0-9a-zA-Z_\.]+]] = poly.read_const @A : !felt.type
//CHECK-NEXT:        constrain.eq %arg1, %[[T0]] : !felt.type, !felt.type
//CHECK-NEXT:        function.return
//CHECK-NEXT:      }
//CHECK-NEXT:    }
//CHECK-NEXT:  }

// -----
module attributes {veridise.lang = "llzk"} {
  struct.def @ComponentF1<[@A]> {
    struct.field @f : !array.type<@A,@A x index>

    function.def @compute(%0: !array.type<@A,@A x index>) -> !struct.type<@ComponentF1<[@A]>> {
      %self = struct.new : !struct.type<@ComponentF1<[@A]>>
      struct.writef %self[@f] = %0 : !struct.type<@ComponentF1<[@A]>>, !array.type<@A,@A x index>
      function.return %self : !struct.type<@ComponentF1<[@A]>>
    }
    function.def @constrain(%self: !struct.type<@ComponentF1<[@A]>>, %0: !array.type<@A,@A x index>) {
      %b = struct.readf %self[@f] : !struct.type<@ComponentF1<[@A]>>, !array.type<@A,@A x index>
      function.return
    }
  }

  function.def @producer() -> !array.type<2,2 x index> {
    %1 = arith.constant 11 : index
    %2 = arith.constant 22 : index
    %3 = arith.constant 33 : index
    %4 = arith.constant 44 : index
    %r = array.new %1, %2, %3, %4 : !array.type<2,2 x index>
    function.return %r: !array.type<2,2 x index>
  }

  struct.def @ComponentF2 {
    struct.field @g : !struct.type<@ComponentF1<[2]>>

    function.def @compute() -> !struct.type<@ComponentF2> {
      %self = struct.new : !struct.type<@ComponentF2>
      %0 = function.call @producer() : () -> !array.type<2,2 x index>
      %1 = function.call @ComponentF1::@compute(%0) : (!array.type<2,2 x index>) -> !struct.type<@ComponentF1<[2]>>
      struct.writef %self[@g] = %1 : !struct.type<@ComponentF2>, !struct.type<@ComponentF1<[2]>>
      function.return %self : !struct.type<@ComponentF2>
    }
    function.def @constrain(%self: !struct.type<@ComponentF2>) {
      function.return
    }
  }
}
//CHECK-LABEL: module attributes {veridise.lang = "llzk"} {
//CHECK-NEXT:    struct.def @ComponentF1<[@A]> {
//CHECK-NEXT:      struct.field @f : !array.type<@A,@A x index>
//CHECK-NEXT:      function.def @compute(%arg0: !array.type<@A,@A x index>) -> !struct.type<@ComponentF1<[@A]>> attributes {function.allow_witness} {
//CHECK-NEXT:        %[[SELF:[0-9a-zA-Z_\.]+]] = struct.new : <@ComponentF1<[@A]>>
//CHECK-NEXT:        struct.writef %[[SELF]][@f] = %arg0 : <@ComponentF1<[@A]>>, !array.type<@A,@A x index>
//CHECK-NEXT:        function.return %[[SELF]] : !struct.type<@ComponentF1<[@A]>>
//CHECK-NEXT:      }
//CHECK-NEXT:      function.def @constrain(%arg0: !struct.type<@ComponentF1<[@A]>>, %arg1: !array.type<@A,@A x index>) attributes {function.allow_constraint} {
//CHECK-NEXT:        %[[T0:[0-9a-zA-Z_\.]+]] = struct.readf %arg0[@f] : <@ComponentF1<[@A]>>, !array.type<@A,@A x index>
//CHECK-NEXT:        function.return
//CHECK-NEXT:      }
//CHECK-NEXT:    }
//CHECK-NEXT:    function.def @producer() -> !array.type<2,2 x index> {
//CHECK-NEXT:      %[[T11:[0-9a-zA-Z_\.]+]] = arith.constant 11 : index
//CHECK-NEXT:      %[[T22:[0-9a-zA-Z_\.]+]] = arith.constant 22 : index
//CHECK-NEXT:      %[[T33:[0-9a-zA-Z_\.]+]] = arith.constant 33 : index
//CHECK-NEXT:      %[[T44:[0-9a-zA-Z_\.]+]] = arith.constant 44 : index
//CHECK-NEXT:      %array = array.new %[[T11]], %[[T22]], %[[T33]], %[[T44]] : <2,2 x index>
//CHECK-NEXT:      function.return %array : !array.type<2,2 x index>
//CHECK-NEXT:    }
//CHECK-NEXT:    struct.def @ComponentF2 {
//CHECK-NEXT:      struct.field @g : !struct.type<@ComponentF1<[2]>>
//CHECK-NEXT:      function.def @compute() -> !struct.type<@ComponentF2> attributes {function.allow_witness} {
//CHECK-NEXT:        %[[SELF:[0-9a-zA-Z_\.]+]] = struct.new : <@ComponentF2>
//CHECK-NEXT:        %[[T0:[0-9a-zA-Z_\.]+]] = function.call @producer() : () -> !array.type<2,2 x index>
//CHECK-NEXT:        %[[T1:[0-9a-zA-Z_\.]+]] = function.call @ComponentF1::@compute(%[[T0]]) : (!array.type<2,2 x index>) -> !struct.type<@ComponentF1<[2]>>
//CHECK-NEXT:        struct.writef %[[SELF]][@g] = %[[T1]] : <@ComponentF2>, !struct.type<@ComponentF1<[2]>>
//CHECK-NEXT:        function.return %[[SELF]] : !struct.type<@ComponentF2>
//CHECK-NEXT:      }
//CHECK-NEXT:      function.def @constrain(%arg0: !struct.type<@ComponentF2>) attributes {function.allow_constraint} {
//CHECK-NEXT:        function.return
//CHECK-NEXT:      }
//CHECK-NEXT:    }
//CHECK-NEXT:  }
// -----

module attributes {veridise.lang = "llzk"} {
  module @risc0 {
    struct.def @Reg {
      struct.field @reg : !felt.type {llzk.pub}

      function.def @compute(%v: !felt.type) -> !struct.type<@risc0::@Reg> {
        %self = struct.new : !struct.type<@risc0::@Reg>
        struct.writef %self[@reg] = %v : !struct.type<@risc0::@Reg>, !felt.type
        function.return %self : !struct.type<@risc0::@Reg>
      }

      function.def @constrain(%self: !struct.type<@risc0::@Reg>, %v: !felt.type) {
        %0 = struct.readf %self[@reg] : !struct.type<@risc0::@Reg>, !felt.type
        constrain.eq %v, %0 : !felt.type
        function.return
      }
    }
  }

  struct.def @Other {
    struct.field @reg : !felt.type {llzk.pub}

    function.def @compute(%v: !felt.type) -> !struct.type<@Other> {
      %self = struct.new : !struct.type<@Other>
      struct.writef %self[@reg] = %v : !struct.type<@Other>, !felt.type
      function.return %self : !struct.type<@Other>
    }

    function.def @constrain(%self: !struct.type<@Other>, %v: !felt.type) {
      %0 = struct.readf %self[@reg] : !struct.type<@Other>, !felt.type
      constrain.eq %v, %0 : !felt.type
      function.return
    }
  }

  struct.def @Bar<[@T]> {
    struct.field @t : !poly.tvar<@T>

    function.def @compute(%x: !felt.type) -> !struct.type<@Bar<[@T]>> {
      %self = struct.new : !struct.type<@Bar<[@T]>>
      // This restricts the parameter @T to be a !struct.type<?> type.
      %1 = function.call @T::@compute(%x) : (!felt.type) -> !poly.tvar<@T>
      struct.writef %self[@t] = %1 : !struct.type<@Bar<[@T]>>, !poly.tvar<@T>
      function.return %self : !struct.type<@Bar<[@T]>>
    }
    function.def @constrain(%self: !struct.type<@Bar<[@T]>>, %x: !felt.type) {
      %1 = struct.readf %self[@t] : !struct.type<@Bar<[@T]>>, !poly.tvar<@T>
      function.call @T::@constrain(%1, %x) : (!poly.tvar<@T>, !felt.type) -> ()
      function.return
    }
  }

  struct.def @Top {
    struct.field @b : !struct.type<@Bar<[!struct.type<@risc0::@Reg>]>>

    function.def @compute() -> !struct.type<@Top> {
      %self = struct.new : !struct.type<@Top>
      %1 = felt.const 2
      %2 = function.call @Bar::@compute(%1) : (!felt.type) -> !struct.type<@Bar<[!struct.type<@risc0::@Reg>]>>
      struct.writef %self[@b] = %2 : !struct.type<@Top>, !struct.type<@Bar<[!struct.type<@risc0::@Reg>]>>
      function.return %self : !struct.type<@Top>
    }

    function.def @constrain(%self: !struct.type<@Top>) {
      %1 = felt.const 2
      %2 = struct.readf %self[@b] : !struct.type<@Top>, !struct.type<@Bar<[!struct.type<@risc0::@Reg>]>>
      function.call @Bar::@constrain(%2, %1) : (!struct.type<@Bar<[!struct.type<@risc0::@Reg>]>>, !felt.type) -> ()
      function.return
    }
  }
}
//CHECK-LABEL: module attributes {veridise.lang = "llzk"} {
//CHECK-NEXT:    module @risc0 {
//CHECK-NEXT:      struct.def @Reg {
//CHECK-NEXT:        struct.field @reg : !felt.type {llzk.pub}
//CHECK-NEXT:        function.def @compute(%[[A0:[0-9a-zA-Z_\.]+]]: !felt.type) -> !struct.type<@risc0::@Reg> attributes {function.allow_witness} {
//CHECK-NEXT:          %[[SELF:[0-9a-zA-Z_\.]+]] = struct.new : <@risc0::@Reg>
//CHECK-NEXT:          struct.writef %[[SELF]][@reg] = %[[A0]] : <@risc0::@Reg>, !felt.type
//CHECK-NEXT:          function.return %[[SELF]] : !struct.type<@risc0::@Reg>
//CHECK-NEXT:        }
//CHECK-NEXT:        function.def @constrain(%[[A0:[0-9a-zA-Z_\.]+]]: !struct.type<@risc0::@Reg>, %[[A1:[0-9a-zA-Z_\.]+]]: !felt.type) attributes {function.allow_constraint} {
//CHECK-NEXT:          %[[T0:[0-9a-zA-Z_\.]+]] = struct.readf %[[A0]][@reg] : <@risc0::@Reg>, !felt.type
//CHECK-NEXT:          constrain.eq %[[A1]], %[[T0]] : !felt.type, !felt.type
//CHECK-NEXT:          function.return
//CHECK-NEXT:        }
//CHECK-NEXT:      }
//CHECK-NEXT:    }
//CHECK-NEXT:    struct.def @Other {
//CHECK-NEXT:      struct.field @reg : !felt.type {llzk.pub}
//CHECK-NEXT:      function.def @compute(%[[A0:[0-9a-zA-Z_\.]+]]: !felt.type) -> !struct.type<@Other> attributes {function.allow_witness} {
//CHECK-NEXT:        %[[SELF:[0-9a-zA-Z_\.]+]] = struct.new : <@Other>
//CHECK-NEXT:        struct.writef %[[SELF]][@reg] = %[[A0]] : <@Other>, !felt.type
//CHECK-NEXT:        function.return %[[SELF]] : !struct.type<@Other>
//CHECK-NEXT:      }
//CHECK-NEXT:      function.def @constrain(%[[A0:[0-9a-zA-Z_\.]+]]: !struct.type<@Other>, %[[A1:[0-9a-zA-Z_\.]+]]: !felt.type) attributes {function.allow_constraint} {
//CHECK-NEXT:        %[[T0:[0-9a-zA-Z_\.]+]] = struct.readf %[[A0]][@reg] : <@Other>, !felt.type
//CHECK-NEXT:        constrain.eq %[[A1]], %[[T0]] : !felt.type, !felt.type
//CHECK-NEXT:        function.return
//CHECK-NEXT:      }
//CHECK-NEXT:    }
//CHECK-NEXT:    struct.def @Bar<[@T]> {
//CHECK-NEXT:      struct.field @t : !poly.tvar<@T>
//CHECK-NEXT:      function.def @compute(%[[A0:[0-9a-zA-Z_\.]+]]: !felt.type) -> !struct.type<@Bar<[@T]>> attributes {function.allow_witness} {
//CHECK-NEXT:        %[[SELF:[0-9a-zA-Z_\.]+]] = struct.new : <@Bar<[@T]>>
//CHECK-NEXT:        %[[T0:[0-9a-zA-Z_\.]+]] = function.call @T::@compute(%[[A0]]) : (!felt.type) -> !poly.tvar<@T>
//CHECK-NEXT:        struct.writef %[[SELF]][@t] = %[[T0]] : <@Bar<[@T]>>, !poly.tvar<@T>
//CHECK-NEXT:        function.return %[[SELF]] : !struct.type<@Bar<[@T]>>
//CHECK-NEXT:      }
//CHECK-NEXT:      function.def @constrain(%[[A0:[0-9a-zA-Z_\.]+]]: !struct.type<@Bar<[@T]>>, %[[A1:[0-9a-zA-Z_\.]+]]: !felt.type) attributes {function.allow_constraint} {
//CHECK-NEXT:        %[[T0:[0-9a-zA-Z_\.]+]] = struct.readf %[[A0]][@t] : <@Bar<[@T]>>, !poly.tvar<@T>
//CHECK-NEXT:        function.call @T::@constrain(%[[T0]], %[[A1]]) : (!poly.tvar<@T>, !felt.type) -> ()
//CHECK-NEXT:        function.return
//CHECK-NEXT:      }
//CHECK-NEXT:    }
//CHECK-NEXT:    struct.def @Top {
//CHECK-NEXT:      struct.field @b : !struct.type<@Bar<[!struct.type<@risc0::@Reg>]>>
//CHECK-NEXT:      function.def @compute() -> !struct.type<@Top> attributes {function.allow_witness} {
//CHECK-NEXT:        %[[SELF:[0-9a-zA-Z_\.]+]] = struct.new : <@Top>
//CHECK-NEXT:        %[[C2:[0-9a-zA-Z_\.]+]] = felt.const 2
//CHECK-NEXT:        %[[T0:[0-9a-zA-Z_\.]+]] = function.call @Bar::@compute(%[[C2]]) : (!felt.type) -> !struct.type<@Bar<[!struct.type<@risc0::@Reg>]>>
//CHECK-NEXT:        struct.writef %[[SELF]][@b] = %[[T0]] : <@Top>, !struct.type<@Bar<[!struct.type<@risc0::@Reg>]>>
//CHECK-NEXT:        function.return %[[SELF]] : !struct.type<@Top>
//CHECK-NEXT:      }
//CHECK-NEXT:      function.def @constrain(%[[A0:[0-9a-zA-Z_\.]+]]: !struct.type<@Top>) attributes {function.allow_constraint} {
//CHECK-NEXT:        %[[C2:[0-9a-zA-Z_\.]+]] = felt.const 2
//CHECK-NEXT:        %[[T0:[0-9a-zA-Z_\.]+]] = struct.readf %[[A0]][@b] : <@Top>, !struct.type<@Bar<[!struct.type<@risc0::@Reg>]>>
//CHECK-NEXT:        function.call @Bar::@constrain(%[[T0]], %[[C2]]) : (!struct.type<@Bar<[!struct.type<@risc0::@Reg>]>>, !felt.type) -> ()
//CHECK-NEXT:        function.return
//CHECK-NEXT:      }
//CHECK-NEXT:    }
//CHECK-NEXT:  }
