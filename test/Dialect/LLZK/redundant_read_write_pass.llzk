// RUN: llzk-opt -split-input-file -llzk-duplicate-read-write-elim %s 2>&1 | FileCheck %s

module attributes {veridise.lang = "llzk"} {

  llzk.struct @Subcomponent {
    func @compute() -> !llzk.struct<@Subcomponent> {
      %self = new_struct : !llzk.struct<@Subcomponent>
      return %self : !llzk.struct<@Subcomponent>
    }
    func @constrain(%self: !llzk.struct<@Subcomponent>) { return }
  }

  llzk.struct @Component {
    field @sub1 : !llzk.struct<@Subcomponent>
    field @sub2 : !llzk.struct<@Subcomponent>

    func @compute() -> !llzk.struct<@Component> {
      %self = new_struct : !llzk.struct<@Component>
      // All these reads are unused, so they will be removed
      %sub1 = readf %self[@sub1] : !llzk.struct<@Component>, !llzk.struct<@Subcomponent>
      %sub2 = readf %self[@sub2] : !llzk.struct<@Component>, !llzk.struct<@Subcomponent>
      %sub3 = readf %self[@sub2] : !llzk.struct<@Component>, !llzk.struct<@Subcomponent>
      return %self : !llzk.struct<@Component>
    }
    func @constrain(%self: !llzk.struct<@Component>) { return }
  }
}

// CHECK-LABEL: module attributes {veridise.lang = "llzk"} {
// CHECK-NEXT:   llzk.struct @Subcomponent {
// CHECK-NEXT:     func @compute() -> !llzk.struct<@Subcomponent> {
// CHECK-NEXT:       %self = new_struct : <@Subcomponent>
// CHECK-NEXT:       return %self : !llzk.struct<@Subcomponent>
// CHECK-NEXT:     }
// CHECK-NEXT:     func @constrain(%arg0: !llzk.struct<@Subcomponent>) {
// CHECK-NEXT:       return
// CHECK-NEXT:     }
// CHECK-NEXT:   }
// CHECK-NEXT:   llzk.struct @Component {
// CHECK-NEXT:     field @sub1 : !llzk.struct<@Subcomponent>
// CHECK-NEXT:     field @sub2 : !llzk.struct<@Subcomponent>
// CHECK-NEXT:     func @compute() -> !llzk.struct<@Component> {
// CHECK-NEXT:       %self = new_struct : <@Component>
// CHECK-NEXT:       return %self : !llzk.struct<@Component>
// CHECK-NEXT:     }
// CHECK-NEXT:     func @constrain(%arg0: !llzk.struct<@Component>) {
// CHECK-NEXT:       return
// CHECK-NEXT:     }
// CHECK-NEXT:   }
// CHECK-NEXT: }

// -----

module attributes {veridise.lang = "llzk"} {
  llzk.struct @Component {
    field @f : !llzk.felt

    func @compute(%arg : !llzk.felt) -> !llzk.struct<@Component> {
      %self = new_struct : !llzk.struct<@Component>
      writef %self[@f] = %arg: !llzk.struct<@Component>, !llzk.felt
      // redundant write
      writef %self[@f] = %arg: !llzk.struct<@Component>, !llzk.felt
      return %self : !llzk.struct<@Component>
    }
    func @constrain(%self: !llzk.struct<@Component>, %arg : !llzk.felt) { return }
  }
}

// CHECK-LABEL: module attributes {veridise.lang = "llzk"} {
// CHECK-NEXT:   llzk.struct @Component {
// CHECK-NEXT:     field @f : !llzk.felt
// CHECK-NEXT:     func @compute(%arg0: !llzk.felt) -> !llzk.struct<@Component> {
// CHECK-NEXT:       %self = new_struct : <@Component>
// CHECK-NEXT:       writef %self[@f] = %arg0 : <@Component>, !llzk.felt
// CHECK-NEXT:       return %self : !llzk.struct<@Component>
// CHECK-NEXT:     }
// CHECK-NEXT:     func @constrain(%arg0: !llzk.struct<@Component>, %arg1: !llzk.felt) {
// CHECK-NEXT:       return
// CHECK-NEXT:     }
// CHECK-NEXT:   }
// CHECK-NEXT: }


// -----

module attributes {veridise.lang = "llzk"} {
  llzk.struct @Component {
    field @arr : !llzk.array<3 x !llzk.felt>

    func @compute(%arg : !llzk.felt) -> !llzk.struct<@Component> {
      %self = new_struct : !llzk.struct<@Component>
      %arr = readf %self[@arr] : !llzk.struct<@Component>, !llzk.array<3 x !llzk.felt>
      %idx = arith.constant 1 : index
      writearr %arr[%idx] = %arg : !llzk.array<3 x !llzk.felt>, !llzk.felt
      %newarr = new_array %arg, %arg, %arg : !llzk.array<3 x !llzk.felt> // ends up being unused after removing the below ops, can also be removed
      %elem = readarr %newarr[%idx] : !llzk.array<3 x !llzk.felt>, !llzk.felt // this is just %arg, redundant
      writearr %arr[%idx] = %elem : !llzk.array<3 x !llzk.felt>, !llzk.felt // redundant write, this idx is already %arg
      return %self : !llzk.struct<@Component>
    }
    func @constrain(%self: !llzk.struct<@Component>, %arg : !llzk.felt) { return }
  }
}

// CHECK-LABEL: module attributes {veridise.lang = "llzk"} {
// CHECK-NEXT:   llzk.struct @Component {
// CHECK-NEXT:     field @arr : !llzk.array<3 x !llzk.felt>
// CHECK-NEXT:     func @compute(%arg0: !llzk.felt) -> !llzk.struct<@Component> {
// CHECK-NEXT:       %self = new_struct : <@Component>
// CHECK-NEXT:       %0 = readf %self[@arr] : <@Component>, !llzk.array<3 x !llzk.felt>
// CHECK-NEXT:       %c1 = arith.constant 1 : index
// CHECK-NEXT:       writearr %0[%c1] = %arg0 : <3 x !llzk.felt>, !llzk.felt
// CHECK-NEXT:       return %self : !llzk.struct<@Component>
// CHECK-NEXT:     }
// CHECK-NEXT:     func @constrain(%arg0: !llzk.struct<@Component>, %arg1: !llzk.felt) {
// CHECK-NEXT:       return
// CHECK-NEXT:     }
// CHECK-NEXT:   }
// CHECK-NEXT: }

// -----

module attributes {veridise.lang = "llzk"} {
  llzk.struct @Component {
    field @matrix : !llzk.array<7,3 x !llzk.felt>

    func @compute(%inputArr : !llzk.array<3 x !llzk.felt>) -> !llzk.struct<@Component> {
      %self = new_struct : !llzk.struct<@Component>
      %mat = readf %self[@matrix] : !llzk.struct<@Component>, !llzk.array<7,3 x !llzk.felt>
      %idx1 = arith.constant 1 : index
      %idx4 = arith.constant 4 : index
      insertarr %mat[%idx1] = %inputArr : !llzk.array<7,3 x !llzk.felt>, !llzk.array<3 x !llzk.felt>
      %arr1 = extractarr %mat[%idx1] : !llzk.array<7,3 x !llzk.felt> // redundant, replace with %inputArr
      insertarr %mat[%idx4] = %arr1 : !llzk.array<7,3 x !llzk.felt>, !llzk.array<3 x !llzk.felt> // replace %arr1 with %inputArr
      insertarr %mat[%idx1] = %arr1 : !llzk.array<7,3 x !llzk.felt>, !llzk.array<3 x !llzk.felt> // redundant
      return %self : !llzk.struct<@Component>
    }
    func @constrain(%self: !llzk.struct<@Component>, %inputArr : !llzk.array<3 x !llzk.felt>) {
      %mat = readf %self[@matrix] : !llzk.struct<@Component>, !llzk.array<7,3 x !llzk.felt>
      %i = arith.constant 2 : index
      %j = arith.constant 3 : index
      %k = arith.constant 3 : index // redundant constant
      %arr_i = extractarr %mat[%i] : !llzk.array<7,3 x !llzk.felt>
      %arr_j = extractarr %mat[%j] : !llzk.array<7,3 x !llzk.felt>
      %arr_k = extractarr %mat[%k] : !llzk.array<7,3 x !llzk.felt> // redundant extract
      emit_eq %arr_i, %arr_j : !llzk.array<3 x !llzk.felt>
      emit_eq %arr_j, %arr_k : !llzk.array<3 x !llzk.felt> // this constraint is redundant, but will not be removed in this pass
      emit_eq %arr_k, %arr_i : !llzk.array<3 x !llzk.felt> // same with above
      return
    }
  }
}

// CHECK-LABEL: module attributes {veridise.lang = "llzk"} {
// CHECK-NEXT:   llzk.struct @Component {
// CHECK-NEXT:     field @matrix : !llzk.array<7,3 x !llzk.felt>
// CHECK-NEXT:     func @compute(%arg0: !llzk.array<3 x !llzk.felt>) -> !llzk.struct<@Component> {
// CHECK-NEXT:       %self = new_struct : <@Component>
// CHECK-NEXT:       %0 = readf %self[@matrix] : <@Component>, !llzk.array<7,3 x !llzk.felt>
// CHECK-NEXT:       %c1 = arith.constant 1 : index
// CHECK-NEXT:       %c4 = arith.constant 4 : index
// CHECK-NEXT:       insertarr %0[%c1] = %arg0 : <7,3 x !llzk.felt>, <3 x !llzk.felt>
// CHECK-NEXT:       insertarr %0[%c4] = %arg0 : <7,3 x !llzk.felt>, <3 x !llzk.felt>
// CHECK-NEXT:       return %self : !llzk.struct<@Component>
// CHECK-NEXT:     }
// CHECK-NEXT:     func @constrain(%arg0: !llzk.struct<@Component>, %arg1: !llzk.array<3 x !llzk.felt>) {
// CHECK-NEXT:       %0 = readf %arg0[@matrix] : <@Component>, !llzk.array<7,3 x !llzk.felt>
// CHECK-NEXT:       %c2 = arith.constant 2 : index
// CHECK-NEXT:       %c3 = arith.constant 3 : index
// CHECK-NEXT:       %c3_0 = arith.constant 3 : index
// CHECK-NEXT:       %1 = extractarr %0[%c2] : <7,3 x !llzk.felt>
// CHECK-NEXT:       %2 = extractarr %0[%c3] : <7,3 x !llzk.felt>
// CHECK-NEXT:       emit_eq %1, %2 : !llzk.array<3 x !llzk.felt>, !llzk.array<3 x !llzk.felt>
// CHECK-NEXT:       emit_eq %2, %2 : !llzk.array<3 x !llzk.felt>, !llzk.array<3 x !llzk.felt>
// CHECK-NEXT:       emit_eq %2, %1 : !llzk.array<3 x !llzk.felt>, !llzk.array<3 x !llzk.felt>
// CHECK-NEXT:       return
// CHECK-NEXT:     }
// CHECK-NEXT:   }
// CHECK-NEXT: }

// -----

module attributes {veridise.lang = "llzk"} {
  llzk.struct @Component {
    field @arr : !llzk.array<3 x !llzk.felt>

    func @compute(%arg : !llzk.felt, %inputIdx : index) -> !llzk.struct<@Component> {
      %self = new_struct : !llzk.struct<@Component>
      %arr = readf %self[@arr] : !llzk.struct<@Component>, !llzk.array<3 x !llzk.felt>
      %idx = arith.constant 1 : index
      %idx2 = arith.constant 2 : index
      writearr %arr[%idx] = %arg : !llzk.array<3 x !llzk.felt>, !llzk.felt
      writearr %arr[%inputIdx] = %arg : !llzk.array<3 x !llzk.felt>, !llzk.felt
      // this read is necessary in the case that %inputIdx == %idx
      %elem1 = readarr %arr[%idx] : !llzk.array<3 x !llzk.felt>, !llzk.felt
      %elem2 = readarr %arr[%inputIdx] : !llzk.array<3 x !llzk.felt>, !llzk.felt
      writearr %arr[%idx] = %elem2 : !llzk.array<3 x !llzk.felt>, !llzk.felt
      writearr %arr[%idx2] = %elem1 : !llzk.array<3 x !llzk.felt>, !llzk.felt
      return %self : !llzk.struct<@Component>
    }
    func @constrain(%self: !llzk.struct<@Component>, %arg : !llzk.felt, %inputIdx : index) { return }
  }
}

// CHECK-LABEL: module attributes {veridise.lang = "llzk"} {
// CHECK-NEXT:   llzk.struct @Component {
// CHECK-NEXT:     field @arr : !llzk.array<3 x !llzk.felt>
// CHECK-NEXT:     func @compute(%arg0: !llzk.felt, %arg1: index) -> !llzk.struct<@Component> {
// CHECK-NEXT:       %self = new_struct : <@Component>
// CHECK-NEXT:       %0 = readf %self[@arr] : <@Component>, !llzk.array<3 x !llzk.felt>
// CHECK-NEXT:       %c1 = arith.constant 1 : index
// CHECK-NEXT:       %c2 = arith.constant 2 : index
// CHECK-NEXT:       writearr %0[%c1] = %arg0 : <3 x !llzk.felt>, !llzk.felt
// CHECK-NEXT:       writearr %0[%arg1] = %arg0 : <3 x !llzk.felt>, !llzk.felt
// CHECK-NEXT:       %1 = readarr %0[%c1] : <3 x !llzk.felt>, !llzk.felt
// CHECK-NEXT:       writearr %0[%c1] = %arg0 : <3 x !llzk.felt>, !llzk.felt
// CHECK-NEXT:       writearr %0[%c2] = %1 : <3 x !llzk.felt>, !llzk.felt
// CHECK-NEXT:       return %self : !llzk.struct<@Component>
// CHECK-NEXT:     }
// CHECK-NEXT:     func @constrain(%arg0: !llzk.struct<@Component>, %arg1: !llzk.felt, %arg2: index) {
// CHECK-NEXT:       return
// CHECK-NEXT:     }
// CHECK-NEXT:   }
// CHECK-NEXT: }

// -----

module attributes {veridise.lang = "llzk"} {
  // A modified version of IsZero that includes some redundancy
  llzk.struct @IsZero {
    llzk.field @bit : !llzk.felt
    llzk.field @zero : !llzk.felt
    llzk.field @one : !llzk.felt

    func @compute(%a: !llzk.felt) -> !llzk.struct<@IsZero> {
      %self = new_struct : !llzk.struct<@IsZero>
      %z = llzk.constfelt 0
      %o = llzk.constfelt 1
      llzk.writef %self[@zero] = %z : !llzk.struct<@IsZero>, !llzk.felt
      llzk.writef %self[@one] = %o : !llzk.struct<@IsZero>, !llzk.felt
      %b = llzk.cmp eq(%a, %z)
      %0 = scf.if %b -> !llzk.felt {
        %z1 = llzk.readf %self[@zero] : !llzk.struct<@IsZero>, !llzk.felt
        scf.yield %z1 : !llzk.felt
      } else {
        %o1 = llzk.readf %self[@one] : !llzk.struct<@IsZero>, !llzk.felt
        scf.yield %o1 : !llzk.felt
      }
      llzk.writef %self[@bit] = %0 : !llzk.struct<@IsZero>, !llzk.felt
      return %self : !llzk.struct<@IsZero>
    }

    func @constrain(%self : !llzk.struct<@IsZero>, %a: !llzk.felt) {
      %0 = llzk.readf %self[@bit] : !llzk.struct<@IsZero>, !llzk.felt
      %1 = llzk.constfelt 1
      %2 = llzk.sub %0, %1
      %3 = llzk.mul %0, %2
      %4 = llzk.constfelt 0
      llzk.emit_eq %3, %4 : !llzk.felt
      %z1 = llzk.readf %self[@zero] : !llzk.struct<@IsZero>, !llzk.felt
      %o1 = llzk.readf %self[@one] : !llzk.struct<@IsZero>, !llzk.felt
      llzk.emit_eq %z1, %4 : !llzk.felt
      llzk.emit_eq %o1, %1 : !llzk.felt
      return
    }
  }
}

// CHECK-LABEL: module attributes {veridise.lang = "llzk"} {
// CHECK-NEXT:   llzk.struct @IsZero {
// CHECK-NEXT:     field @bit : !llzk.felt
// CHECK-NEXT:     field @zero : !llzk.felt
// CHECK-NEXT:     field @one : !llzk.felt
// CHECK-NEXT:     func @compute(%arg0: !llzk.felt) -> !llzk.struct<@IsZero> {
// CHECK-NEXT:       %self = new_struct : <@IsZero>
// CHECK-NEXT:       %felt_const_0 = constfelt  0
// CHECK-NEXT:       %felt_const_1 = constfelt  1
// CHECK-NEXT:       writef %self[@zero] = %felt_const_0 : <@IsZero>, !llzk.felt
// CHECK-NEXT:       writef %self[@one] = %felt_const_1 : <@IsZero>, !llzk.felt
// CHECK-NEXT:       %0 = cmp eq(%arg0, %felt_const_0)
// CHECK-NEXT:       %1 = scf.if %0 -> (!llzk.felt) {
// CHECK-NEXT:         scf.yield %felt_const_0 : !llzk.felt
// CHECK-NEXT:       } else {
// CHECK-NEXT:         scf.yield %felt_const_1 : !llzk.felt
// CHECK-NEXT:       }
// CHECK-NEXT:       writef %self[@bit] = %1 : <@IsZero>, !llzk.felt
// CHECK-NEXT:       return %self : !llzk.struct<@IsZero>
// CHECK-NEXT:     }
// CHECK-NEXT:     func @constrain(%arg0: !llzk.struct<@IsZero>, %arg1: !llzk.felt) {
// CHECK-NEXT:       %0 = readf %arg0[@bit] : <@IsZero>, !llzk.felt
// CHECK-NEXT:       %felt_const_1 = constfelt  1
// CHECK-NEXT:       %1 = sub %0, %felt_const_1 : !llzk.felt, !llzk.felt
// CHECK-NEXT:       %2 = mul %0, %1 : !llzk.felt, !llzk.felt
// CHECK-NEXT:       %felt_const_0 = constfelt  0
// CHECK-NEXT:       emit_eq %2, %felt_const_0 : !llzk.felt, !llzk.felt
// CHECK-NEXT:       %3 = readf %arg0[@zero] : <@IsZero>, !llzk.felt
// CHECK-NEXT:       %4 = readf %arg0[@one] : <@IsZero>, !llzk.felt
// CHECK-NEXT:       emit_eq %3, %felt_const_0 : !llzk.felt, !llzk.felt
// CHECK-NEXT:       emit_eq %4, %felt_const_1 : !llzk.felt, !llzk.felt
// CHECK-NEXT:       return
// CHECK-NEXT:     }
// CHECK-NEXT:   }
// CHECK-NEXT: }

// -----

module attributes {veridise.lang = "llzk"} {
  llzk.struct @Component {
    field @matrix : !llzk.array<7,3 x !llzk.felt>

    func @compute(%inputArr : !llzk.array<3 x !llzk.felt>, %cond : i1) -> !llzk.struct<@Component> {
      %self = new_struct : !llzk.struct<@Component>
      %mat = readf %self[@matrix] : !llzk.struct<@Component>, !llzk.array<7,3 x !llzk.felt>
      %idx1 = arith.constant 1 : index
      %idx4 = arith.constant 4 : index

      scf.if %cond {
        llzk.insertarr %mat[%idx1] = %inputArr : !llzk.array<7,3 x !llzk.felt>, !llzk.array<3 x !llzk.felt>
      } else {
        %arr1 = llzk.extractarr %mat[%idx1] : !llzk.array<7,3 x !llzk.felt> // This load is necessary, as the value is unknown in this branch
        llzk.insertarr %mat[%idx4] = %arr1 : !llzk.array<7,3 x !llzk.felt>, !llzk.array<3 x !llzk.felt>
        llzk.insertarr %mat[%idx1] = %arr1 : !llzk.array<7,3 x !llzk.felt>, !llzk.array<3 x !llzk.felt> // this store is still unnecessary
      }

      return %self : !llzk.struct<@Component>
    }
    func @constrain(%self: !llzk.struct<@Component>, %inputArr : !llzk.array<3 x !llzk.felt>, %cond : i1) {
      return
    }
  }
}

// CHECK-LABEL: module attributes {veridise.lang = "llzk"} {
// CHECK-NEXT:   llzk.struct @Component {
// CHECK-NEXT:     field @matrix : !llzk.array<7,3 x !llzk.felt>
// CHECK-NEXT:     func @compute(%arg0: !llzk.array<3 x !llzk.felt>, %arg1: i1) -> !llzk.struct<@Component> {
// CHECK-NEXT:       %self = new_struct : <@Component>
// CHECK-NEXT:       %0 = readf %self[@matrix] : <@Component>, !llzk.array<7,3 x !llzk.felt>
// CHECK-NEXT:       %c1 = arith.constant 1 : index
// CHECK-NEXT:       %c4 = arith.constant 4 : index
// CHECK-NEXT:       scf.if %arg1 {
// CHECK-NEXT:         llzk.insertarr %0[%c1] = %arg0 : <7,3 x !llzk.felt>, <3 x !llzk.felt>
// CHECK-NEXT:       } else {
// CHECK-NEXT:         %1 = llzk.extractarr %0[%c1] : <7,3 x !llzk.felt>
// CHECK-NEXT:         llzk.insertarr %0[%c4] = %1 : <7,3 x !llzk.felt>, <3 x !llzk.felt>
// CHECK-NEXT:       }
// CHECK-NEXT:       return %self : !llzk.struct<@Component>
// CHECK-NEXT:     }
// CHECK-NEXT:     func @constrain(%arg0: !llzk.struct<@Component>, %arg1: !llzk.array<3 x !llzk.felt>, %arg2: i1) {
// CHECK-NEXT:       return
// CHECK-NEXT:     }
// CHECK-NEXT:   }
// CHECK-NEXT: }