// RUN: llzk-opt -split-input-file -verify-diagnostics %s

// Test: [constrain.in] type annotation does not match type of parameter 2 in size
module attributes {veridise.lang = "llzk"} {
  struct.def @TestComponent01 {
    function.def @compute() -> !struct.struct<@TestComponent01> {
      %self = struct.new : !struct.struct<@TestComponent01>
      function.return %self : !struct.struct<@TestComponent01>
    }
    function.def @constrain(
          %a: !felt.felt,
          %b: !array.array<5 x !felt.felt> // expected-note {{prior use here}}
          ) {
      // expected-error@+1 {{use of value '%b' expects different type than prior uses: '!array.array<6 x !felt.felt>' vs '!array.array<5 x !felt.felt>'}}
      constrain.in %b, %a : !array.array<6 x !felt.felt>
      function.return
    }
  }
}
// -----

// Test: [constrain.in] type annotation does not match type of parameter 2 in element type
module attributes {veridise.lang = "llzk"} {
  struct.def @TestComponent02 {
    function.def @compute() -> !struct.struct<@TestComponent02> {
      %self = struct.new : !struct.struct<@TestComponent02>
      function.return %self : !struct.struct<@TestComponent02>
    }
    function.def @constrain(
          %a: index,
          %b: !array.array<5 x !felt.felt> // expected-note {{prior use here}}
          ) {
      // expected-error@+1 {{use of value '%b' expects different type than prior uses: '!array.array<5 x index>' vs '!array.array<5 x !felt.felt>'}}
      constrain.in %b, %a : !array.array<5 x index>
      function.return
    }
  }
}
// -----

// Test: [constrain.in] type of parameter 1 does not match array element type of annotation
module attributes {veridise.lang = "llzk"} {
  struct.def @TestComponent03 {
    function.def @compute() -> !struct.struct<@TestComponent03> {
      %self = struct.new : !struct.struct<@TestComponent03>
      function.return %self : !struct.struct<@TestComponent03>
    }
    function.def @constrain(
          %a: index, // expected-note {{prior use here}}
          %b: !array.array<5 x !felt.felt>
          ) {
      // expected-error@+1 {{use of value '%a' expects different type than prior uses: '!felt.felt' vs 'index'}}
      constrain.in %b, %a : !array.array<5 x !felt.felt>
      function.return
    }
  }
}
// -----

// Test: [constrain.in] type annotation is not an array type
module attributes {veridise.lang = "llzk"} {
  struct.def @TestComponent04 {
    function.def @compute() -> !struct.struct<@TestComponent04> {
      %self = struct.new : !struct.struct<@TestComponent04>
      function.return %self : !struct.struct<@TestComponent04>
    }
    function.def @constrain(%a: !felt.felt, %b: !felt.felt) {
      // expected-error@+1 {{custom op 'constrain.in' invalid kind of Type specified}}
      constrain.in %b, %a : !felt.felt
      function.return
    }
  }
}
// -----

// Test: [constrain.in] type of parameter 2 is not an array
module attributes {veridise.lang = "llzk"} {
  struct.def @TestComponent05 {
    function.def @compute() -> !struct.struct<@TestComponent05> {
      %self = struct.new : !struct.struct<@TestComponent05>
      function.return %self : !struct.struct<@TestComponent05>
    }
    function.def @constrain(
          %a: !felt.felt,
          %b: !felt.felt  // expected-note {{prior use here}}
          ) {
      // expected-error@+1 {{use of value '%b' expects different type than prior uses: '!array.array<5 x !felt.felt>' vs '!felt.felt'}}
      constrain.in %b, %a : !array.array<5 x !felt.felt>
      function.return
    }
  }
}
// -----

// Test: [constrain.in] type of parameter 1 does not match array element type of parameter 2
module attributes {veridise.lang = "llzk"} {
  struct.def @TestComponent06 {
    function.def @compute() -> !struct.struct<@TestComponent06> {
      %self = struct.new : !struct.struct<@TestComponent06>
      function.return %self : !struct.struct<@TestComponent06>
    }
    function.def @constrain(
          %a: index, // expected-note {{prior use here}}
          %b: !array.array<5 x !felt.felt>
          ) {
      // expected-error@+1 {{use of value '%a' expects different type than prior uses: '!felt.felt' vs 'index'}}
      constrain.in %b, %a : !array.array<5 x !felt.felt>
      function.return
    }
  }
}
// -----

// Test: [constrain.eq] lhs has invalid type
module attributes {veridise.lang = "llzk"} {
  struct.def @TestComponent07 {
    function.def @compute() -> !struct.struct<@TestComponent07> {
      %self = struct.new : !struct.struct<@TestComponent07>
      function.return %self : !struct.struct<@TestComponent07>
    }
    function.def @constrain(
          %a: !struct.struct<@TestComponent07>, // expected-note {{prior use here}}
          %b: !felt.felt
          ) {
      // expected-error@+1 {{use of value '%a' expects different type than prior uses: '!felt.felt' vs '!struct.struct<@TestComponent07>'}}
      constrain.eq %a, %b : !felt.felt
      function.return
    }
  }
}
// -----

// Test: [constrain.eq] rhs has invalid type
module attributes {veridise.lang = "llzk"} {
  struct.def @TestComponent08 {
    function.def @compute() -> !struct.struct<@TestComponent08> {
      %self = struct.new : !struct.struct<@TestComponent08>
      function.return %self : !struct.struct<@TestComponent08>
    }
    function.def @constrain(
          %a: index,
          %b: !struct.struct<@TestComponent08> // expected-note {{prior use here}}
          ) {
      // expected-error@+1 {{use of value '%b' expects different type than prior uses: 'index' vs '!struct.struct<@TestComponent08>'}}
      constrain.eq %a, %b : index
      function.return
    }
  }
}
// -----

// Test: [constrain.eq] lhs type does not match the given type
module attributes {veridise.lang = "llzk"} {
  struct.def @TestComponent09 {
    function.def @compute() -> !struct.struct<@TestComponent09> {
      %self = struct.new : !struct.struct<@TestComponent09>
      function.return %self : !struct.struct<@TestComponent09>
    }
    function.def @constrain(
          %a: !felt.felt, // expected-note {{prior use here}}
          %b: index
          ) {
      // expected-error@+1 {{use of value '%a' expects different type than prior uses: 'index' vs '!felt.felt'}}
      constrain.eq %a, %b : index
      function.return
    }
  }
}
// -----

// Test: [constrain.eq] rhs type does not match the given type
module attributes {veridise.lang = "llzk"} {
  struct.def @TestComponent10 {
    function.def @compute() -> !struct.struct<@TestComponent10> {
      %self = struct.new : !struct.struct<@TestComponent10>
      function.return %self : !struct.struct<@TestComponent10>
    }
    function.def @constrain(
          %a: index,
          %b: !felt.felt // expected-note {{prior use here}}
          ) {
      // expected-error@+1 {{use of value '%b' expects different type than prior uses: 'index' vs '!felt.felt'}}
      constrain.eq %a, %b : index
      function.return
    }
  }
}
// -----

// Test: [constrain.eq] both sides have invalid (although the same) type
module attributes {veridise.lang = "llzk"} {
  struct.def @TestComponent11 {
    function.def @compute() -> !struct.struct<@TestComponent11> {
      %self = struct.new : !struct.struct<@TestComponent11>
      function.return %self : !struct.struct<@TestComponent11>
    }
    function.def @constrain(
          %a: !struct.struct<@TestComponent11>,
          %b: !struct.struct<@TestComponent11>
          ) {
      // expected-error@+1 {{'constrain.eq' op operand #0 must be any LLZK type, excluding non-Signal struct and string types, but got '!struct.struct<@TestComponent11>'}}
      constrain.eq %a, %b : !struct.struct<@TestComponent11>
      function.return
    }
  }
}
// -----

// Test: [constrain.eq] both sides have invalid (although the same) type
module attributes {veridise.lang = "llzk"} {
  struct.def @TestComponent12 {
    function.def @compute() -> !struct.struct<@TestComponent12> {
      %self = struct.new : !struct.struct<@TestComponent12>
      function.return %self : !struct.struct<@TestComponent12>
    }
    function.def @constrain(
          %a: !array.array<3 x !struct.struct<@TestComponent12>>,
          %b: !array.array<3 x !struct.struct<@TestComponent12>>
          ) {
      // expected-error@+1 {{'constrain.eq' op operand #0 must be any LLZK type, excluding non-Signal struct and string types, but got '!array.array<3 x !struct.struct<@TestComponent12>>'}}
      constrain.eq %a, %b : !array.array<3 x !struct.struct<@TestComponent12>>
      function.return
    }
  }
}
// -----

// Test: [constrain.eq] both sides have invalid (although the same) type
module attributes {veridise.lang = "llzk"} {
  struct.def @TestComponent13 {
    function.def @compute() -> !struct.struct<@TestComponent13> {
      %self = struct.new : !struct.struct<@TestComponent13>
      function.return %self : !struct.struct<@TestComponent13>
    }
    function.def @constrain(
          %a: !array.array<3,2 x !struct.struct<@TestComponent13>>,
          %b: !array.array<3,2 x !struct.struct<@TestComponent13>>
          ) {
      // expected-error@+1 {{'constrain.eq' op operand #0 must be any LLZK type, excluding non-Signal struct and string types, but got '!array.array<3,2 x !struct.struct<@TestComponent13>>'}}
      constrain.eq %a, %b : !array.array<3,2 x !struct.struct<@TestComponent13>>
      function.return
    }
  }
}
// -----

// Test: [constrain.eq] lhs array size does not match the type given
module attributes {veridise.lang = "llzk"} {
  struct.def @TestComponent14 {
    function.def @compute() -> !struct.struct<@TestComponent14> {
      %self = struct.new : !struct.struct<@TestComponent14>
      function.return %self : !struct.struct<@TestComponent14>
    }
    function.def @constrain(
          %a: !array.array<9 x index>, // expected-note {{prior use here}}
          %b: !array.array<3 x index>
          ) {
      // expected-error@+1 {{use of value '%a' expects different type than prior uses: '!array.array<3 x index>' vs '!array.array<9 x index>'}}
      constrain.eq %a, %b : !array.array<3 x index>
      function.return
    }
  }
}
// -----

// Test: [constrain.eq] rhs array size does not match the type given
module attributes {veridise.lang = "llzk"} {
  struct.def @TestComponent15 {
    function.def @compute() -> !struct.struct<@TestComponent15> {
      %self = struct.new : !struct.struct<@TestComponent15>
      function.return %self : !struct.struct<@TestComponent15>
    }
    function.def @constrain(
          %a: !array.array<3 x index>,
          %b: !array.array<9 x index> // expected-note {{prior use here}}
          ) {
      // expected-error@+1 {{use of value '%b' expects different type than prior uses: '!array.array<3 x index>' vs '!array.array<9 x index>'}}
      constrain.eq %a, %b : !array.array<3 x index>
      function.return
    }
  }
}
// -----

// Test: [constrain.eq] neither array size matches the type given
module attributes {veridise.lang = "llzk"} {
  struct.def @TestComponent16 {
    function.def @compute() -> !struct.struct<@TestComponent16> {
      %self = struct.new : !struct.struct<@TestComponent16>
      function.return %self : !struct.struct<@TestComponent16>
    }
    function.def @constrain(
          %a: !array.array<9 x index>, // expected-note {{prior use here}}
          %b: !array.array<9 x index>
          ) {
      // expected-error@+1 {{use of value '%a' expects different type than prior uses: '!array.array<3 x index>' vs '!array.array<9 x index>'}}
      constrain.eq %a, %b : !array.array<3 x index>
      function.return
    }
  }
}
// -----

// Test: [constrain.eq] lhs array size does not match the type given
module attributes {veridise.lang = "llzk"} {
  struct.def @TestComponent17 {
    function.def @compute() -> !struct.struct<@TestComponent17> {
      %self = struct.new : !struct.struct<@TestComponent17>
      function.return %self : !struct.struct<@TestComponent17>
    }
    function.def @constrain(
          %a: !array.array<3 x !felt.felt>, // expected-note {{prior use here}}
          %b: !array.array<3 x index>
          ) {
      // expected-error@+1 {{use of value '%a' expects different type than prior uses: '!array.array<3 x index>' vs '!array.array<3 x !felt.felt>'}}
      constrain.eq %a, %b : !array.array<3 x index>
      function.return
    }
  }
}
// -----

// Test: [constrain.eq] rhs array size does not match the type given
module attributes {veridise.lang = "llzk"} {
  struct.def @TestComponent18 {
    function.def @compute() -> !struct.struct<@TestComponent18> {
      %self = struct.new : !struct.struct<@TestComponent18>
      function.return %self : !struct.struct<@TestComponent18>
    }
    function.def @constrain(
          %a: !array.array<3 x index>,
          %b: !array.array<3 x !felt.felt> // expected-note {{prior use here}}
          ) {
      // expected-error@+1 {{use of value '%b' expects different type than prior uses: '!array.array<3 x index>' vs '!array.array<3 x !felt.felt>'}}
      constrain.eq %a, %b : !array.array<3 x index>
      function.return
    }
  }
}
// -----

// Test: [constrain.eq] neither array size matches the type given
module attributes {veridise.lang = "llzk"} {
  struct.def @TestComponent19 {
    function.def @compute() -> !struct.struct<@TestComponent19> {
      %self = struct.new : !struct.struct<@TestComponent19>
      function.return %self : !struct.struct<@TestComponent19>
    }
    function.def @constrain(
          %a: !array.array<3 x !felt.felt>, // expected-note {{prior use here}}
          %b: !array.array<3 x !felt.felt>
          ) {
      // expected-error@+1 {{use of value '%a' expects different type than prior uses: '!array.array<3 x index>' vs '!array.array<3 x !felt.felt>'}}
      constrain.eq %a, %b : !array.array<3 x index>
      function.return
    }
  }
}
// -----

// Test: [constrain.eq] outside of a function body
module attributes {veridise.lang = "llzk"} {
    %a = felt.const 7653
    %b = felt.const 34572
    // expected-error@+1 {{'constrain.eq' op only valid within a 'function.def' with 'function.allow_constraint' attribute}}
    constrain.eq %a, %b : !felt.felt
}
// -----

// Test: [constrain.in] outside of a function body
module attributes {veridise.lang = "llzk"} {
    %a = arith.constant 433 : index
    %b = arith.constant 535 : index
    %z = array.new %a, %b: !array.array<2 x index>
    // expected-error@+1 {{'constrain.in' op only valid within a 'function.def' with 'function.allow_constraint' attribute}}
    constrain.in %z, %a : !array.array<2 x index>
}
// -----

// Test: [constrain.eq] attempt to assign to an SSA value but it has no result
module attributes {veridise.lang = "llzk"} {
  struct.def @Component20 {
    function.def @constrain(%a: !felt.felt, %b: !array.array<5 x !felt.felt>) {
      // expected-error@+1 {{cannot name an operation with no results}}
      %c = constrain.in %b, %a : !array.array<5 x !felt.felt>
      function.return
    }

    function.def @compute() -> !struct.struct<@Component20> {
      %self = struct.new : !struct.struct<@Component20>
      function.return %self : !struct.struct<@Component20>
    }
  }
}
// -----

// Test: [constrain.eq] attempt to assign to an SSA value but it has no result
module attributes {veridise.lang = "llzk"} {
  struct.def @Component21 {
    function.def @constrain(%a: !felt.felt, %b: !felt.felt) {
      // expected-error@+1 {{cannot name an operation with no results}}
      %c = constrain.eq %a, %b : !felt.felt
      function.return
    }

    function.def @compute() -> !struct.struct<@Component21> {
      %self = struct.new : !struct.struct<@Component21>
      function.return %self : !struct.struct<@Component21>
    }
  }
}
// -----

// Test: [constrain.eq] LHS and RHS types do not unify
module attributes {veridise.lang = "llzk"} {
  struct.def @Component22 {
    function.def @constrain(%a: !felt.felt, %b: index) {
      // expected-error@+1 {{'constrain.eq' op failed to verify that rhs type matches with lhs type}}
      constrain.eq %a, %b : !felt.felt, index
      function.return
    }

    function.def @compute() -> !struct.struct<@Component22> {
      %self = struct.new : !struct.struct<@Component22>
      function.return %self : !struct.struct<@Component22>
    }
  }
}
// -----

// Test: [constrain.in] RHS and LHS element types do not unify
module attributes {veridise.lang = "llzk"} {
  struct.def @Component23 {
    function.def @constrain(%a: !array.array<4 x !felt.felt>, %b: index) {
      // expected-error@+1 {{'constrain.in' op failed to verify that rhs type matches with lhs element type}}
      constrain.in %a, %b : !array.array<4 x !felt.felt>, index
      function.return
    }

    function.def @compute() -> !struct.struct<@Component23> {
      %self = struct.new : !struct.struct<@Component23>
      function.return %self : !struct.struct<@Component23>
    }
  }
}
// -----

// Test: cannot use string type with [constrain.eq] op
module attributes {veridise.lang = "llzk"} {
  struct.def @Component24 {
    function.def @compute(%a: !string.string, %b: !string.string) -> !struct.struct<@Component24> {
      %self = struct.new : !struct.struct<@Component24>
      function.return %self : !struct.struct<@Component24>
    }
    function.def @constrain(%a: !string.string, %b: !string.string) {
      // expected-error@+1 {{'constrain.eq' op operand #0 must be any LLZK type, excluding non-Signal struct and string types, but got '!string.string'}}
      constrain.eq %a, %b : !string.string
      function.return
    }
  }
}
// -----

// Test: cannot use string type with [constrain.eq] op (at depth)
module attributes {veridise.lang = "llzk"} {
  struct.def @Component25 {
    function.def @compute(%a: !array.array<2 x !string.string>, %b: !array.array<2 x !string.string>) -> !struct.struct<@Component25> {
      %self = struct.new : !struct.struct<@Component25>
      function.return %self : !struct.struct<@Component25>
    }
    function.def @constrain(%self: !struct.struct<@Component25>, %a: !array.array<2 x !string.string>, %b: !array.array<2 x !string.string>) {
      // expected-error@+1 {{'constrain.eq' op operand #0 must be any LLZK type, excluding non-Signal struct and string types, but got '!array.array<2 x !string.string>'}}
      constrain.eq %a, %b : !array.array<2 x !string.string>
      function.return
    }
  }
}
