<!-- HTML header for doxygen 1.13.2-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LLZK: LLZK Language Specification</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<!-- doxygen-awesome extensions -->
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeParagraphLink.init()
    DoxygenAwesomeInteractiveToc.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LLZK<span id="projectnumber">&#160;0.1.0</span>
   </div>
   <div id="projectbrief">Veridise&#39;s ZK Language IR</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('syntax.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">LLZK Language Specification</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul>
  <li class="level1">
    <a href="#autotoc_md22">Syntax</a>
  </li>
  <li class="level1">
    <a href="#autotoc_md23">Types</a>
  </li>
  <li class="level1">
    <a href="#autotoc_md24">Special Constructs</a>
  </li>
  <li class="level1">
    <a href="#autotoc_md25">Semantic Rules</a>
  </li>
  <li class="level1">
    <a href="#translation-guidelines">Translation Guidelines</a>
  </li>
</ul>
</div>
<div class="textblock"><p><a class="anchor" id="md_doc_2doxygen_23__syntax"></a></p>
<dl class="section warning"><dt>Warning</dt><dd>This documentation is out of date and will be updated shortly.</dd></dl>
<h1><a class="anchor" id="autotoc_md22"></a>
Syntax</h1>
<div class="fragment"><div class="line">program = program_header, { include | global_const | global_func | component } ;</div>
<div class="line">program_header = &quot;#dialect&quot;, identifier ;</div>
<div class="line">include = &quot;#include&quot;, ? path ? ;</div>
<div class="line">global_const = identifier, &quot;:=&quot;, const_expr, &quot;;&quot; , [ annotation ] ;</div>
<div class="line">global_func = &quot;function.def&quot;, identifier, parameters, &quot;-&gt;&quot;, type, body ;</div>
<div class="line">component = &quot;struct&quot;, identifier, [ struct_params ],</div>
<div class="line">                        &quot;{&quot;, fields, funcs, &quot;}&quot;, [ annotation ] ;</div>
<div class="line">struct_params = &quot;&lt;&quot;, [ identifier, { &quot;,&quot; , identifier }], &quot;&gt;&quot; ;</div>
<div class="line">fields = { identifier, &quot;:&quot;, type, &quot;,&quot; , [ annotation ] } ;</div>
<div class="line">funcs = ( compute , constrain ) | ( constrain, compute ) ;</div>
<div class="line">compute = &quot;function.def compute&quot;, parameters, body ;</div>
<div class="line">constrain = &quot;function.def constrain&quot;, parameters, body ;</div>
<div class="line">parameters = &quot;(&quot;, [ param, { &quot;,&quot; , param }], &quot;)&quot; ;</div>
<div class="line">param = identifier, &quot;:&quot;, type ;</div>
<div class="line">body = &quot;{&quot;, { statement, &quot;;&quot;, [ annotation ] }, &quot;}&quot; ;</div>
<div class="line">statement = emit | return | while | if | assign | expr_call ;</div>
<div class="line">emit = &quot;emit&quot;, ( expr_contains | ( expr, &quot;=&quot;, expr ) ) ;</div>
<div class="line">return = &quot;return&quot;, expr ;</div>
<div class="line">while = &quot;while&quot;, expr , body ;</div>
<div class="line">if = &quot;if&quot;, expr, body, [ &quot;else&quot;, body ] ;</div>
<div class="line">assign = lvalue, &quot;:=&quot;, expr ;</div>
<div class="line">const_expr = expr ; (* semantics require const type *)</div>
<div class="line">expr = literal | lvalue | expr_array | expr_call | expr_ref |</div>
<div class="line">       expr_contains | expr_binop | expr_monop | expr_special ;</div>
<div class="line">expr_array = &quot;[&quot;, list_of_expr, &quot;]&quot; ;</div>
<div class="line">expr_call = [ expr_call_base ], expr_call_target ;</div>
<div class="line">expr_call_base = lvalue, [ &quot;&lt;&quot;, const_expr, &quot;&gt;&quot; ], &quot;.&quot; ;</div>
<div class="line">expr_call_target = identifier, &quot;(&quot;, list_of_expr, &quot;)&quot; ;</div>
<div class="line">expr_ref = lvalue, &quot;.&quot;, identifier ;</div>
<div class="line">expr_contains = lvalue, &quot;in&quot;, lvalue ;</div>
<div class="line">expr_binop = expr, binop, expr ;</div>
<div class="line">list_of_expr = [ expr, { &quot;,&quot; , expr }] ;</div>
<div class="line">binop = binop_arith | binop_bit | binop_compare | binop_logic ;</div>
<div class="line">binop_arith = &quot;+&quot; | &quot;-&quot; | &quot;*&quot; | &quot;/&quot; | &quot;%&quot; ;</div>
<div class="line">binop_bit = &quot;&amp;&quot; | &quot;|&quot; | &quot;^&quot; | &quot;&lt;&lt;&quot; | &quot;&gt;&gt;&quot; ;</div>
<div class="line">binop_compare = &quot;&gt;&quot; | &quot;&lt;&quot; | &quot;&gt;=&quot; | &quot;&lt;=&quot; | &quot;==&quot; | &quot;!=&quot; ;</div>
<div class="line">binop_logic = &quot;&amp;&amp;&quot; | &quot;||&quot; ;</div>
<div class="line">expr_monop = ( &quot;(&quot;, expr, &quot;)&quot; ) | ( monop, expr ) ;</div>
<div class="line">monop = monop_arith | monop_bit | monop_logic ;</div>
<div class="line">monop_arith = &quot;-&quot; ;</div>
<div class="line">monop_bit = &quot;~&quot; ;</div>
<div class="line">monop_logic = &quot;!&quot; ;</div>
<div class="line">expr_special = &quot;nondetFelt()&quot;;</div>
<div class="line">lvalue = identifier | lvalue_array ;</div>
<div class="line">lvalue_array = lvalue, &quot;[&quot;, lvalue, &quot;]&quot; ;</div>
<div class="line">type = { type_modifier }, type_base ;</div>
<div class="line">type_modifier = &quot;pub&quot; | &quot;const&quot; ;</div>
<div class="line">type_base = identifier | ( type, &quot;[&quot;, const_expr, &quot;]&quot; ) ;</div>
<div class="line">constant = literal | identifier ;</div>
<div class="line">identifier = letter, { letter | digit } ;  (* and symbols if needed *)</div>
<div class="line">annotation = &quot;#&quot;, ? anything except newline ? ;</div>
<div class="line">letter = ? all capital and lowercase characters ? ;</div>
<div class="line">literal = ( digit, { digit } ) | ( &quot;0x&quot;, hexit, { hexit } ) ;</div>
<div class="line">hexit = digit | &quot;A&quot; | &quot;B&quot; | &quot;C&quot; | &quot;D&quot; | &quot;E&quot; | &quot;F&quot;</div>
<div class="line">              | &quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot; | &quot;e&quot; | &quot;f&quot; ;</div>
<div class="line">digit = &quot;0&quot; | &quot;1&quot; | &quot;2&quot; | &quot;3&quot; | &quot;4&quot; | &quot;5&quot; | &quot;6&quot; | &quot;7&quot; | &quot;8&quot; | &quot;9&quot; ;</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md23"></a>
Types</h1>
<ul>
<li><code>bool</code>: subtype of Felt in [0,1]</li>
<li><code>int</code>: machine integer</li>
<li><code>Felt</code>: finite field element</li>
<li><code>struct</code> (component): Aggregate type with named heterogeneous elements. Generally correlates to components/functions in the source language. Constituent elements may be local variables, subcomponents, and/or called functions.</li>
<li><code>array&lt;E&gt;</code>: elements can be any type, including other array type for multi-dimensional arrays. We may need this type to have a built-in field named <code>len</code> that returns the length of the array.</li>
<li><code>const&lt;T&gt;</code>: <b>modifier</b> on types to denote it’s a compile-time constant. Semantic analysis can infer <code>const</code> based on usage of literal values, etc. but it can also be specified in the IR in which case the semantic analysis must ensure it’s correct or give an error. The semantics of several syntax nodes require a <code>const</code> value, such as the <code>i</code> in <code>GetWeight&lt;i&gt;.compute()</code>. Global function return type can be <code>const</code> and that would allow such a function to be used in these locations.</li>
</ul>
<h1><a class="anchor" id="autotoc_md24"></a>
Special Constructs</h1>
<ul>
<li><code>nondetFelt()</code>: can be used as the parameter of a <code>constrain()</code> function when the expression from the source language can be elided because it cannot be used as part of a constraint. For example, expressions containing bitwise operators cannot be part of a constraint.</li>
<li>A special element can be added to a <code>struct</code> to store the return value of a component (i.e. <code>synthetic_return</code> in the examples above).</li>
</ul>
<h1><a class="anchor" id="autotoc_md25"></a>
Semantic Rules</h1>
<ul>
<li><code>emit</code> must only appear in <code>constrain()</code> functions and <code>return</code> only in global functions.</li>
<li><code>constrain()</code> only calls <code>constrain()</code> and <code>compute()</code> only calls <code>compute()</code>. Either can call arbitrary functions but not each other.</li>
<li>Function parameters are pass-by-value.</li>
<li>For references like <code>a.b</code>, a field named <code>b</code> must be present in the component <code>a</code>. For references like <code>c</code>, if a field named <code>c</code> is present in the current component the reference refers to that field instance, otherwise it refers to a local named <code>c</code> within that function, with type inferred from the RHS of the expression where <code>c</code> is defined.</li>
<li>Global constants cannot be modified/assigned.</li>
</ul>
<h1><a class="anchor" id="translation-guidelines"></a>
Translation Guidelines</h1>
<ul>
<li>The modifier <code>pub</code> can be added before the type on <code>compute()</code> and <code>constrain()</code> parameters to denote which elements of the domain are public (default is private). Likewise, it can be used on struct fields to denote which fields are part of the co-domain (i.e. public outputs).</li>
<li>The frontend translation for each source language to ZK IR should be as simple as possible since this will be repeated effort for each source language. Any transformations or optimizations on the ZK IR should be done in a shared module run on the internal representation after translation.</li>
<li>Constant integer parameters on a <code>struct</code> can be used to avoid creating multiple versions of that <code>struct</code> in the IR. A later pass can flatten the IR if needed by the client analysis. This is even where multiple dialects of the IR could be used, with a flattened dialect disallowing these parameters.</li>
<li>If loop bounds are known, <code>scf.for</code> should be used to make loop bounds explicit. However, <code>scf.while</code> is available to handle the general case if that information is not available but this should not be used in the <code>constrain()</code> function.</li>
<li>Global functions (i.e. user-defined or helper functions, located outside of <code>struct</code> definitions) are pure. There is no global state and parameters are pass-by-value (i.e. a copy is created) so there is nothing external they can modify.</li>
<li>Source line information should be handled via MLIR so frontend components must provide that information when building the MLIR AST.</li>
<li>Only the outermost module should have the <code>veridise.lang = "zkir"</code> attribute (because the presence of that attribute is used to determine the “root” symbol table for symbol resolution).</li>
<li>All inner modules must be named because their names are used to build the fully-qualified path names for symbol references.</li>
<li>All references to functions and types must use fully-qualified paths. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.13.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
    <li class="footer">Copyright 2025 Veridise Inc. under the Apache License v2.0.</li>
  </ul>
</div>
</body>
</html>
